IMDATGAT TITLE 'IMP DATA GATHERER'
*        COPYRIGHT (C) 1991  PRYCROFT SIX PTY LTD
         LCLC  &IMPDATE
&IMPDATE SETC  '&SYSDATE'
         AIF   ('&IMPDATE'(3,1) NE '/').GOTDATE
&MM      SETC  '&IMPDATE'(1,2)          GET MM.
&DD      SETC  '&IMPDATE'(4,2)          GET DD.
&YY      SETC  '&IMPDATE'(7,2)          GET YY.
&IMPDATE SETC  '&YY..&MM..&DD'          GET YY.MM.DD (FACOM &SYSDATE).
.GOTDATE ANOP
IMDATGAT CSECT
IMDATGAT AMODE 31
IMDATGAT RMODE 24
         USING IMDATGAT,R15
         B     GATSTART           BRANCH AROUND HEADER.
         DC    AL1(47)
         DC    CL47'IMDATGAT COPYRIGHT (C) 1991 PRYCROFT SIX P/L   '
DGBASEAD DC    A(0)               POINTER TO DATA IN STORAGE.
         DROP  R15                IMDATGAT.
         DC    CL8'&IMPDATE'
GATSTART STM   R14,R12,12(R13)    SAVE REGISTERS.
         LR    R12,R15            COPY BASE REGISTER.
         LA    R11,2048(,R12)
         LA    R11,2048(,R11)     LOAD SECOND BASE REGISTER.
         LA    R10,2048(,R11)
         LA    R10,2048(,R10)     LOAD THIRD BASE REGISTER.
         USING IMDATGAT,R12,R11,R10
         L     R2,GATCOMAD        POINT TO COMMON AREA.
         ST    R2,8(,R13)
         ST    R13,4(,R2)         CHAIN SAVE AREAS.
         LR    R13,R2
         USING IMGATCOM,R13
         L     R15,INITADDR       GET INITIALIZATION ROUTINE EP.
         BASR  R14,R15            CALL INITIALIZATION ROUTINE.
         TM    GATFLAGS,TSU       RUNNING IN A TSO USER ADDRESS SPACE?
         BZ    DGDEAMON           NO, RUNNING AS AN IMPISH DEMON.
         OI    GATFLAGS,NOTRACK   YES, DO NOT TRACK CURRENT SMF.
         B     GATSOINT           GO INITIALIZE.
         SPACE
DGDEAMON ENQ   (IMPMAJOR,IMPMINOR,E,IMINRLEN,SYSTEM),RET=USE
         LTR   R15,R15            DATA GATHERER ALREADY ACTIVE?
         BZ    GATINIT            NO, GO INITIALIZE.
         LA    R1,GATWTO01        YES, ISSUE NOTIFICATION OF THIS.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         L     R13,4(,R13)        POINT TO CALLER'S SAVE AREA.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         LA    R15,12             LOAD RETURN CODE.
         BSM   0,R14              RETURN WITHOUT INITIALIZING.
         SPACE
         DS    0F
GATCOMAD DC    V(IMGATCOM)        COMMON AREA ADDRESS.
GATGETAD DC    V(IMGATGET)        GET RECORD ROUTINE ADDRESS.
DGPURGAD DC    V(IMDGPURG)        OLD ENTRY PURGE ROUTINE ADDRESS.
DELAY    DC    F'500'             WAIT DURATION IS FIVE SECONDS.
GATWTO00 WTO   'PRY630I  IMPGAT STARTED',                              +
               ROUTCDE=(2,11),MF=L
GATWTO01 WTO   'PRY631I  IMPGAT STOPPING BECAUSE ALREADY ACTIVE',      +
               ROUTCDE=(2,11),MF=L
GATWTO02 WTO   'PRY632I  IMPGAT STOPPING BECAUSE OF STOP COMMAND',     +
               ROUTCDE=(2,11),MF=L
GATWTO09 WTO   'PRY639I  IMPGAT HAS PURGED DATA FROM DAY YYYY.DDD',    +
               ROUTCDE=(2,11),MF=L
OPURGEDT EQU   GATWTO09+44,9
MSKWTO09 DC    XL9'40202021204B202020'
         DS    0F
IMPMAJOR DC    CL8'IMPMAJOR'      ENQUEUE MAJOR NAME.
IMPMINOR DC    C'IMPDATGAT ACTIVE'    ENQ MINOR NAME.
IMINRLEN EQU   *-IMPMINOR         ENQUEUE MINOR NAME LENGTH.
         DS    0F
MDSTSUP0 MODESET KEY=ZERO,MODE=SUP,MF=L
MDSTPROB MODESET KEY=NZERO,MODE=PROB,MF=L
         SPACE
ESTAEON  ESTAE GATABEND,PARAM=SCANZONE,MF=L
         SPACE
SCANZONE DC    A(DATGAT70)        START OF DATA EXTRACTION CODE.
INITADDR DC    A(IMDGINIT)        END OF DATA EXTRACTION CODE.
RETRYADR DC    A(GATRETRY)        RETRY ADDRESS AFTER EXTRACTION ABEND.
RECTIME  DC    F'0'               SMF RECORD TIME (HHMMSSTH).
CHNTRIPL DC    A(0)               ADDRESS OF FIRST+LAST+COUNT TRIPLET.
CHNENTRY DC    A(0)               ADDRESS OF ENTRY TO INSERT IN CHAIN.
CHNPTROF DC    F'0'               OFFSET OF NEXT AND PREVIOUS POINTERS.
CHNCMPOF DC    F'0'               OFFSET OF COMPARE OR "KEY" FIELD.
CHNCMPLN DC    F'0'               LENGTH OF COMPARE OR "KEY" FIELD.
*
*        STORAGE PARTITIONING TABLE.
*
*        3 FULLWORDS PER ENTRY:
*          1. HIGH-WATER-MARK - ADDRESS OF NEXT ENTRY TO ALLOCATE.
*          2. MAXIMUM VALUE ALLOWED FOR H-W-M WITHOUT ANOTHER GETMAIN.
*          3. GETMAIN SIZE TO BE USED FOR THIS ENTRY TYPE.
*
DGHWM    EQU   0                  ADDRESS TO BE USED FOR NEXT ENTRY.
DGMAX    EQU   4                  MAXIMUM VALUE FOR DGHWM THIS GETMAIN.
DGSIZE   EQU   8                  GETMAIN SIZE FOR RMF DATA.
STGTABLE DS    0F                 STORAGE TABLE.
*              HWM  MAX  SIZE
         DC    F'0',F'0',F'65536'  0 - DEFAULT.
         DC    F'0',F'0',F'4096'   1 - BASE, SYSTEM, ID LISTS.
         DC    F'0',F'0',F'65536'  2 - RMF AND PDLF INTERVALS.
         DC    F'0',F'0',F'65536'  3 - CHANNEL PATHS.
         DC    F'0',F'0',F'65536'  4 - DEVICES.
         DC    F'0',F'0',F'65536'  5 - PERFORMANCE GROUPS.
         DC    F'0',F'0',F'65536'  6 - PAGE DATA SET.
         DC    F'0',F'0',F'4096'   7 - DATA SET NAME.
         DC    F'0',F'0',F'65536'  8 - DATA SET EVENT.
         DC    F'0',F'0',F'4096'   9 - PROGRAM NAME.
         DC    F'0',F'0',F'65536' 10 - JOB STEP END EVENT.
         DC    F'0',F'0',F'16384' 11 - TAPE VOLUME SERIAL NUMBER.
         DC    F'0',F'0',F'32768' 12 - TAPE VOLUME EVENT.
         DC    F'0',F'0',F'4096'  13 - JOB NAME.
MAXENTYP EQU   13                 MAXIMUM ENTRY TYPE VALUE.
STENTSIZ DC    H'12'              SIZE OF A STORAGE TABLE ENTRY.
         TITLE 'SUBROUTINES'
DGNEWENT DS    0H                 CREATE AN ENTRY IN VIRTUAL STORAGE.
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         SLR   R8,R8              CLEAR FOR INSERT.
         CLI   ENTRYTYP,MAXENTYP  VALID ENTRY TYPE?
         BH    GOTENTYP           NO, USE DEFAULT.
         TM    GATFLAGS,TSU       TIME SHARING USER?
         BO    GOTENTYP           YES, GO FOR CAPACITY, NOT SPEED.
         IC    R8,ENTRYTYP        LOAD VALID TYPE IF STARTED TASK.
GOTENTYP MH    R8,STENTSIZ        MULTIPLY BY SIZE FOR INDEX.
         LA    R8,STGTABLE(R8)    POINT TO TABLE ENTRY FOR THIS TYPE.
         LR    R7,R0              COPY REQUESTED LENGTH.
         BCTR  R7,0               DECREMENT FOR EXECUTE.
         L     R6,DGHWM(,R8)      GET ADDRESS OF NEW ENTRY.
         LA    R1,1(R7,R6)        DERIVE NEW HIGH WATER MARK.
         C     R1,DGMAX(,R8)      USED ALL OF GETMAINED AREA?
         BH    DGFREEMN           YES, GETMAIN SOME MORE STORAGE.
         ST    R1,DGHWM(,R8)      NO, SAVE FUTURE ENTRY'S ADDRESS.
         EX    R7,DGNEWCLR        ERASE ANY RESIDUAL DATA.
         CH    R7,=H'255'         ENTRY SIZE MORE THAN 256 BYTES?
         BNH   ENTCLRED           NO, STORAGE SET TO ZEROS.
         XC    0(256,R6),0(R6)    YES, ERASE ANY RESIDUAL DATA
         EX    R7,DGNEWCLX        FROM THE WHOLE ENTRY.
ENTCLRED ST    R6,20(,R13)        SAVE THIS ENTRY'S ADDRESS IN R0 SLOT.
         MVI   ENTRYTYP,0         RESET STORAGE ENTRY TYPE CODE.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         BR    R14                RETURN TO CALLER.
         SPACE
DGFREEMN L     R0,DGMAX(,R8)      POINT PAST CURRENT AREA.
         LR    R1,R6              POINT TO UNUSABLE REMNANT.
         SR    R0,R1              GET SIZE OF UNUSABLE REMNANT.
         BNP   DGETMAIN           EXACTLY ALL OF THE AREA WAS USED.
         FREEMAIN RU,LV=(0),A=(1),SP=23
DGETMAIN L     R0,DGSIZE(,R8)     LOAD THE GETMAIN CHUNK SIZE.
         GETMAIN RU,LV=(0),LOC=(ANY),SP=23
         ST    R1,DGHWM(,R8)      SUPPLY THE STARTING HIGH-WATER-MARK.
         CLI   DGHWM(R8),0        NEW STORAGE IN EXTENDED REGION?
         BE    DGCALLPG           NO, TIME TO FREE UP SOME SPACE.
         A     R1,DGSIZE(,R8)     POINT PAST GETMAINED AREA.
         ST    R1,DGMAX(,R8)      SAVE MAX ADDRESS BEFORE NEW GETMAIN.
         LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS.
         B     DGNEWENT           REDRIVE THE CALLER'S REQUEST.
         SPACE
DGCALLPG L     R0,DGSIZE(,R8)     LOAD THE GETMAIN CHUNK SIZE.
         FREEMAIN RU,LV=(0),A=(1),SP=23
         ST    R15,DGMAX(,R8)     FORCE NEW GETMAIN FOR ENTRY TYPE.
         L     R15,DGPURGAD       POINT PURGE ROUTINE ENTRY POINT.
         L     R1,DGBASEAD        POINT TO DATA REPOSITORY.
         BASR  R14,R15            PURGE OLD ENTRIES TO RECLAIM SPACE.
         USING DGBASE,R1
         ZAP   WORK,DGPURGDT      COPY THE LATEST PURGE DATE.
         DROP  R1                 DGBASE.
         AP    WORK,=P'1900000'   CONVERT YEAR TO FOUR DIGITS.
         MVC   OPURGEDT,MSKWTO09  FORMAT LATEST PURGE DATE.
         ED    OPURGEDT,WORK+4
         LA    R1,GATWTO09        REPORT LATEST PURGE DATE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         L     R15,DGBASEAD       POINT TO DATA REPOSITORY.
         USING DGBASE,R15
DGNJSEOK L     R1,24(,R13)        RESTORE CALLER'S RECORD POINTER.
         USING SMF70HDR,R1
         CLC   DGPURGDT,SMF70DTE  IS RECORD FROM AFTER PURGE DATE?
         BNL   DGNPURGE           NO, DISCARD RECORD.
         CLI   SMF70RTY,70        IS THIS AN RMF SMF RECORD?
         BL    DGETMAIN           NO, REDRIVE THE GETMAIN.
         CLI   SMF70RTY,127       IS THIS A PDLF SMF RECORD?
         BE    DGNINTCK           YES, CHECK INTERVAL START DATE.
         CLI   SMF70RTY,79        IS THIS AN RMF SMF RECORD?
         BH    DGETMAIN           NO, REDRIVE THE GETMAIN.
         DROP  R1                 SMF70HDR.
DGNINTCK CLC   DGPURGDT,WORK+4    IS INTERVAL FROM AFTER PURGE DATE?
         BL    DGETMAIN           YES, REDRIVE THE GETMAIN.
         DROP  R15                DGBASE.
DGNPURGE LM    R14,R12,12(R13)    RESTORE CALLER'S REGISTERS.
         B     GATMAIN            DISCARD RECORD.
         SPACE
DGNEWCLR XC    0(0,R6),0(R6)      <<< EXECUTED >>>
DGNEWCLX XC    256(0,R6),256(R6)  <<< EXECUTED >>>
         SPACE 2
CHAINADD DS    0H                 INSERT NEW ENTRY INTO CHAIN.
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         L     R3,CHNTRIPL        ROOT FIRST/LAST/COUNT TRIPLET PTR.
         ICM   R0,15,0(R3)        ANY FIRST ENTRY?
         BZ    CHAINNEW           NO, THIS IS THE ONLY ENTRY SO FAR.
         L     R6,CHNENTRY        POINT TO ENTRY TO ADD.
         LR    R4,R3              COPY ROOT TRIPLET POINTER.
         S     R4,CHNPTROF        POINT TO BEFORE ROOT POINTERS.
         LR    R1,R6              POINT TO NEW ENTRY.
         A     R1,CHNCMPOF        POINT TO "KEY".
         L     R8,CHNCMPLN        GET "KEY" LENGTH.
         BCTR  R8,0               DECREMENT FOR COMPARE EXECUTE.
CHAINLP  A     R4,CHNPTROF        POINT TO NEXT/PREVIOUS POINTERS.
         ICM   R4,15,4(R4)        POINT TO PREVIOUS ENTRY.
         BZ    CHAINFST           START OF CHAIN, SO NEW GOES FIRST.
         LR    R7,R4
         A     R7,CHNCMPOF        POINT TO THIS ENTRY'S "KEY".
         EX    R8,CHNCOMPR        IS NEW ENTRY BEFORE THIS ENTRY?
         BL    CHAINLP            YES, GO BACK ANOTHER ONE.
         LR    R7,R4
         A     R7,CHNPTROF        NO, POINT TO ENTRY'S POINTERS.
         A     R6,CHNPTROF        POINT TO NEW ENTRY'S POINTERS.
         ST    R4,4(,R6)          SET NEW BACKWARD POINTER.
         MVC   0(4,R6),0(R7)      SET NEW FORWARD POINTER.
         MVC   0(4,R7),CHNENTRY   SET PREVIOUS FORWARD POINTER.
         ICM   R5,15,0(R6)        POINT TO NEXT ENTRY.
         BZ    CHAINLST           NEW ENTRY IS LAST ENTRY.
         A     R5,CHNPTROF        POINT TO NEXT ENTRY'S POINTERS.
         MVC   4(4,R5),CHNENTRY   SET NEXT BACKWARD POINTER.
         B     CHAINCNT           GO UPDATE CHAIN ENTRY COUNT.
CHAINFST A     R6,CHNPTROF        POINT TO NEW ENTRY'S POINTERS.
         L     R5,0(,R3)          POINT TO OLD FIRST ENTRY.
         A     R5,CHNPTROF        POINT TO OLD FIRST ENTRY'S POINTERS.
         MVC   0(4,R6),0(R3)      SET NEW FORWARD POINTER FROM OLD 1ST.
         MVC   4(4,R5),CHNENTRY   SET OLD 1ST BACK PTR TO NEW ENTRY.
         MVC   0(4,R3),CHNENTRY   SET FIRST POINTER TO NEW ENTRY.
         B     CHAINCNT           GO UPDATE CHAIN ENTRY COUNT.
CHAINNEW MVC   0(4,R3),CHNENTRY   SET FIRST POINTER TO NEW ENTRY.
CHAINLST MVC   4(4,R3),CHNENTRY   SET LAST POINTER TO NEW ENTRY.
CHAINCNT LA    R0,1
         A     R0,8(,R3)          INCREMENT ENTRY COUNTER.
         ST    R0,8(,R3)
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         BR    R14                RETURN TO CALLER.
CHNCOMPR CLC   0(0,R1),0(R7)      <<< EXECUTED >>>
         SPACE 2
PICTOBIN DS    0H                 CONVERT EBCDIC NUMBER TO BINARY.
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         ST    R0,WORK            PUT CHARACTERS IN STORAGE.
         MVI   WORK+4,0           CLEAR A FLAG BYTE.
         SLR   R0,R0              ZERO ACCUMULATOR.
         LA    R1,4               GET COUNT OF BYTES TO SCAN.
         SLR   R2,R2              CLEAR FOR WORK.
         LA    R3,WORK            POINT TO FIRST POSSIBLE DIGIT.
PICLOOP  NI    0(R3),X'0F'        REMOVE ZONE.
         CLI   0(R3),10           VALID DECIMAL?
         BL    PICDIGIT           YES, PROCESS THE DIGIT.
         MVI   WORK+4,1           NO, FLAG DECIMAL POINT ENCOUNTERED.
         B     PICNEXT            GO LOOK AT THE NEXT BYTE.
PICDIGIT MH    R0,PICHW10         PROMOTE PREVIOUS DIGITS.
         IC    R2,0(,R3)          GET THIS DIGIT.
         AR    R0,R2              ADD THIS DIGIT TO ACCUMULATOR.
         OI    WORK+4,2           SET DIGIT PROCESSED FLAG.
         TM    WORK+4,3           FIRST DIGIT AFTER DECIMAL POINT?
         BO    PICOKAY            YES, TENTHS IS ONLY FRACTION HANDLED.
PICNEXT  LA    R3,1(,R3)          POINT TO NEXT CANDIDATE DIGIT.
         BCT   R1,PICLOOP         PROCESS IT IF APPROPRIATE.
         MH    R0,PICHW10         CONVERT INTEGER TO TENTHS.
PICOKAY  ST    R0,20(,R13)        SAVE BINARY TENTHS IN R0 SLOT.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         BR    R14                RETURN TO CALLER.
         SPACE
PICHW10  DC    H'10'              TEN.
         SPACE 2
CENTITOD DS    0H                 CONVERT BINARY CENTISECS TO HHMMSSTH.
         SLR   R4,R4              CLEAR FOR DIVIDE - R5 HAS INPUT TIME.
         D     R4,=F'6000'        CONVERT TO MINUTES.
         CVD   R4,WORK            GET CENTISECONDS NOT IN MINUTES.
         L     R2,WORK+4          GET 000SSTHF.
         SRL   R2,4               SHIFT OUT DECIMAL SIGN.
         SLR   R4,R4              CLEAR FOR DIVIDE.
         D     R4,=F'60'          GET HOURS AND MINUTES.
         CVD   R4,WORK            GET MINUTES NOT IN HOURS.
         L     R4,WORK+4          GET 00000MMF.
         SRL   R4,4               SHIFT OUT DECIMAL SIGN.
         SLL   R4,16              PUT IN CORRECT POSITION.
         OR    R2,R4              GET 00MMSSTH.
         CVD   R5,WORK            GET HOURS.
         L     R5,WORK+4          GET 00000HHF.
         SRL   R5,4               SHIFT OUT DECIMAL SIGN.
         SLL   R5,24              PUT IN CORRECT POSITION.
         OR    R2,R5              GET HHMMSSTH - R2 HAS OUTPUT TIME.
         BR    R14                RETURN TO CALLER.
         SPACE 2
GREG2JUL DS    0H                 CONVERT CYYMMDDF TO 0CYYDDDF.
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         LR    R1,R0              COPY INPUT DATE.
         SLL   R1,4               GET YY IN TOP BYTE.
         ST    R1,WORK            PLACE IN WORK AREA.
         MVI   MONTHTAB+5,28      ASSUME NOT A LEAP YEAR.
         TM    WORK,X'01'         ODD NUMBERED YEAR?
         BO    LEAPOKAY           YES, NOT A LEAP YEAR.
         TM    WORK,X'12'         LEAP YEAR?
         BM    LEAPOKAY           NO.
         MVI   MONTHTAB+5,29      YES.
LEAPOKAY XC    WORK,WORK          CLEAR A WORK AREA.
         STCM  R0,B'0110',WORK+6
         NI    WORK+6,X'0F'
         OI    WORK+7,X'0F'       GET 00000MMF.
         CVB   R1,WORK            GET THE BINARY MONTH NUMBER.
         LA    R2,MONTHTAB        POINT TO DAYS PER MONTH TABLE.
         SLR   R3,R3              CLEAR ACCUMULATOR.
MNTHLOOP AH    R3,0(,R2)          ADD DAYS OF A PREVIOUS MONTH.
         LA    R2,2(,R2)          POINT TO NEXT MONTH'S ENTRY.
         BCT   R1,MNTHLOOP
         XC    WORK,WORK          CLEAR A WORK AREA.
         STH   R0,WORK+6
         NI    WORK+6,X'0F'       GET 00000DDF.
         CVB   R1,WORK            GET BINARY DAY OF MONTH.
         AR    R3,R1              GET JULIAN DAY OF YEAR.
         CVD   R3,WORK            GET DECIMAL JULIAN DAY OF YEAR.
         OI    WORK+7,X'0F'       GET REQUIRED DECIMAL POSITIVE SIGN.
         SRL   R0,4               GET 0CYYMMDD FROM INPUT DATE.
         ICM   R0,3,WORK+6        GET 0CYYDDDF.
         ST    R0,20(,R13)        SAVE VALUE IN R0 SLOT.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         BR    R14                RETURN TO CALLER.
         SPACE
MONTHTAB DC    AL2(0,31,28,31,30,31,30,31,31,30,31,30)
         SPACE 2
DGPUTMSG DS    0H                 ISSUE WTO OR TPUT AS APPROPRIATE.
         TM    GATFLAGS,TSU       RUNNING IN A TSO USER ADDRESS SPACE?
         BO    DGTSUPUT           YES, PERFORM A TPUT.
         WTO   MF=(E,(1))         NO, ISSUE THE WTO.
         BR    R14                RETURN TO CALLER.
DGTSUPUT LA    R15,4              GET FOUR.
         LH    R0,0(,R1)          GET WTO LENGTH.
         SR    R0,R15             GET TPUT LENGTH.
         LA    R1,4(,R1)          GET MESSAGE ADDRESS.
         TPUT  (1),(0),R          SHOW ON TSO TERMINAL, NOT OS CONSOLE.
         BR    R14                RETURN TO CALLER.
         SPACE 2
MASKTEST DS    0H                 COMPARE TWO STRINGS WITH '*' WILD.
         CLI   0(R3),C'*'         WILD CARD IN MASK?
         BE    MASKOKAY           YES, SAME AS EQUAL.
         CLC   0(1,R3),0(R2)      COMPARE MASK TO INPUT STRING.
         BNER  R14                RETURN TO CALLER IF NOT EQUAL.
MASKOKAY LA    R3,1(,R3)          POINT TO NEXT BYTE OF MASK.
         LA    R2,1(,R2)          POINT TO NEXT BYTE OF INPUT STRING.
         BCT   R0,MASKTEST        TEST NEXT CHARACTER.
         BR    R14                EXACT MATCH SO RETURN TO CALLER.
         SPACE 2
**********************************************
* FIXED - FLOATING POINT CONVERSION ROUTINES *
**********************************************
         SPACE
* ROUTINE FIXFL CONVERTS A BINARY NUMBER IN GENERAL REGISTER 0 TO A
* FLOATING POINT NUMBER IN FLOATING POINT REGISTER 0.
* ROUTINE FLFIX CONVERTS A FLOATING POINT NUMBER IN FLOATING POINT
* REGISTER 0 TO A BINARY NUMBER IN GENERAL REGISTER 0.
         SPACE
FIXFL    X     R0,FLCONST+4
         ST    R0,FLTEMP+4
         X     R0,FLCONST+4
         LD    E0,FLTEMP
         SD    E0,FLCONST
         BR    R14
         SPACE
FLFIX    AD    E0,FIXCONST
         STD   E0,FIXTEMP
         L     R0,FIXTEMP+4
         BR    R14
         SPACE
*                                 FLOATING POINT REGISTER EQUATES.
E0       EQU   0
E2       EQU   2
E4       EQU   4
E6       EQU   6
         DS    0D
FLCONST  DC    XL8'4E00000080000000'
FIXCONST DC    XL8'4F08000000000000'
FLTEMP   DC    XL8'4E00000000000000'
FIXTEMP  DC    XL8'0000000000000000'
         TITLE 'INITIALIZATION'
*        BECOME NON-SWAPPABLE TO FACILITATE CROSS-MEMORY ACCESS.
         SPACE
GATINIT  DS    0H
         MODESET MF=(E,MDSTSUP0)  GET INTO SYSTEM STATE.
         XC    WORK,WORK          CLEAR AN ECB.
         LA    R1,WORK            POINT TO A MAKESHIFT ECB.
         SYSEVENT TRANSWAP        BECOME NON-SWAPPABLE.
         LTR   R15,R15            WAS ANYTHING TO BE DONE?
         BNZ   TRANOKAY           NO, ALREADY NON-SWAPPABLE.
         WAIT  ECB=WORK           YES, WAIT TILL TRANSWAP COMPLETE.
TRANOKAY OI    GATFLAGS,NONSWAP   REMEMBER CURRENTLY NON-SWAPPABLE.
         MODESET MF=(E,MDSTPROB)  REVERT TO PROBLEM STATE.
         SPACE 2
*        CREATE THE BASE ENTRY FOR THE WHOLE DATA STRUCTURE.
         SPACE
GATSOINT LA    R0,DGBASLEN        GET THE BASE ENTRY LENGTH.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       CREATE THE BASE ENTRY.
         LR    R1,R0              COPY THE DATA AREA ADDRESS.
         USING DGBASE,R1
         LA    R0,DGSMFTYP        GET NUMBER OF SMF EVENT TYPES.
         ST    R0,DGSMFCNT        SAVE IT FOR POST-PROCESSING.
         ST    R1,DGBASEAD        SAVE THE DATA AREA ADDRESS.
         MVC   DGBASEID,DGSTRING  LOAD THE HEADER STRING.
         DROP  R1                 DGBASE.
         SPACE
         ESTAE MF=(E,ESTAEON)     ENABLE TASK ABNORMAL END EXIT.
         SPACE
         LA    R1,GATWTO00        ISSUE NOTIFICATION OF IMPGAT START.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         B     GATMAIN            START READING SMF RECORDS.
         TITLE 'MAIN PROCESSING LOOP'
GATWAIT  DS    0H
         STIMER WAIT,BINTVL=DELAY WAIT A BIT.
GATMAIN  DS    0H
         SLR   R0,R0              ENTRY CODE FOR RECORD GET.
         L     R1,COMMADDR        POINT TO MODIFY/STOP ECB ADDRESS.
         L     R1,0(,R1)          POINT TO MODIFY/STOP ECB.
         TM    0(R1),X'40'        HAS THE ECB BEEN POSTED?
         BZ    CALLGET            NO, SEE IF ANY MORE INPUT DATA YET.
         LA    R0,4               YES, TELL IMGATGET TO CLOSE FILE.
CALLGET  L     R15,GATGETAD       GET GET RECORD ROUTINE ENTRY ADDRESS.
         BASSM R14,R15            CALL IT.
         LTR   R15,R15            ANY RECORD RETURNED?
         BZ    DGDIGEST           YES, PROCESS IT.
         CH    R15,=H'4'          NO, TERMINATION IN PROGRESS?
         BH    GATWAIT            NO, WAIT A BIT THEN CHECK FOR DATA.
         TM    GATFLAGS,TSU       RUNNING UNDER TSO USER?
         BO    GATTERM            YES, TERMINATE WITH DATA IN STORAGE.
         LA    R1,GATWTO02        ISSUE NOTIFICATION OF TERMINATION.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
*                                 DEQ, FREE STORAGE AND TERMINATE.
         DEQ   (IMPMAJOR,IMPMINOR,IMINRLEN,SYSTEM),RET=NONE
         MODESET MF=(E,MDSTSUP0)  GET INTO SYSTEM STATE.
         SYSEVENT OKSWAP          BECOME SWAPPABLE.
         MODESET MF=(E,MDSTPROB)  REVERT TO PROBLEM STATE.
         FREEMAIN RU,SP=23        FREE ALL THE STORAGE.
GATTERM  DS    0H                 COMMON TERMINATION CODE.
         ESTAE 0                  DISABLE TASK ABNORMAL END EXIT.
         L     R13,4(,R13)        POINT TO CALLER'S SAVE AREA.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         SLR   R15,R15            SET ZERO RETURN CODE.
         BSM   0,R14              RETURN TO CALLER IN CALLER'S AMODE.
         SPACE 2
DGDIGEST DS    0H
         USING SMF70HDR,R1
         L     R2,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R2
         CLC   DGPURGDT,SMF70DTE  IS RECORD FROM AFTER PURGE DATE?
         BNL   GATMAIN            NO, DISCARD RECORD.
         DROP  R2                 DGBASE.
         ICM   R5,15,SMF70TME     GET THE SMF TIME OF DAY.
         BAS   R14,CENTITOD       CONVERT TO HOURS/MINUTES/SECONDS.
         ST    R2,RECTIME         SAVE FOR TESTING AND LOADING.
         TM    SELFLAGS,DSET      COLLECTING SMF DATA SET EVENTS?
         BZ    TESTPGMS           NO, TEST FOR OTHER DATA.
         SPACE
*              DIVERT NON-RMF SMF RECORDS OF INTEREST.
         SPACE
         CLI   SMF70RTY,14        TYPE 14 SMF RECORD?
         BE    DGDSET14           YES, PROCESS IT.
         CLI   SMF70RTY,15        TYPE 15 SMF RECORD?
         BE    DGDSET14           YES, PROCESS IT.
         CLI   SMF70RTY,17        TYPE 17 SMF RECORD?
         BE    DGDSET17           YES, PROCESS IT.
         CLI   SMF70RTY,18        TYPE 18 SMF RECORD?
         BE    DGDSET18           YES, PROCESS IT.
         CLI   SMF70RTY,61        TYPE 61 SMF RECORD?
         BE    DGDSET61           YES, PROCESS IT.
         CLI   SMF70RTY,62        TYPE 62 SMF RECORD?
         BE    DGDSET62           YES, PROCESS IT.
         CLI   SMF70RTY,64        TYPE 64 SMF RECORD?
         BE    DGDSET64           YES, PROCESS IT.
         CLI   SMF70RTY,65        TYPE 65 SMF RECORD?
         BE    DGDSET65           YES, PROCESS IT.
         CLI   SMF70RTY,66        TYPE 66 SMF RECORD?
         BE    DGDSET66           YES, PROCESS IT.
         TM    SMF70RTY,X'80'     USER SMF RECORD TYPE?
         BZ    TESTPGMS           NO, TEST FOR OTHER DATA.
         CLC   =H'100',0(R1)      YES, POSSIBLY WORTH INVESTIGATING?
         BH    GATMAIN            NO, TOO SHORT SO DISCARD.
         CLC   =C'DSR',21(R1)     HSM DAILY STATISTICS RECORD?
         BE    HSMSTATS           YES.
         CLC   =C'VSR',21(R1)     HSM VOLUME STATISTICS RECORD?
         BE    HSMSTATS           YES.
         CLC   HSMFNTYP,5(R1)     HSM FUNCTION RECORD?
         BE    DGDSETHF           YES.
         CLC   =C'**HSM***',34(R1)
         BE    DGDSETHF           YES, THAT WAS LUCKY!
         CLC   =C'*H*S*M*',35(R1)
         BE    DGDSETHF           YES, THAT WAS LUCKY!
         B     GATMAIN            PROBABLY NOT.
HSMSTATS IC    R15,5(,R1)         GET THE SMF RECORD TYPE.
         LA    R15,1(,R15)        ADD ONE.
         STC   R15,HSMFNTYP       SAVE THE HSM FUNCTION RECORD TYPE.
         B     GATMAIN
TESTPGMS CLI   SMF70RTY,30        TYPE 30 SMF RECORD?
         BNE   TESTPERF           NO, TEST FOR PERFORMANCE DATA.
         TM    SELFLAGS,PGMS      COLLECTING SMF JOB STEP END EVENTS?
         BZ    GATMAIN            NO, DISCARD THE RECORD.
         L     R9,=A(DATGAT30)    YES, LOAD ROUTINE ENTRY POINT.
         BR    R9                 CALL PROCESSING ROUTINE.
TESTPERF TM    SELFLAGS,PERF      COLLECTING PERFORMANCE HISTORY?
         BZ    GATMAIN            NO, FETCH ANOTHER RECORD.
         CLI   SMF70RTY,6         IS THIS A TYPE 6 SMF RECORD?
         BE    CHKSYSID           YES, OBTAIN MATCHING SYSTEM ENTRY.
         CLI   SMF70RTY,57        IS THIS A TYPE 57 SMF RECORD?
         BE    CHKSYSID           YES, OBTAIN MATCHING SYSTEM ENTRY.
         DROP  R1                 SMF70HDR.
         SPACE
*              PROCESS FUJITSU PDLF SMF RECORDS.
         SPACE
         USING PDLFHDR,R1
         DS    0H
         CLI   PDLFRTY,127        TYPE 127 SMF RECORD?
         BNE   TEST4RMF           NO, GO TEST FOR RMF RECORD.
         CLC   =C'S001',PDLFCRID  SYSTEM PERFORMANCE RECORD?
         BE    PDLFDATE           YES.
         CLC   =C'I001',PDLFCRID  I/O PERFORMANCE RECORD?
         BE    PDLFDATE           YES.
         CLC   =C'P001',PDLFCRID  PERFORMANCE GROUP PERFORMANCE RECORD?
         BE    PDLFDATE           YES.
         B     GATMAIN            NOT A KNOWN PDLF RECORD, GET ANOTHER.
PDLFDATE ICM   R0,15,PDLFCDTE     LOAD PDLF INTERVAL START DATE.
         BAS   R14,GREG2JUL       CONVERT TO JULIAN DATE.
         ST    R0,WORK+4          SAVE PDLF INTERVAL START DATE.
         ICM   R0,15,PDLFCTME     LOAD PDLF INTERVAL START TIME.
         SRL   R0,4               CONVERT HHMMSSTH TO 0HHMMSST.
         ST    R0,WORK            SAVE PDLF INTERVAL START TIME.
         OI    WORK+3,X'0F'       CONVERT 0HHMMSST TO 0HHMMSSF.
         L     R5,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R5
         CLC   DGPURGDT,WORK+4    IS INTERVAL FROM AFTER PURGE DATE?
         BNL   GATMAIN            NO, DISCARD RECORD.
         B     CHKSYSID
         DROP  R1,R5              PDLFHDR, DGBASEAD.
         SPACE
*              PROCESS SUITABLE RMF SMF RECORDS.
         SPACE
         USING SMF70HDR,R1
TEST4RMF DS    0H
         TM    SMF70FLG,SMF70SUT+SMF70VXA+SMF70OS   SUBTYPES+XA+VS2?
         BNO   GATMAIN            NO, FETCH ANOTHER RECORD.
         CLI   SMF70RTY,70        IS THIS AN RMF SMF RECORD?
         BL    GATMAIN            NO, FETCH ANOTHER RECORD.
         CLI   SMF70RTY,79        IS THIS AN RMF SMF RECORD?
         BH    GATMAIN            NO, FETCH ANOTHER RECORD.
         CLI   SMF70RTY,70        IS THIS A TYPE 70 SMF RECORD?
         BE    CHKSYSID           YES, PROCESS IT.
         CLI   SMF70RTY,71        IS THIS A TYPE 71 SMF RECORD?
         BE    CHKSYSID           YES, PROCESS IT.
         CLI   SMF70RTY,72        IS THIS A TYPE 72 SMF RECORD?
         BNE   CHECK73            NO.
         CLC   =H'1',SMF70STY     SUBTYPE 1?
         BNE   GATMAIN            NO, IGNORE RMF MONITOR III DATA.
         B     CHKSYSID           YES, PROCESS IT.
CHECK73  CLI   SMF70RTY,73        IS THIS A TYPE 73 SMF RECORD?
         BE    CHKSYSID           YES, PROCESS IT.
         CLI   SMF70RTY,74        IS THIS A TYPE 74 SMF RECORD?
         BNE   CHECK75            NO.
         CLC   =H'1',SMF70STY     SUBTYPE 1?
         BNE   GATMAIN            NO, IGNORE RMF MONITOR III DATA.
         B     CHKSYSID           YES, PROCESS IT.
CHECK75  CLI   SMF70RTY,75        IS THIS A TYPE 75 SMF RECORD?
         BE    CHKSYSID           YES, PROCESS IT.
         CLI   SMF70RTY,78        IS THIS A TYPE 78 SMF RECORD?
         BNE   GATMAIN            NO.
         CLC   =H'2',SMF70STY     SUBTYPE 2?
         BNE   GATMAIN            NO, I/O QUEUING DATA.
CHKSYSID L     R3,DGBASEAD        YES, POINT TO THE BASE ENTRY.
         USING DGBASE,R3
         LA    R3,DGFSTSYS        POINT TO SYSTEM ENTRY ANCHORS.
         DROP  R3                 DGBASE.
DGSYSLP  ICM   R3,15,0(R3)        POINT TO THE NEXT SYSTEM ENTRY.
         BZ    MKNEWSYS           NO MORE SYSTEM ENTRIES SO MAKE ONE.
         USING DGSYSTEM,R3
         CLC   DGSYSID,SMF70SID   FOUND THE MATCHING SYSTEM ENTRY?
         BE    SYSMATCH           YES.
         B     DGSYSLP            NO, TRY THE NEXT ONE.
         SPACE
MKNEWSYS LA    R0,DGSYSLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R3,R0              POINT TO THE NEW ENTRY.
         MVC   DGSYSID,SMF70SID   LOAD THE SMF SYSTEM IDENTIFIER.
         L     R2,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R2
         ICM   R4,15,DGLSTSYS     POINT TO THE LAST SYSTEM ENTRY.
         BNZ   CHAINSYS           GO UPDATE SYSTEM ENTRY CHAINS.
         ST    R3,DGFSTSYS        NO LAST SO THIS IS THE FIRST SYSTEM.
         B     LASTSYS            IT IS ALSO THE LAST SYSTEM.
CHAINSYS ST    R3,0(,R4)          MAKE OLD LAST POINT TO NEW ONE.
         ST    R4,DGSYSPRV        MAKE THIS ONE POINT BACK TO OLD LAST.
LASTSYS  ST    R3,DGLSTSYS        NEW ONE IS NOW THE LAST ONE.
         LA    R0,1
         A     R0,DGNUMSYS        INCREMENT THE SYSTEM ENTRY COUNTER.
         ST    R0,DGNUMSYS
         DROP  R2                 DGBASE.
         SPACE
SYSMATCH LA    R4,DGFSTINT        POINT TO THE INTERVAL ENTRY POINTERS.
         CLI   SMF70RTY,6         IS THIS JES2/JES3/PSF/XWTR OUTPUT?
         BE    INTEVENT           YES, RECORD EVENT IN INTERVAL STATS.
         CLI   SMF70RTY,57        IS THIS NJE OUTPUT?
         BE    INTEVENT           YES, RECORD EVENT IN INTERVAL STATS.
         CLI   SMF70RTY,127       IS THIS A PDLF SMF RECORD?
         BE    DGINTLP            YES, TIME AND DATE ALREADY IN WORK.
         CLC   =H'1',SMF70PRN     IS ONE RMF PRODUCT SECTION PRESENT?
         BNE   GATMAIN            NO, IGNORE RECORD AND FETCH ANOTHER.
         ICM   R2,15,SMF70PRS     YES, GET ITS OFFSET.
         ALR   R2,R1              POINT TO IT.
         OI    DGSYSFLG,DGRMFSYS  FLAG RMF DATA FOUND FOR THIS SYSTEM.
         USING SMF70PRO,R2
         MVC   WORK(4),SMF70IST   COPY RMF INTERVAL START TIME.
         MVC   WORK+4(4),SMF70DAT COPY RMF INTERVAL START DATE.
         L     R5,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R5
         CLC   DGPURGDT,WORK+4    IS INTERVAL FROM AFTER PURGE DATE?
         BNL   GATMAIN            NO, DISCARD RECORD.
         DROP  R5                 DGBASEAD.
DGINTLP  LR    R5,R4              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R4,15,4(R4)        POINT TO THE PREVIOUS INTERVAL ENTRY.
         BZ    MKNEWINT           NO MORE INTERVAL ENTRIES SO MAKE ONE.
         USING DGRMFINT,R4
         CLC   DGINTDAT,WORK+4    COMPARE THE DATES.
         BH    DGINTLP            RECORD FROM EARLIER DATE SO BACK UP.
         BL    MKNEWINT           RECORD FROM LATER DATE SO MAKE ENTRY.
         CLC   DGINTTIM,WORK      COMPARE THE TIMES.
         BH    DGINTLP            RECORD FROM EARLIER TIME SO BACK UP.
         BE    INTCHNOK           FOUND THE MATCHING RMF INTERVAL.
*        BL    MKNEWINT           RECORD FROM LATER TIME SO MAKE ENTRY.
         DROP  R4                 DGRMFINT.
         SPACE
MKNEWINT LA    R0,DGINTLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,2         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGRMFINT,R6
         LA    R0,1
         ST    R0,DGCPUCNT        ASSUME UNIPROCESSOR FOR THE MOMENT.
         L     R0,RECTIME         GET THE SMF TIME OF DAY.
         IC    R0,=X'F0'          OVERLAY SECONDS FRACTION WITH SIGN.
         SRL   R0,4               GET SMF RECORD TIME IN 0HHMMSSF.
         ST    R0,DGINTEND        SAVE AS THE INTERVAL END TIME.
         MVC   DGINTPRL,DGCUMPRL  LOAD INTERVAL PRINT LINE COUNTS.
         MVC   DGINTPRX,DGCUMPRX
         MVC   DGINTPRN,DGCUMPRN
         L     R0,DGINTPRL
         A     R0,DGINTPRX
         A     R0,DGINTPRN        GET TOTAL PRINT LINES THIS INTERVAL.
         C     R0,DGMAXPRT        MORE THAN PREVIOUS HIGHEST?
         BNH   CLRPRCUM           NO, CLEAR THE PRINT ACCUMULATORS.
         ST    R0,DGMAXPRT        YES, UPDATE THE HIGH-WATER-MARK.
CLRPRCUM SLR   R0,R0
         ST    R0,DGCUMPRL        RESET ACCUMULATORS.
         ST    R0,DGCUMPRX
         ST    R0,DGCUMPRN
         MVC   DGINTTIM,WORK      COPY RMF INTERVAL START TIME.
         MVC   DGINTDAT,WORK+4    COPY RMF INTERVAL START DATE.
         CLI   SMF70RTY,127       IS THIS A PDLF SMF RECORD?
         BNE   DORMFINT           NO, IT IS AN RMF SMF RECORD.
         DROP  R1                 SMF70HDR.
         USING PDLFHDR,R1
         SLR   R9,R9
         ICM   R9,3,PDLFCITV      GET PDLF INTERVAL LENGTH IN MINUTES.
         CVD   R9,WORK            GET THE DECIMAL MINUTE COUNT.
         SRP   WORK,5,0           CONVERT TO MMSS000C.
         ZAP   DGINTDUR,WORK      SAVE IT.
         OI    DGINTDUR+3,X'0F'   CONVERT TO MMSS000F.
         M     R8,=F'60000'       CONVERT MINUTES TO MILLISECONDS.
         ST    R9,DGINTSIZ        SAVE IT.
         B     INTDUROK           INTERVAL DURATION NOW CALCULATED.
         DROP  R1                 PDLFHDR.
         SPACE
         USING SMFRECD,R1
INTEVENT L     R2,RECTIME         GET THE SMF TIME OF DAY.
         IC    R2,=X'F0'          OVERLAY SECONDS FRACTION WITH SIGN.
         SRL   R2,4               GET SMF RECORD TIME IN 0HHMMSSF.
         ICM   R6,15,DGLSTINT     POINT TO THE LAST INTERVAL ENTRY.
         BZ    DGCUMNOW           NO INTERVALS YET, ACCUMULATE FOR NOW.
SMFINTLP CLC   DGINTDAT,SMF6DTE   EVENT DATE AFTER LAST INTERVAL?
         BL    DGCUMNOW           YES, ACCUMULATE FOR NOW.
         BH    SMFINTBK           NO, BEFORE SO GET PREVIOUS INTERVAL.
         C     R2,DGINTTIM        IS TIME BEFORE INTERVAL START TIME?
         BL    SMFINTBK           YES, SO GET PREVIOUS INTERVAL.
         CLC   DGINTTIM,DGINTEND  START TIME AFTER END TIME?
         BH    SMFGOTIT           YES, USE THIS INTERVAL.
         C     R2,DGINTEND        EVENT TIME BEFORE INTERVAL END?
         BL    SMFGOTIT           YES, USE THIS INTERVAL.
         C     R6,DGLSTINT        POINTING TO LAST INTERVAL?
         BE    DGCUMNOW           YES, SO ACCUMULATE FOR NOW.
         B     GATMAIN            NO, MISSING INTERVAL SO DISCARD.
SMFINTBK ICM   R6,15,DGINTPRV     POINT TO PREVIOUS INTERVAL.
         BNZ   SMFINTLP           CHECK ITS TIME.
         B     GATMAIN            MISSING INTERVAL SO DISCARD.
DGCUMNOW SLR   R6,R6              CLEAR INTERVAL ENTRY POINTER.
SMFGOTIT CLI   SMF6RTY,6          IS THIS JES2/JES3/PSF/XWTR OUTPUT?
         BE    DGSYSOUT           YES, ACCUMULATE OUTPUT VOLUMES.
         CLI   SMF57RTY,57        IS THIS NJE OUTPUT?
         BE    DGNJEOUT           YES, ACCUMULATE OUTPUT VOLUMES.
         B     GATMAIN            UNKNOWN TYPE - SHOULDN'T HAPPEN.
DGSYSOUT ICM   R9,15,SMF6NLR      GET THE NUMBER OF LOGICAL RECORDS.
         BZ    GATMAIN            FORGET IT IF NONE.
         TM    SMF6SBS+1,X'0F'    WAS EXTERNAL WRITER USED?
         BZ    DGXRITER           YES, EITHER THAT OR CA-DISPATCH.
         LTR   R6,R6              ADDING TO AN EXISTING INTERVAL ENTRY?
         BNZ   MOREOLDL           YES.
         A     R9,DGCUMPRL        NO.
         ST    R9,DGCUMPRL        UPDATE LOCAL PRINT LINE COUNT.
         B     GATMAIN
MOREOLDL A     R9,DGINTPRL
         ST    R9,DGINTPRL        UPDATE LOCAL PRINT LINE COUNT.
         B     PRMAXCHK
DGXRITER LTR   R6,R6              ADDING TO AN EXISTING INTERVAL ENTRY?
         BNZ   MOREOLDX           YES.
         A     R9,DGCUMPRX        NO.
         ST    R9,DGCUMPRX        UPDATE XWTR PRINT LINE COUNT.
         B     GATMAIN
MOREOLDX A     R9,DGINTPRX
         ST    R9,DGINTPRX        UPDATE XWTR PRINT LINE COUNT.
         B     PRMAXCHK
DGNJEOUT CLI   SMF57SBS+1,2       JES2?
         BNE   DGNJEOP3           NO.
         ICM   R9,15,SMF57CNT     GET THE NUMBER OF LOGICAL RECORDS.
         B     DGNJECHK
DGNJEOP3 CLI   SMF57SBS+1,5       JES3?
         BNE   GATMAIN            NO, UNKNOWN SUBSYSTEM.
         CLC   =C'OP',32(R1)      OUTPUT?
         BNE   GATMAIN            NO, PROBABLY 'JB' FOR JOB STREAM.
         ICM   R9,15,158(R1)      GET THE NUMBER OF LOGICAL RECORDS.
DGNJECHK BZ    GATMAIN            FORGET IT IF NONE.
         LTR   R6,R6              ADDING TO AN EXISTING INTERVAL ENTRY?
         BNZ   MOREOLDN           YES.
         A     R9,DGCUMPRN
         ST    R9,DGCUMPRN        UPDATE NJE PRINT LINE COUNT.
         B     GATMAIN
MOREOLDN A     R9,DGINTPRN
         ST    R9,DGINTPRN        UPDATE NJE PRINT LINE COUNT.
PRMAXCHK L     R9,DGINTPRL
         A     R9,DGINTPRX
         A     R9,DGINTPRN        GET TOTAL PRINT LINES THIS INTERVAL.
         C     R9,DGMAXPRT        MORE THAN PREVIOUS HIGHEST?
         BNH   GATMAIN            NO, RECORD NOW PROCESSED.
         ST    R9,DGMAXPRT        YES, UPDATE THE HIGH-WATER-MARK.
         B     GATMAIN
         DROP  R1                 SMFRECD.
         SPACE
         USING SMF70HDR,R1
DORMFINT MVC   DGINTDUR,SMF70INT  COPY RMF INTERVAL DURATION.
         ZAP   WORK,DGINTDUR      COPY RMF INTERVAL DURATION.
         SRP   WORK,64-5,0        GET INTERVAL WHOLE MINUTES.
         MP    WORK,=PL2'60'      CONVERT MINUTES TO SECONDS.
         SRP   WORK,3,0           CONVERT SECONDS TO MILLISECONDS.
         AP    WORK,DGINTDUR+1(3) ADD TRUNCATED MILLISECONDS.
         CVB   R0,WORK            GET BINARY DURATION MILLISECONDS.
         ST    R0,DGINTSIZ        SAVE IT.
INTDUROK MVI   DGCPUTIL,X'80'     FLAG NO-TYPE-70-YET.
         MVI   DGNUCPCT,X'80'     FLAG NO-TYPE-71-YET.
         MVI   DGPAGEIN,X'80'     FLAG NO-TYPE-71-YET.
         LTR   R4,R4              ENCOUNTERED END OF BACKWARD CHAIN?
         BNZ   LATERINT           NO, THIS INTERVAL IS LATER.
         ICM   R0,15,DGNUMINT     YES, ANY INTERVALS ON CHAIN?
         BZ    FIRSTINT           NO, THIS IS THE FIRST RECORD READ.
         ST    R5,DGINTNXT        YES, NEW POINTS TO OLD NEXT ENTRY.
         ST    R6,4(,R5)          OLD NEXT POINTS BACK TO NEW ENTRY.
         ST    R6,DGFSTINT        NEW ENTRY IS NOW THE FIRST ENTRY.
         B     CTINTENT           RMF INTERVAL ENTRY CHAIN NOW UPDATED.
FIRSTINT ST    R6,DGFSTINT        NEW ENTRY IS NOW THE FIRST ENTRY.
         ST    R6,DGLSTINT        NEW ENTRY IS NOW THE LAST ENTRY.
         B     CTINTENT           RMF INTERVAL ENTRY CHAIN NOW UPDATED.
LATERINT ST    R4,DGINTPRV        NEW ENTRY POINTS BACK TO OLD ENTRY.
         MVC   DGINTNXT,0(R4)     OLD FORWARD POINTER IS NEW FWD PTR.
         ST    R6,4(,R5)          POINT BACK TO NEW ENTRY.
         ST    R6,0(,R4)          POINT FORWARD TO NEW ENTRY.
         DROP  R6                 DGRMFINT.
CTINTENT LA    R0,1
         A     R0,DGNUMINT        INCREMENT THE INTERVAL ENTRY COUNTER
         ST    R0,DGNUMINT        FOR THIS SYSTEM.
         LR    R4,R6              COPY THE INTERVAL ENTRY ADDRESS.
         USING DGRMFINT,R4
INTCHNOK DS    0H
         CLI   SMF70RTY,127       IS THIS A PDLF SMF RECORD?
         BE    DATGAT7F           YES, EXECUTE RELEVANT CODE.
         MVC   RMFSAMCT,SMF70SAM  GET RMF SAMPLE COUNT FOR INTERVAL.
         MVC   RMFSMFRL,SMF70SRL  GET RMF SMF RECORD LEVEL INDICATOR.
         CLI   SMF70RTY,70        IS THIS A TYPE 70 SMF RECORD?
         BE    DATGAT70           YES, PROCESS IT.
         CLI   SMF70RTY,71        IS THIS A TYPE 71 SMF RECORD?
         BE    DATGAT71           YES, PROCESS IT.
         CLI   SMF70RTY,72        IS THIS A TYPE 72 SMF RECORD?
         BE    DATGAT72           YES, PROCESS IT.
         CLI   SMF70RTY,73        IS THIS A TYPE 73 SMF RECORD?
         BE    DATGAT73           YES, PROCESS IT.
         CLI   SMF70RTY,74        IS THIS A TYPE 74 SMF RECORD?
         BE    DATGAT74           YES, PROCESS IT.
         CLI   SMF70RTY,75        IS THIS A TYPE 75 SMF RECORD?
         BE    DATGAT75           YES, PROCESS IT.
         CLI   SMF70RTY,78        IS THIS A TYPE 78 SMF RECORD?
         BE    DATGAT78           YES, PROCESS IT.
         B     GATMAIN            IGNORE UNWANTED RECORD.
         TITLE 'PROCESS RMF SMF RECORD TYPE 70'
DATGAT70 DS    0H                 PROCESS RMF SMF RECORD TYPE 70.
         CLC   =H'1',SMF70STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         MVC   DGPRSMNM,BLANKS    LOAD BLANKS FOR PR/SM LPAR NAME.
         ICM   R15,3,SMF70BCN     ANY PR/SM DATA SECTIONS PRESENT?
         BZ    NOTPARTN           NO, ASSUME NOT PR/SM PARTITION.
         SLR   R15,R15
         ICM   R15,1,SMF70PTN     GET THE PR/SM PARTITION NUMBER.
         BZ    LPAR0CMF           ASSUME FIRST ENTRY, PROBABLY CMF.
         DROP  R2                 SMF70PRO.
         SPACE
         ST    R15,WORK           SAVE THE PR/SM PARTITION NUMBER.
         CLM   R15,3,SMF70BCN     ENOUGH PR/SM DATA SECTIONS PRESENT?
         BH    NOTPARTN           NO, ASSUME NOT PR/SM PARTITION.
         BCTR  R15,0              DECREMENT FOR INDEX.
         LTR   R15,R15            ANY PR/SM DATA SECTIONS PRESENT?
         BM    NOTPARTN           NO, ASSUME NOT PR/SM PARTITION.
         MVC   WORK(2),SMF70BCL   GET PR/SM DATA SECTION LENGTH.
         MH    R15,WORK           GET INDEX INTO PR/SM DATA SECTIONS.
LPAR0CMF ICM   R0,15,SMF70BCS     GET OFFSET TO FIRST DATA SECTION.
         ALR   R15,R0             GET OFFSET TO REQUIRED DATA SECTION.
         ALR   R15,R1             POINT TO REQUIRED PR/SM DATA SECTION.
         USING SMF70BCT,R15
         MVC   DGPRSMNM,SMF70LPM  COPY LOGICAL PARTITION NAME.
         MVC   DGCPUCNT+2(2),SMF70BDN  COPY LOGICAL PROCESSOR COUNT.
         MVC   WORK+4(4),SMF70BDS COPY SECTION SKIP COUNT.
         DROP  R15                SMF70BCT.
         SLR   R7,R7
         ICM   R7,3,SMF70BVL      GET LPAR DATA SECTION LENGTH.
         ICM   R15,15,SMF70BVS    GET OFFSET TO LPAR DATA SECTION.
         ALR   R15,R1             POINT TO FIRST LPAR DATA SECTION.
         ICM   R0,15,WORK+4       GET COUNT OF SECTIONS TO SKIP.
         BZ    CPSKIPOK           DO NOT SKIP ANY SECTIONS.
CPSKIPLP ALR   R15,R7             SKIP OVER ONE LPAR DATA SECTION.
         BCT   R0,CPSKIPLP
         USING SMF70BPD,R15
CPSKIPOK SLR   R8,R8
         SLR   R9,R9              ZERO ACCUMULATOR.
         L     R0,DGCPUCNT        GET CENTRAL PROCESSOR COUNT.
         XC    WORK(16),WORK      CLEAR SOME BYTES.
LPARLOOP CLI   SMF70BPS,X'FF'     DEDICATED PROCESSOR?
         BE    NOTPARTN           YES, TREAT AS PR/SM PARTITION.
         SLR   R5,R5              CLEAR FOR INSERT.
         ICM   R5,3,SMF70VPA      GET LOGICAL PARTITION ADDRESS.
         LA    R5,WORK(R5)        POINT TO A FLAG BYTE.
         MVI   0(R5),X'FF'        REMEMBER THE CP NUMBER USED HERE.
         ICM   R5,15,SMF70PDT+4   LOAD DISPATCH MICROSECONDS.
         ALR   R9,R5              ACCUMULATE DISPATCH MICROSECONDS.
         BC    12,CPOFLWOK        THERE IS NO OVERFLOW.
         LA    R8,1(,R8)          COUNT OVERFLOW.
CPOFLWOK ALR   R15,R7             POINT TO THE NEXT LPAR DATA SECTION.
         BCT   R0,LPARLOOP        PROCESS NEXT LPAR FOR THIS OS IF ANY.
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         SLR   R8,R8
         D     R8,DGCPUCNT        AVERAGE UTILIZATION OVER EACH CP.
         ST    R9,DGCPUTIL        SAVE AVERAGE CPU BUSY FOR THIS MVS.
         ICM   R15,15,SMF70BVS    GET OFFSET TO LPAR DATA SECTION.
         ALR   R15,R1             POINT TO FIRST LPAR DATA SECTION.
         SLR   R0,R0
         ICM   R0,3,SMF70BVN      GET COUNT OF LPAR DATA SECTIONS.
         SLR   R8,R8
         SLR   R9,R9              ZERO ACCUMULATOR.
CPLPARLP CLI   SMF70BPS,X'FF'     DEDICATED PROCESSOR?
         BE    NEXTCPLP           YES, CAN'T BE SHARING WITH THIS LPAR.
         SLR   R5,R5              CLEAR FOR INSERT.
         ICM   R5,3,SMF70VPA      GET LOGICAL PARTITION ADDRESS.
         LA    R5,WORK(R5)        POINT TO A FLAG BYTE.
         CLI   0(R5),X'FF'        CAN LPAR USE THIS CP?
         BNE   NEXTCPLP           NO, DO NOT COUNT IT.
         ICM   R5,15,SMF70PDT+4   YES, LOAD DISPATCH MICROSECONDS.
         ALR   R9,R5              ACCUMULATE DISPATCH MICROSECONDS.
         BC    12,NEXTCPLP        THERE IS NO OVERFLOW.
         LA    R8,1(,R8)          COUNT OVERFLOW.
NEXTCPLP ALR   R15,R7             POINT TO THE NEXT LPAR DATA SECTION.
         BCT   R0,CPLPARLP        PROCESS NEXT LPAR IF ANY.
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         SLR   R8,R8
         D     R8,DGCPUCNT        AVERAGE UTILIZATION OVER EACH CP.
         ST    R9,DGCPBUSY        SAVE AVERAGE PHYSICAL CPU BUSY.
         B     DGCPOKAY           NOW HAVE CPU AVERAGE UTILIZATION.
         DROP  R15                SMF70BPD.
         SPACE
NOTPARTN SLR   R0,R0
         ICM   R0,3,SMF70CPN      GET THE CPU DATA SECTION COUNT.
         BZ    GATMAIN            UNEXPECTED FORMAT IF NONE.
         ST    R0,DGCPUCNT        SAVE THE CENTRAL PROCESSOR COUNT.
         SLR   R2,R2              ZERO ACCUMULATOR.
         SLR   R7,R7
         ICM   R7,3,SMF70CPL      GET THE CPU DATA SECTION LENGTH.
         ICM   R15,15,SMF70CPS    GET THE CPU DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO THE FIRST CPU DATA SECTION.
         USING SMF70CPU,R15
CPWAITLP ICM   R8,15,SMF70WAT     LOAD CPU DISPATCHED WAIT TIME.
         ICM   R9,15,SMF70WAT+4
         SRDL  R8,12              CONVERT TO MICROSECONDS.
         ALR   R2,R9              ACCUMULATE WAIT MICROSECONDS.
         ALR   R15,R7             POINT TO CPU DATA SECTION IF ANY.
         BCT   R0,CPWAITLP        PROCESS NEXT CP IF ANY.
         DROP  R15                SMF70CPU.
         LR    R9,R2              GET TOTAL WAIT MICROSECONDS.
         SLR   R8,R8
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         SLR   R8,R8
         D     R8,DGCPUCNT        AVERAGE WAIT TIME OVER EACH CP.
         LA    R8,1000
         SR    R8,R9              CONVERT WAIT TO UTILIZATION.
         ST    R8,DGCPUTIL        SAVE AVERAGE CPU BUSY FOR THIS MVS.
         ST    R8,DGCPBUSY        SAVE AVERAGE PHYSICAL CPU BUSY.
         SPACE
DGCPOKAY DS    0H                 NOW CALCULATE THE AVERAGE I/O RATE.
         SLR   R0,R0
         ICM   R0,3,SMF70CPN      GET THE CPU DATA SECTION COUNT.
         BZ    GATMAIN            UNEXPECTED FORMAT IF NONE.
         SLR   R2,R2              ZERO ACCUMULATORS.
         SLR   R9,R9              ZERO ACCUMULATORS.
         SLR   R7,R7
         ICM   R7,3,SMF70CPL      GET THE CPU DATA SECTION LENGTH.
         ICM   R15,15,SMF70CPS    GET THE CPU DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO THE FIRST CPU DATA SECTION.
         USING SMF70CPU,R15
IOCOMPLP ICM   R8,15,SMF70SLH     LOAD ENTRY TO I/O SLIH COUNT.
         AR    R2,R8              ACCUMULATE IT.
         ICM   R8,15,SMF70TPI     LOAD TPI WITH CC=1 COUNT.
         AR    R9,R8              ACCUMULATE IT.
         ALR   R15,R7             POINT TO CPU DATA SECTION IF ANY.
         BCT   R0,IOCOMPLP        PROCESS NEXT CP IF ANY.
         DROP  R15                SMF70CPU.
         AR    R2,R9              GET TOTAL I/O COMPLETION COUNT.
         M     R8,=F'100000'      WANT HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         ST    R9,DGIOTPI1        SAVE TPI WITH CC=1 RATE.
         LR    R9,R2              GET TOTAL I/O COMPLETION COUNT.
         M     R8,=F'100000'      WANT HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         ST    R9,DGIORATE        SAVE TOTAL SYSTEM I/O RATE.
         C     R9,DGMAXIOR        NEW MAXIMUM I/O RATE FOR SYSTEM?
         BNH   ASIDCNTS           NO, RECORD ASID COUNT STATISTICS.
         ST    R9,DGMAXIOR        YES, SAVE IT FOR SCALING PURPOSES.
         SPACE
ASIDCNTS CLC   =H'1',SMF70ASN     ONE ASID DATA SECTION PRESENT?
         BNE   GATMAIN            NO, UNEXPECTED FORMAT.
         ICM   R15,15,SMF70ASS    GET THE ASID DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO THE FIRST CPU DATA SECTION.
         USING SMF70AID,R15
         LA    R5,DGMAXRDY        PROCESS READY USER ASID COUNTS.
         LA    R6,DGRDYLOW
         LA    R7,SMF70RMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXINU        PROCESS IN USER ASID COUNTS.
         LA    R6,DGINULOW
         LA    R7,SMF70IMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXOTU        PROCESS OUT USER ASID COUNTS.
         LA    R6,DGOTULOW
         LA    R7,SMF70OMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXWTU        PROCESS WAIT USER ASID COUNTS.
         LA    R6,DGWTULOW
         LA    R7,SMF70WMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXJOB        PROCESS BATCH JOB ASID COUNTS.
         LA    R6,DGJOBLOW
         LA    R7,SMF70BMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXSTC        PROCESS STARTED TASK ASID COUNTS.
         LA    R6,DGSTCLOW
         LA    R7,SMF70SMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXTSU        PROCESS TSO USER ASID COUNTS.
         LA    R6,DGTSULOW
         LA    R7,SMF70TMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXLRD        PROCESS LOGICAL READY ASID COUNTS.
         LA    R6,DGLRDLOW
         LA    R7,SMF70LMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXLWT        PROCESS LOGICAL WAIT ASID COUNTS.
         LA    R6,DGLWTLOW
         LA    R7,SMF70AMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXASC        PROCESS ASCH ASID COUNTS.
         LA    R6,DGASCLOW
         LA    R7,SMF70PMN-SMF70AID
         BAS   R14,ASIDCALC
         LA    R5,DGMAXOED        PROCESS OPEN EDITION MVS ASID COUNTS.
         LA    R6,DGOEDLOW
         LA    R7,SMF70PMN-SMF70AID
         BAS   R14,ASIDCALC
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         DROP  R15                SMF70AID.
ASIDCALC DS    0H                 GET MIN, MAX AND AVERAGE ASID COUNTS.
         CLM   R7,3,SMF70ASL      IS THE ASID SECTION LONG ENOUGH?
         BNLR  R14                NO, THE FIGURES AREN'T SUPPLIED.
         ALR   R7,R15             YES, POINT TO THE SOURCE DATA.
         MVC   0(4,R6),0(R7)      COPY THE MINIMUM AND MAXIMUM COUNTS.
         ICM   R9,15,4(R7)        GET TOTAL OF ALL SAMPLES.
         M     R8,=F'10'          MULTIPLY BY TEN.
         D     R8,RMFSAMCT        GET AVERAGE TO ONE DECIMAL PLACE.
         ST    R9,4(,R6)          SAVE IT.
         CLC   0(2,R5),2(R6)      NEW ALL-TIME MAXIMUM?
         BNLR  R14                NO, RETURN.
         MVC   0(2,R5),2(R6)      YES, COPY THE NEW HIGH-WATER-MARK.
         BR    R14                RETURN.
         SPACE
         DROP  R1                 SMF70HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 71'
         USING SMF71HDR,R1
DATGAT71 DS    0H                 PROCESS RMF SMF RECORD TYPE 71.
         CLC   =H'1',SMF71STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF71PDN     PAGING DATA SECTION PRESENT?
         BZ    GATMAIN            NO, SO RETURN.
         ICM   R15,15,SMF71PDS    YES, GET ITS OFFSET.
         ALR   R15,R1             POINT TO THE PAGING DATA SECTION.
         USING SMF71PAG,R15
         L     R0,DGINTSIZ        GET THE INTERVAL SIZE (MS).
         ICM   R9,15,SMF71PIN     GET THE NON-VIO PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGPAGEIN        SAVE IT.
         ICM   R9,15,SMF71POT     GET THE NON-VIO PAGE-OUT COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGPAGOUT        SAVE IT.
         ICM   R9,15,SMF71SIN     GET THE SWAP PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGSWPGIN        SAVE IT.
         ICM   R9,15,SMF71SOT     GET THE SWAP PAGE-OUT COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGSWPGOT        SAVE IT.
         ICM   R9,15,SMF71VIN     GET THE VIO PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGVIOIN         SAVE IT.
         ICM   R9,15,SMF71VOT     GET THE VIO PAGE-OUT COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGVIOOUT        SAVE IT.
         AL    R9,DGVIOIN
         AL    R9,DGSWPGOT
         AL    R9,DGSWPGIN
         AL    R9,DGPAGOUT
         AL    R9,DGPAGEIN        GET THE TOTAL SYSTEM PAGING RATE.
         CL    R9,DGMAXPGR        NEW MAXIMUM SYSTEM PAGING RATE?
         BNH   EPAGRTOK           NO.
         ST    R9,DGMAXPGR        YES, SAVE IT FOR SCALING PURPOSES.
EPAGRTOK ICM   R9,15,SMF71RES     GET THE EXPANDED PAGE READ COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGESTGRD        SAVE IT.
         ICM   R9,15,SMF71PES     GET THE MOVE PAGE TO EXPANDED COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGESTGWR        SAVE IT.
         A     R9,DGESTGRD        GET TOTAL EXPANDED READ/WRITE COUNT.
         C     R9,DGMAXEIO        NEW MAXIMUM SYSTEM ESTOR I/O RATE?
         BNH   ESTGRDOK           NO.
         ST    R9,DGMAXEIO        YES, SAVE IT FOR SCALING PURPOSES.
ESTGRDOK ICM   R0,15,SMF71FIN     GET THE NUMBER OF NUCLEUS FRAMES.
         LR    R9,R0              COPY IT.
         ICM   R8,15,SMF71TFC     LOAD THE RSM FRAME COUNT.
         AR    R0,R8              GET THE TOTAL USABLE FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET NUCLEUS CENTRAL STORAGE FRACTION.
         ST    R9,DGNUCPCT        SAVE IT.
         ICM   R9,15,SMF71AVQ     GET THE AVERAGE SQA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET SQA CENTRAL STORAGE FRACTION.
         ST    R9,DGSQAPCT        SAVE IT.
         ICM   R9,15,SMF71AVP     GET THE AVERAGE CSA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET CSA CENTRAL STORAGE FRACTION.
         ST    R9,DGCSAPCT        SAVE IT.
         ICM   R9,15,SMF71ALP     GET THE AVERAGE LPA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET LPA CENTRAL STORAGE FRACTION.
         ST    R9,DGLPAPCT        SAVE IT.
         ICM   R9,15,SMF71AVS     GET THE AVERAGE NON-FIXED PVT COUNT.
         ICM   R8,15,SMF71AVR     GET THE AVERAGE FIXED PVT COUNT.
         AR    R9,R8              GET THE AVERAGE NON-LSQA PVT FRAMES.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET REGION CENTRAL STORAGE FRACTION.
         ST    R9,DGRGNPCT        SAVE IT.
         ICM   R9,15,SMF71ALS     GET THE AVERAGE LSQA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET LSQA CENTRAL STORAGE FRACTION.
         ST    R9,DGLSQPCT        SAVE IT.
         MVC   DGUICLOW,SMF71LIC  COPY MINIMUM SYSTEM HIGH UIC.
         MVC   DGUICHIG,SMF71HIC  COPY MAXIMUM SYSTEM HIGH UIC.
         MVC   DGUICAVG,SMF71ACA  COPY AVERAGE SYSTEM HIGH UIC BY 10.
         MVC   DGMIGLOW,SMF71LMA  COPY MINIMUM SYSTEM HIGH MIG AGE.
         MVC   DGMIGHIG,SMF71HMA  COPY MAXIMUM SYSTEM HIGH MIG AGE.
         MVC   DGMIGAVG,SMF71AMA  COPY AVERAGE SYSTEM HIGH MIG BY 10.
         CLC   DGMIGHIG,DGMAXMIG  NEW MAXIMUM MIGRATION AGE FOR SYSTEM?
         BNH   EXPMIGOK           NO.
         MVC   DGMAXMIG,DGMIGHIG  YES, SAVE IT FOR SCALING PURPOSES.
EXPMIGOK MVI   DGHPREXP,X'80'     INDICATE NO ESTOR USAGE STATISTICS.
         TM    SMF71FLG,SMF71ESA  RECORD FROM AN MVS/ESA SYSTEM?
         BZ    GATMAIN            NO, REQUEST NEXT INPUT RECORD.
         ICM   R0,15,SMF71OLE     GET THE ONLINE ESTOR FRAME COUNT.
         BZ    GATMAIN            ZERO, SO REQUEST NEXT INPUT RECORD.
         ICM   R9,15,SMF71AHE     GET THE AVERAGE HIPERSPACE FRAME CNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET HIPERSPACE EXPD STORAGE FRACTION.
         ST    R9,DGHPREXP        SAVE IT.
         ICM   R9,15,SMF71ASE     GET THE AVERAGE SQA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET SQA EXPANDED STORAGE FRACTION.
         ST    R9,DGSQAEXP        SAVE IT.
         ICM   R9,15,SMF71CAE     GET THE AVERAGE CSA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET CSA EXPANDED STORAGE FRACTION.
         ST    R9,DGCSAEXP        SAVE IT.
         ICM   R9,15,SMF71LAE     GET THE AVERAGE LPA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET LPA EXPANDED STORAGE FRACTION.
         ST    R9,DGLPAEXP        SAVE IT.
         ICM   R9,15,SMF71RAE     GET THE AVERAGE NON-LSQA PVT COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET REGION EXPANDED STORAGE FRACTION.
         ST    R9,DGRGNEXP        SAVE IT.
         ICM   R9,15,SMF71ALE     GET THE AVERAGE LSQA FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET LSQA EXPANDED STORAGE FRACTION.
         ST    R9,DGLSQEXP        SAVE IT.
         ICM   R9,15,SMF71AVE     GET THE AVERAGE VIO FRAME COUNT.
         M     R8,=F'100'         WANT PERCENTAGE.
         DR    R8,R0              GET VIO EXPANDED STORAGE FRACTION.
         ST    R9,DGVIOEXP        SAVE IT.
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
         DROP  R1                 SMF71HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 72'
         USING SMF72HDR,R1
DATGAT72 DS    0H                 PROCESS RMF SMF RECORD TYPE 72.
         CLC   =H'1',SMF72STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF72WLN     WORKLOAD CONTROL SECTION PRESENT?
         BZ    GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF72PGN     ANY PERF. GROUP PERIOD DATA SECTION?
         BZ    GATMAIN            NO, SO RETURN.
         OI    DGSYSFLG,DGRMFPRF  FLAG SYSTEM HAS RMF WORKLOAD DATA.
         ICM   R15,15,SMF72WLS    GET WORKLOAD CONTROL SECTION OFFSET.
         ALR   R15,R1             POINT TO WORKLOAD CONTROL SECTION.
         USING SMF72CTL,R15
         SLR   R2,R2
         ICM   R2,3,SMF72SUB      LOAD THE PERFORMANCE GROUP NUMBER.
         LA    R7,DGFSTPG#        POINT TO THE PGN ENTRY POINTERS.
DGPGNLP  LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT PG NUMBER ENTRY.
         BZ    MKNEWPGN           NO MORE PGN ENTRIES SO MAKE ONE.
         USING DGPG#ENT,R7
         C     R2,DGPG#           COMPARE PERFORMANCE GROUP NUMBERS.
         BH    DGPGNLP            RECORD FROM HIGHER PGN SO CONTINUE.
         BE    PGNENTOK           FOUND THE PGN ENTRY IN THE LIST.
*        BL    MKNEWPGN           RECORD FROM LOWER PGN SO MAKE ENTRY.
         SPACE
MKNEWPGN LA    R0,DGPG#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R7,R0              POINT TO THE NEW ENTRY.
         ST    R2,DGPG#           STORE PERFORMANCE GROUP NUMBER.
         LA    R0,DGFSTPG#        POINT TO PG NUMBER TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R7,CHNENTRY        SUPPLY PGN ENTRY ADDRESS.
         LA    R0,DGPG#NXT-DGPG#ENT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGPG#-DGPG#ENT
         ST    R0,CHNCMPOF        SUPPLY PG NUMBER OFFSET.
         LA    R0,4
         ST    R0,CHNCMPLN        SUPPLY DGPG# LENGTH.
         BAS   R14,CHAINADD       ADD PGN TO PGN ENTRY CHAIN.
PGNENTOK LA    R0,1
         A     R0,DGPG#NUM        INCREMENT THE NUMBER OF RMF INTERVALS
         ST    R0,DGPG#NUM        WITH THIS PERFORMANCE GROUP NUMBER.
         DROP  R7                 DGPG#ENT.
         LA    R8,DGPERLEN        GET THE PERIOD SECTION LENGTH.
         STH   R8,WORK
         ICM   R8,3,SMF72PGN      GET THE PERIOD COUNT FOR THIS GROUP.
         MH    R8,WORK            GET THE LENGTH FOR ALL PERIODS.
         LA    R0,DGPRFLEN(,R8)   GET THE TOTAL GROUP ENTRY SIZE.
         MVI   ENTRYTYP,5         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGPRFGRP,R6
         ICM   R7,15,DGLSTPGN     POINT TO THE PREVIOUSLY LAST ENTRY.
         BZ    FIRSTPRF           ZERO SO FIRST TYPE 72 FOR INTERVAL.
         ST    R7,DGPRFPRV        NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R7)          OLD LAST POINTS FORWARD TO NEW.
         B     LASTPERF           GO UPDATE THE INTERVAL ENTRY.
FIRSTPRF ST    R6,DGFSTPGN        THIS IS THE FIRST PG ENTRY.
LASTPERF ST    R6,DGLSTPGN        THIS IS NOW THE LAST PG ENTRY.
         ST    R2,DGPRFNUM        PUT PG NUMBER INTO ENTRY.
         MVC   DGPRFFLG,SMF72FG1  COPY PERFORMANCE GROUP FLAGS.
         MVC   DGPRFSYS,SMF72SYS  COPY ASSOCIATED SUBSYSTEM.
         MVC   DGPRFCLS,SMF72CLS  COPY ASSOCIATED TRANSACTION CLASS.
         MVC   DGPRFUSR,SMF72USR  COPY ASSOCIATED USER IDENTIFIER.
         MVC   DGPRFNAM,SMF72NAM  COPY ASSOCIATED TRANSACTION NAME.
         SLR   R0,R0
         ICM   R0,3,SMF72PGN      GET THE PERFORMANCE PERIOD COUNT.
         ST    R0,DGPRFPER        SAVE IT.
         MVC   DGADJC,SMF72ADJ    SAVE THE ADJUSTMENT COEFFICIENT.
         ICM   R0,15,SMF72CSD     LOAD THE CPU SERVICE COEFFICIENT.
         BAS   R14,PICTOBIN       CONVERT IT TO BINARY TIMES 10.
         ST    R0,DGTCBC          SAVE IT.
         ICM   R0,15,SMF72SSD     LOAD THE SRB SERVICE COEFFICIENT.
         BAS   R14,PICTOBIN       CONVERT IT TO BINARY TIMES 10.
         ST    R0,DGSRBC          SAVE IT.
         DROP  R15                SMF72CTL.
         SLR   R5,R5
         ICM   R5,3,SMF72PGL      GET PG PERIOD DATA SECTION LENGTH.
         ST    R5,WORK            SAVE IT FOR LATER.
         L     R5,DGPRFPER        LOAD THE COUNT OF PERIODS IN GROUP.
         ICM   R15,15,SMF72PGS    GET FIRST PERIOD DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO PG PERIOD DATA SECTION.
         USING SMF72WKL,R15
         ST    R6,SAVE+24         SAVE THE PERF. GROUP ENTRY ADDRESS.
         LA    R6,DGPERIOD        POINT TO FIRST PERF. PERIOD SECTION.
         DROP  R6                 DGPRFGRP.
         XC    SAVE+28(8),SAVE+28 CLEAR ACCUMULATORS.
         USING DGPERIOD,R6
DGPPLOOP ICM   R7,15,SMF72TTX     LOAD TERMINATED TRANSACTION COUNT.
         BZ    PP0XACTN           SKIP DIVIDE IF NO TRANSACTION ENDED.
         ST    R7,DGPERXAN        SAVE IT.
         LR    R8,R7              COPY IT.
         A     R8,SAVE+28         ACCUMULATE WHOLE GROUP XACTN COUNT.
         ST    R8,SAVE+28
         ICM   R9,15,SMF72TTM     GET PERIOD TRANSACTION ELAPSED TIME.
         LR    R8,R9              COPY IT.
         A     R8,SAVE+32         ACCUMULATE WHOLE GROUP XACTN TIME.
         ST    R8,SAVE+32
         SLR   R8,R8
         CLI   SMF72TTM,X'7D'     WILL SCALING CAUSE AN S0C9?
         BL    PPSCALOK           NO.
         L     R9,RMFMAXTM        YES, SET TO MAXIMUM.
         B     PPSCALDN           SCALING NOW DONE.
PPSCALOK SLDL  R8,10              CONVERT TO MICROSECONDS.
         D     R8,=F'1000'        CONVERT TO MILLESECONDS.
         SLR   R8,R8
PPSCALDN DR    R8,R7              GET MILLISECONDS PER TRANSACTION.
         ST    R9,DGPERXTM        SAVE IT.
PP0XACTN SLR   R8,R8
         ICM   R9,15,SMF72SER     GET TOTAL SERVICE UNIT CONSUMPTION.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        GET SERVICE UNITS PER 100SECONDS.
         ST    R9,DGPERSRV        SAVE IT.
         ICM   R9,15,SMF72STS     GET THE SRB CPU SERVICE UNITS.
         M     R8,DGADJC          CONVERT TO CPU 16*MICROSECONDS-ISH.
         SRDL  R8,4               CONVERT TO CPU MICROSECONDS-ISH.
         D     R8,DGSRBC          CONVERT TO CPU MICROSECONDS/10.
         M     R8,=F'10'          CONVERT TO CPU MICROSECONDS.
         LR    R7,R9              SAVE FOR NOW.
         ICM   R9,15,SMF72CTS     GET THE TCB CPU SERVICE UNITS.
         M     R8,DGADJC          CONVERT TO CPU 16*MICROSECONDS-ISH.
         SRDL  R8,4               CONVERT TO CPU MICROSECONDS-ISH.
         D     R8,DGTCBC          CONVERT TO CPU MICROSECONDS/10.
         M     R8,=F'10'          CONVERT TO CPU MICROSECONDS.
         ALR   R9,R7              ADD SRB TO TCB FOR TOTAL CPU TIME.
         BC    12,PPOFLWOK        THERE IS NO OVERFLOW.
         LA    R8,1(,R8)          COUNT OVERFLOW.
PPOFLWOK D     R8,DGINTSIZ        GET PP CPU AVERAGE PERMILLAGE.
         ST    R9,DGPERCPU        SAVE IT.
         ICM   R9,15,SMF72PIN     GET THE PERIOD PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        GET THE RATE.
         ST    R9,DGPERPIN        SAVE IT.
         AL    R15,WORK           POINT TO NEXT PP DATA SECTION.
         LA    R6,DGPERLEN(,R6)   POINT TO NEXT PG PERIOD SECTION.
         BCT   R5,DGPPLOOP        PROCESS THE NEXT PERFORMANCE PERIOD.
         DROP  R6                 DGPERIOD.
         SPACE
         L     R6,SAVE+24         POINT BACK TO PERF. GROUP ENTRY.
         USING DGPRFGRP,R6
         ICM   R7,15,SAVE+28      GET PERF. GROUP TRANSACTION COUNT.
         BZ    GATMAIN            RETURN IF NO TRANSACTIONS ENDED.
         ST    R7,DGPRFXAN        SAVE THE GROUP TRANSACTION COUNT.
         L     R9,SAVE+32         GET PERF. GROUP TRANSACTION TIME.
         SLR   R8,R8
         CLI   SAVE+32,X'7D'      WILL SCALING CAUSE AN S0C9?
         BL    PGSCALOK           NO.
         L     R9,RMFMAXTM        YES, SET TO MAXIMUM.
         B     PGSCALDN           SCALING NOW DONE.
PGSCALOK SLDL  R8,10              CONVERT TO MICROSECONDS.
         D     R8,=F'1000'        CONVERT TO MILLESECONDS.
         SLR   R8,R8
PGSCALDN DR    R8,R7              GET MILLISECONDS PER TRANSACTION.
         ST    R9,DGPRFXTM        SAVE IT.
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
         DROP  R6,R15             DGPERIOD, SMF72WKL.
         SPACE
DGADJC   DC    F'0'               SRM CPU ADJUSTMENT COEFFICIENT.
DGTCBC   DC    F'0'               TCB CPU IPS SERVICE COEFF.  (1/10THS)
DGSRBC   DC    F'0'               SRB CPU IPS SERVICE COEFF.  (1/10THS)
         SPACE
         DROP  R1                 SMF72HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 73'
         USING SMF73HDR,R1
DATGAT73 DS    0H                 PROCESS RMF SMF RECORD TYPE 73.
         CLC   =H'1',SMF73STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF73HIN     CHANNEL PATH CONTROL SECTION PRESENT?
         BZ    GATMAIN            NO, SO RETURN.
         ICM   R15,15,SMF73HIS    YES, GET ITS OFFSET.
         ALR   R15,R1             POINT TO IT.
         USING SMF73CTL,R15
         MVC   WORK(4),SMF73SMP   COPY SRM CHANNEL SAMPLE COUNT.
         DROP  R15                SMF73CTL.
         SLR   R5,R5
         ICM   R5,3,SMF73HPN      ANY CHANNEL PATH DATA SECTIONS?
         BZ    GATMAIN            NO, SO RETURN.
         STH   R5,WORK+4          YES, SAVE THE NUMBER.
         SLR   R7,R7
         ICM   R7,3,SMF73HPL      GET THE LENGTH OF CHP DATA SECTION.
         STH   R7,WORK+6          SAVE THE LENGTH.
         LA    R7,DGCHPLEN        GET THE LENGTH OF A CHPID SECTION.
         MH    R7,WORK+4          MULTIPLY BY CHPID COUNT.
         LA    R0,DGCHNLEN(,R7)   GET SIZE FOR NEW CHANNEL PATH ENTRY.
         MVI   ENTRYTYP,3         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              COPY THE ENTRY ADDRESS.
         ST    R6,DGFSTCHN        SAVE THE ADDRESS.
         ST    R6,DGLSTCHN
         USING DGCHPID,R6
         ST    R5,DGCHNNUM        SUPPLY THE CHPID COUNT.
         LA    R6,DGCHPATH        POINT TO THE FIRST CHPID SECTION.
         DROP  R6                 DGCHPID.
         USING DGCHPATH,R6
         ICM   R15,15,SMF73HPS    GET CHANNEL PATH DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO CHANNEL PATH DATA SECTION.
         USING SMF73CHA,R15
CHPIDLP  DS    0H                 PROCESS NEXT CHPID.
         STH   R5,WORK+4          SAVE REMAINING CHPID COUNT.
         TM    SMF73FG2,SMF73STA  IS THE CHPID ONLINE?
         BNO   CHPIDOFF           NO, SKIP DISPLAY ITEM CREATION.
         SLR   R2,R2
         IC    R2,SMF73PID        LOAD THE CHANNEL PATH NUMBER.
         LA    R7,DGFSTCH#        POINT TO THE CHN ENTRY POINTERS.
DGCHNLP  LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT CHP NUMBER ENTRY.
         BZ    MKNEWCHN           NO MORE CHN ENTRIES SO MAKE ONE.
         USING DGCH#ENT,R7
         C     R2,DGCH#           COMPARE CHANNEL PATH NUMBERS.
         BH    DGCHNLP            RECORD FROM HIGHER CHN SO CONTINUE.
         BE    CHNENTOK           FOUND THE CHN ENTRY IN THE LIST.
*        BL    MKNEWCHN           RECORD FROM LOWER CHN SO MAKE ENTRY.
         SPACE
MKNEWCHN LA    R0,DGCH#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R7,R0              POINT TO THE NEW ENTRY.
         ST    R2,DGCH#           STORE CHPID NUMBER.
         MVC   DGCH#ACR,BLANKS    CLEAR CHANNEL TYPE ACRONYM.
         LA    R0,DGFSTCH#        POINT TO CHPID NUMBER TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R7,CHNENTRY        SUPPLY CHPID ENTRY ADDRESS.
         LA    R0,DGCH#NXT-DGCH#ENT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGCH#-DGCH#ENT
         ST    R0,CHNCMPOF        SUPPLY CHPID NUMBER OFFSET.
         LA    R0,4
         ST    R0,CHNCMPLN        SUPPLY DGCH# LENGTH.
         BAS   R14,CHAINADD       ADD CHPID TO CHPID ENTRY CHAIN.
CHNENTOK LA    R0,1
         A     R0,DGCH#NUM        INCREMENT THE COUNT OF RMF
         ST    R0,DGCH#NUM        INTERVALS WITH THIS CHPID ID.
         LA    R8,SMF73ACR-SMF73CHA+5
         CH    R8,WORK+6          SECTION LONG ENOUGH FOR ACRONYM?
         BL    CHPIDOFF           NO.
         MVC   DGCH#ACR,SMF73ACR  YES, UPDATE IT.
         DROP  R7                 DGCH#ENT.
CHPIDOFF MVC   DGCHPPID,SMF73PID  COPY CHANNEL PATH ID AND FLAGS.
         ICM   R9,15,SMF73BSY     GET THE CHANNEL PATH BUSY COUNT.
         M     R8,=F'10000'       PREPARE FOR HUNDREDTHS OF PERCENT.
         D     R8,WORK            GET BUSY FRACTION OF TIME.
         ST    R9,DGCHPBSY        SAVE IT.
         AH    R15,WORK+6         POINT TO NEXT CHPID DATA SECTION.
         LA    R6,DGCHPLEN(,R6)   POINT TO NEXT CHPID ENTRY SECTION.
         LH    R5,WORK+4          GET REMAINING CHPID COUNT.
         BCT   R5,CHPIDLP         PROCESS NEXT CHPID, IF ANY.
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
         DROP  R6,R15             DGCHPATH, SMF73CHA.
         SPACE
         DROP  R1                 SMF73HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 74'
         USING SMF74HDR,R1
DATGAT74 DS    0H                 PROCESS RMF SMF RECORD TYPE 74.
         CLC   =H'1',SMF74STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         SLR   R5,R5
         ICM   R5,3,SMF74DDN      ANY DEVICE DATA SECTIONS?
         BZ    GATMAIN            NO, SO RETURN.
         SLR   R7,R7
         ICM   R7,3,SMF74DDL      GET THE LENGTH OF DEV DATA SECTION.
         STH   R7,WORK+6          SAVE THE LENGTH.
         ICM   R15,15,SMF74DDS    GET FIRST DEVICE DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO FIRST DEVICE DATA SECTION.
         USING SMF74B,R15
DEVICELP DS    0H                 PROCESS NEXT DEVICE.
         STH   R5,WORK+4          SAVE REMAINING DEVICE COUNT.
         SLR   R2,R2
         ICM   R2,3,SMF74NUM      LOAD THE DEVICE NUMBER.
         LA    R7,DGFSTDV#        POINT TO THE DEV ENTRY POINTERS.
DGDEVLP  LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT DEV NUMBER ENTRY.
         BZ    MKNEWDEV           NO MORE DVN ENTRIES SO MAKE ONE.
         USING DGDV#ENT,R7
         C     R2,DGDV#           COMPARE DEVICE NUMBERS.
         BH    DGDEVLP            RECORD FROM HIGHER DEV SO CONTINUE.
         BE    DEVENTOK           FOUND THE DEVICE ENTRY IN THE LIST.
*        BL    MKNEWDEV           RECORD FROM LOWER DEV SO MAKE ENTRY.
         SPACE
MKNEWDEV LA    R0,DGDV#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R7,R0              POINT TO THE NEW ENTRY.
         ST    R2,DGDV#           STORE DEVICE NUMBER.
         LA    R0,DGFSTDV#        POINT TO DEVICE NUMBER TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R7,CHNENTRY        SUPPLY DEVICE NUMBER ENTRY ADDRESS.
         LA    R0,DGDV#NXT-DGDV#ENT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGDV#-DGDV#ENT
         ST    R0,CHNCMPOF        SUPPLY DEVICE NUMBER OFFSET.
         LA    R0,4
         ST    R0,CHNCMPLN        SUPPLY DGDV# LENGTH.
         BAS   R14,CHAINADD       ADD DEV# TO DEVICE NUMBER CHAIN.
DEVENTOK LA    R0,1
         A     R0,DGDV#NUM        INCREMENT THE NUMBER OF RMF
         ST    R0,DGDV#NUM        INTERVALS WITH THIS DEVICE NUMBER.
         DROP  R7                 DGDV#ENT.
         LA    R0,DGDEVLEN        GET THE DEVICE ENTRY SIZE.
         MVI   ENTRYTYP,4         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGDEVICE,R6
         ICM   R7,15,DGLSTDEV     POINT TO THE PREVIOUSLY LAST ENTRY.
         BZ    FIRSTDEV           ZERO SO FIRST TYPE 74 FOR INTERVAL.
         ST    R7,DGDEVPRV        NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R7)          OLD LAST POINTS FORWARD TO NEW.
         B     LASTDEV            GO UPDATE THE INTERVAL ENTRY.
FIRSTDEV ST    R6,DGFSTDEV        THIS IS THE FIRST DEVICE ENTRY.
LASTDEV  ST    R6,DGLSTDEV        THIS IS NOW THE LAST DEVICE ENTRY.
         ST    R2,DGDEVNAM        PUT DEVICE NUMBER INTO ENTRY.
         ICM   R2,3,SMF74LCU      GET LOGICAL CONTROL UNIT NUMBER.
         ST    R2,DGDEVLCU        PUT LCU NUMBER INTO ENTRY.
         MVC   DGDEVFLG,SMF74CNF  COPY DEVICE FLAG BYTE INTO ENTRY.
         MVC   DGDEVVOL,SMF74SER  COPY VOLUME SERIAL NUMBER.
         MVC   DGDEVTYP,SMF74TYP  COPY DEVICE UNIT TYPE BYTES.
         MVC   DGDEVSGN,SMF74SGN  COPY DEVICE SMS STORAGE GROUP NAME.
         OI    DGDEVFL2,DGDEV0IO  ASSUME ZERO I/O IN INTERVAL.
         ICM   R9,15,SMF74SSC     GET THE DEVICE I/O COUNT.
         BZ    DVIOCTOK           ZERO SO SKIP SOME CALCULATIONS.
         ST    R9,WORK            SAVE IT FOR LATER.
         XI    DGDEVFL2,DGDEV0IO  NON-ZERO I/O IN INTERVAL.
         M     R8,=F'100000'      WANT HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        DIVIDE I/O COUNT BY ELAPSED TIME.
         ST    R9,DGDEVACT        SAVE DEVICE ACTIVATION RATE.
         ICM   R0,15,SMF74MEC     GET THE DEVICE MEASURED I/O COUNT.
         BZ    DVIOCTOK           ZERO SO SKIP SOME CALCULATIONS.
         ICM   R9,15,SMF74CNN     GET THE DEVICE CONNECT TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET CONNECT MICROSECONDS PER IO.
         ST    R9,DGDEVAVC        SAVE IT.
         ICM   R9,15,SMF74DIS     GET THE DEVICE DISCONNECT TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET DISCONNECT MICROSECONDS PER IO.
         ST    R9,DGDEVAVD        SAVE IT.
         ICM   R9,15,SMF74PEN     GET THE DEVICE PENDING TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET PENDING MICROSECONDS PER IO.
         ST    R9,DGDEVAVP        SAVE IT.
         ICM   R9,15,SMF74DVB     GET THE DEVICE BUSY DELAY TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET BUSY DELAY MICROSECONDS PER IO.
         ST    R9,DGDEVBSW        SAVE IT.
         ICM   R9,15,SMF74CUB     GET THE CU BUSY DELAY TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET BUSY DELAY MICROSECONDS PER IO.
         ST    R9,DGDEVCUW        SAVE IT.
         TM    SMF74FLG,SMF74ESA  RECORD FROM AN MVS/ESA SYSTEM?
         BZ    DIRPRTOK           NO.
         CLI   RMFSMFRL,5         DIRECTOR PORT MEASUREMENT AVAILABLE?
         BL    DIRPRTOK           NO.
         ICM   R9,15,SMF74DPB     GET THE DIR. PORT BUSY DELAY TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         DR    R8,R0              GET BUSY DELAY MICROSECONDS PER IO.
         ST    R9,DGDEVDPW        SAVE IT.
DIRPRTOK ICM   R9,15,SMF74CNN     GET THE DEVICE CONNECT TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVCON        SAVE CONNECT TIME PERMILLAGE.
         ICM   R9,15,SMF74DIS     GET THE DEVICE DISCONNECT TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVDIS        SAVE DISCONNECT TIME PERMILLAGE.
         ICM   R9,15,SMF74PEN     GET THE DEVICE PENDING TIME.
         SLR   R8,R8
         SLDL  R8,7               CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVPND        SAVE PENDING TIME PERMILLAGE.
         ICM   R9,15,SMF74QUE     GET IOS-QUEUED I/O COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         D     R8,WORK            GET QUEUED FRACTION OF ALL I/O'S.
         ST    R9,DGDEVQUE        SAVE IT.
DVIOCTOK ICM   R9,15,SMF74RSV     GET RESERVED SAMPLE COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         D     R8,RMFSAMCT        GET RESERVED FRACTION OF TIME.
         ST    R9,DGDEVRSV        SAVE IT.
         ICM   R9,15,SMF74MTP     GET MOUNT PENDING SAMPLE COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         D     R8,RMFSAMCT        GET MOUNT PENDING FRACTION OF TIME.
         ST    R9,DGDEVMTP        SAVE IT.
         ICM   R9,15,SMF74NRD     GET NOT READY SAMPLE COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         D     R8,RMFSAMCT        GET NOT READY FRACTION OF TIME.
         ST    R9,DGDEVNRD        SAVE IT.
         AH    R15,WORK+6         POINT TO NEXT DEVICE DATA SECTION.
         LH    R5,WORK+4          GET REMAINING DEVICE COUNT OF RECORD.
         BCT   R5,DEVICELP        PROCESS NEXT DEVICE, IF ANY.
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
         DROP  R6,R15             DGDEVICE, SMF74B.
         SPACE
         DROP  R1                 SMF74HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 75'
         USING SMF75HDR,R1
DATGAT75 DS    0H                 PROCESS RMF SMF RECORD TYPE 75.
         CLC   =H'1',SMF75STY     SUBTYPE 1?
         BNE   GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF75PSN     PAGE/SWAP D/S DATA SECTION PRESENT?
         BZ    GATMAIN            NO, SO RETURN.
         ICM   R15,15,SMF75PSS    GET DATA SET DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO DATA SET DATA SECTION.
         USING SMF75PSD,R15
         LA    R7,DGFSTPDN        POINT TO THE PDN ENTRY POINTERS.
DGPDNLP  LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT PAGE DSN ENTRY.
         BZ    MKNEWPDN           NO MORE PAGE DSN ENTRIES SO MAKE ONE.
         USING DGPDNENT,R7
         CLC   DGPDNAME,SMF75DSN  COMPARE PAGE/SWAP DATA SET NAMES.
         BE    PDNENTOK           FOUND THE PAGE DSN ENTRY IN THE LIST.
         B     DGPDNLP            NOT THIS ONE SO CONTINUE SEARCH.
         SPACE
MKNEWPDN LA    R0,DGPDNLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R7,R0              POINT TO THE NEW ENTRY.
         MVC   DGPDNAME,SMF75DSN  LOAD PAGE/SWAP DATA SET NAME.
         LA    R0,DGFSTPDN        POINT TO DEVICE NUMBER TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R7,CHNENTRY        SUPPLY PDN ENTRY ADDRESS.
         LA    R0,DGPDNNXT-DGPDNENT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGPDNAME-DGPDNENT
         ST    R0,CHNCMPOF        SUPPLY PAGE DATA SET NAME OFFSET.
         LA    R0,4               SMALL VALUE FOR LITTLE SORTING.
         ST    R0,CHNCMPLN        SUPPLY DATA SET NAME SORT LENGTH.
         BAS   R14,CHAINADD       ADD DSN TO DSN CHAIN.
PDNENTOK LA    R0,1
         A     R0,DGPDNNUM        INCREMENT THE NUMBER OF RMF INTERVALS
         ST    R0,DGPDNNUM        WITH THIS PAGE DATA SET NAME.
         DROP  R7                 DGPDNENT.
         LA    R0,DGPAGLEN        GET THE PAGE DATA SET ENTRY SIZE.
         MVI   ENTRYTYP,6         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGPAGEDS,R6
         ICM   R7,15,DGLSTPAG     POINT TO THE PREVIOUSLY LAST ENTRY.
         BZ    FIRSTPAG           ZERO SO FIRST TYPE 75 FOR INTERVAL.
         ST    R7,DGPAGPRV        NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R7)          OLD LAST POINTS FORWARD TO NEW.
         B     LASTPAGE           GO UPDATE THE INTERVAL ENTRY.
FIRSTPAG ST    R6,DGFSTPAG        THIS IS THE FIRST DATA SET ENTRY.
LASTPAGE ST    R6,DGLSTPAG        THIS IS NOW THE LAST DATA SET ENTRY.
         MVC   DGPAGDSN,SMF75DSN  COPY PAGE/SWAP DATA SET NAME.
         MVC   DGPAGFLG,SMF75PST  COPY PAGE/SWAP DATA SET FLAGS.
         MVC   DGPAGBAD,SMF75BDS  COPY UNUSABLE SLOT/SWAP SET COUNT.
         ICM   R0,15,SMF75SLA     GET THE DATA SET SLOT/SWAP SET SIZE.
         BNP   PAGSIZOK           HANDLE UNEXPECTED DATA.
         ICM   R9,15,SMF75MXU     GET MAXIMUM USED COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         DR    R8,R0              GET MAXIMUM FRACTION USED.
         ST    R9,DGPAGMAX        SAVE IT.
         ICM   R9,15,SMF75MNU     GET MINIMUM USED COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         DR    R8,R0              GET MINIMUM FRACTION USED.
         ST    R9,DGPAGMIN        SAVE IT.
         ICM   R9,15,SMF75AVU     GET AVERAGE USED COUNT.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         DR    R8,R0              GET AVERAGE FRACTION USED.
         ST    R9,DGPAGAVG        SAVE IT.
PAGSIZOK ICM   R9,15,SMF75USE     GET THE IN-USE SAMPLE COUNT.
         BZ    PAGUSEOK           NO ACTIVITY CAPTURED BY RMF.
         M     R8,=F'1000'        PREPARE FOR PERMILLAGE.
         D     R8,RMFSAMCT        GET THE BUSY FRACTION OF TIME.
         ST    R9,DGPAGBSY        SAVE IT.
         M     R8,DGINTSIZ        GET BUSY MICROSECONDS.
         ICM   R0,15,SMF75PGX     GET THE PAGE TRANSFER COUNT.
         BZ    PAGUSEOK           HANDLE ZERO ACTIVITY.
         DR    R8,R0              GET MICROSECONDS/PAGE-TRANSFERRED.
         ST    R9,DGPAGTIM        SAVE PAGE TRANSFER SERVICE TIME.
PAGUSEOK ICM   R9,15,SMF75SIO     GET THE DATA SET I/O REQUEST COUNT.
         M     R8,=F'100000'      SCALE IT FOR MILLISECONDS.
         D     R8,DGINTSIZ        DIVIDE I/O COUNT BY ELAPSED TIME.
         ST    R9,DGPAGIOR        SAVE THE DATA SET I/O RATE.
         ICM   R9,15,SMF75PGX     GET THE PAGE TRANSFER COUNT.
         M     R8,=F'100000'      SCALE IT FOR MILLISECONDS.
         D     R8,DGINTSIZ        DIVIDE XFR COUNT BY ELAPSED TIME.
         ST    R9,DGPAGXFR        SAVE THE DATA SET TRANSFER RATE.
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
         DROP  R6,R15             DGPAGEDS, SMF75PSD.
         SPACE
         DROP  R1                 SMF75HDR.
         TITLE 'PROCESS RMF SMF RECORD TYPE 78'
         USING SMF78HDR,R1
DATGAT78 DS    0H                 PROCESS RMF SMF RECORD TYPE 78.
         CLC   =H'2',SMF78STY     SUBTYPE 2?
         BNE   GATMAIN            NO, SO RETURN.
         ICM   R15,3,SMF78DCN     VS COMMON STORAGE SECTION PRESENT?
         BZ    GATMAIN            NO, SO RETURN.
         ICM   R15,15,SMF78DCS    GET COMMON STG DATA SECTION OFFSET.
         ALR   R15,R1             POINT TO COMMON STORAGE DATA SECTION.
         USING R782COMN,R15
         ICM   R0,15,R782CS       GET TOTAL CSA SIZE.
         BZ    GATMAIN            AVOID ABEND FOR ZERO DATA.
         ST    R0,WORK+4          SAVE IT FOR LATER.
         ICM   R9,15,R782CSAU+8   GET MAXIMUM CSA USAGE.
         M     R8,=F'1000'        MULTIPLY FOR PERMILLAGE.
         DR    R8,R0              GET MAXIMUM CSA USAGE PERMILLAGE.
         STH   R9,DGCSAMAX        SAVE IT.
         MVC   DGCSAALC,R782CSAL+8     COPY MAXIMUM CSA ALLOCATION.
         MVC   DGCSAEXT,R782CSLF  COPY MINIMUM CSA LARGEST FREE EXTENT.
         LA    R6,R782227K+196    GET CSA SUBPOOL 227 AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DG227AVG
         LA    R6,R782228K+196    GET CSA SUBPOOL 228 AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DG228AVG
         LA    R6,R782231K+196    GET CSA SUBPOOL 231 AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DG231AVG
         LA    R6,R782241K+196    GET CSA SUBPOOL 241 AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DG241AVG
         LA    R6,R782CSAU+16     GET CSA TOTAL AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DGCSAAVG
         ICM   R0,15,R782ECS      GET TOTAL ECSA SIZE.
         BZ    GATMAIN            AVOID ABEND FOR ZERO DATA.
         ST    R0,WORK+4          SAVE IT FOR LATER.
         ICM   R9,15,R782CSAU+28  GET MAXIMUM ECSA USAGE.
         M     R8,=F'1000'        MULTIPLY FOR PERMILLAGE.
         DR    R8,R0              GET MAXIMUM ECSA USAGE PERMILLAGE.
         STH   R9,DGECSAMX        SAVE IT.
         MVC   DGECSAAL,R782CSAL+28   COPY MAXIMUM ECSA ALLOCATION.
         MVC   DGECSAXT,R782CSLF+20   COPY MIN. ECSA LRGST FREE XTNT.
         LA    R6,R782CSAU+36     GET ECSA TOTAL AVERAGE USAGE.
         BAS   R7,CMNAVG78
         STH   R9,DGECSAAV
         B     GATMAIN            REQUEST NEXT INPUT RECORD.
         SPACE
CMNAVG78 DS    0H                 GET FLOATING POINT AVERAGE.
         MVC   WORK(4),0(R6)      COPY SAMPLE TOTAL.
         LE    E4,WORK            LOAD SAMPLE TOTAL.
         ICM   R0,15,RMFSAMCT     GET SAMPLE COUNT.
         BZ    GATMAIN            AVOID ABEND FOR ZERO DATA.
         BAS   R14,FIXFL          GET SAMPLE COUNT IN FLOATING POINT.
         DDR   E4,E0              GET AVERAGE USAGE.
         LDR   E0,E4              COPY IT.
         BAS   R14,FLFIX          CONVERT TO FIXED POINT.
         LR    R9,R0              COPY IT.
         M     R8,=F'1000'        MULTIPLY FOR PERMILLAGE.
         D     R8,WORK+4          GET PERMILLAGE.
         BR    R7                 RETURN TO CALLER.
         SPACE
         DROP  R15                R782COMN.
         SPACE
         DROP  R1                 SMF78HDR.
         TITLE 'PROCESS PERFORMANCE DATA LOGGING FACILITY DATA'
         USING PDLFHDR,R1
DATGAT7F DS    0H
         TM    PDLFCFLG,PDLFCMNP  WAS MEASUREMENT POSSIBLE?
         BO    GATMAIN            NO, IPS WAS PROBABLY SET IN INTERVAL.
         LA    R2,PDLFCMNE        POINT TO FIRST ELEMENT DESCRIPTOR.
         USING PDLFCELM,R2
         CLI   PDLFCENO,1         ELEMENT NUMBER ONE?
         BNE   GATMAIN            NO, UNEXPECTED FORMAT SO DISCARD IT.
         SLR   R15,R15
         ICM   R15,3,PDLFCOFF     GET OFFSET TO FIRST ELEMENT.
         LA    R15,PDLFCMNS(R15)  POINT TO THE FIRST ELEMENT.
         CLC   =C'S001',PDLFCRID  SYSTEM PERFORMANCE RECORD?
         BE    SCANS001           YES.
         CLC   =C'I001',PDLFCRID  I/O PERFORMANCE RECORD?
         BE    SCANI001           YES.
         CLC   =C'P001',PDLFCRID  PERFORMANCE GROUP PERFORMANCE RECORD?
         BE    SCANP001           YES.
         B     GATMAIN            UNKNOWN RECORD TYPE SO DISCARD IT.
         SPACE 2
*        USING PDLFS1,R15
SCANS001 DS    0H                 PROCESS SYSTEM PERFORMANCE RECORD.
         SLR   R0,R0
         ICM   R0,3,PDLFCELN      GET THE CPU COUNT @ 1 BYTE PER CPU.
         SLR   R5,R5              ZERO ACTIVE CPU COUNT.
         SLR   R6,R6              ZERO WORK REGISTER.
         SLR   R7,R7              ZERO CPU UTLIZATION ACCUMULATOR.
S1CPULP  CLI   0(R15),X'FF'       ACTIVE CPU?
         BE    S1CPUNXT           NO, DO NOT COUNT IT.
         IC    R6,0(,R15)         YES, GET ITS UTILIZATION.
         AR    R7,R6              ACCUMULATE IT.
         LA    R5,1(,R5)          INCREMENT ACTIVE CPU COUNT.
S1CPUNXT LA    R15,1(,R15)        POINT TO THE NEXT CPU'S BUSY RATE.
         BCT   R0,S1CPULP         PROCESS NEXT CPU ENTRY.
         LTR   R5,R5              ANY ACTIVE CPU?
         BZ    S1PAGING           NO.  (SHOULDN'T HAPPEN.)
         ST    R5,DGCPUCNT        YES, SAVE THE ACTIVE CPU COUNT.
         M     R6,=F'10'          CONVERT PERCENTAGE TO PERMILLAGE.
         DR    R6,R5              GET AVERAGE CPU UTILIZATION.
         ST    R7,DGCPUTIL        SAVE LOGICAL CPU BUSY RATE.
         ST    R7,DGCPBUSY        SAVE PHYSICAL CPU BUSY RATE.
S1PAGING ICM   R0,3,PDLFCELN      GET THE THE LENGTH OF ELEMENT 1.
*        DROP  R15                PDLFS1.
         AR    R15,R0             POINT TO ELEMENT 2.
         LA    R2,PDLFCELE        POINT TO THE ELEMENT 2 DESCRIPTOR.
         CLI   PDLFCENO,2         ELEMENT NUMBER TWO?
         BNE   GATMAIN            NO, UNEXPECTED FORMAT SO DISCARD IT.
         USING PDLFS2,R15
         L     R0,DGINTSIZ        GET THE INTERVAL SIZE (MS).
         ICM   R9,15,PDLFS2PI     GET THE PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGPAGEIN        SAVE IT.
         ICM   R9,15,PDLFS2PO     GET THE PAGE-OUT COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGPAGOUT        SAVE IT.
         ICM   R9,15,PDLFS2SI     GET THE SWAP PAGE-IN COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGSWPGIN        SAVE IT.
         ICM   R9,15,PDLFS2SO     GET THE SWAP PAGE-OUT COUNT.
         M     R8,=F'100000'      WANT RATE AS HUNDREDTHS PER SECOND.
         DR    R8,R0              GET THE RATE.
         ST    R9,DGSWPGOT        SAVE IT.
         AL    R9,DGSWPGIN
         AL    R9,DGPAGOUT
         AL    R9,DGPAGEIN        GET THE TOTAL SYSTEM PAGING RATE.
         CL    R9,DGMAXPGR        NEW MAXIMUM SYSTEM PAGING RATE?
         BNH   GATMAIN            NO, END OF PDLF S001 RECORD STUFF.
         ST    R9,DGMAXPGR        YES, SAVE IT FOR SCALING PURPOSES.
         B     GATMAIN            END OF PDLF S001 RECORD PROCESSING.
         DROP  R15,R2             PDLFS2, PDLFCELM.
         SPACE 2
*        USING PDLFIREC,R15
SCANI001 DS    0H                 PROCESS I/O PERFORMANCE RECORD.
         ST    R15,WORK           SAVE ELEMENT 1 ADDRESS.
         LA    R5,256             GET THE NUMBER OF CHANNEL SECTIONS.
         SLR   R6,R6              ZERO THE ACTIVE CHANNEL COUNTER.
I1CHNLP1 DS    0H                 PROCESS NEXT CHANNEL.
         CLI   0(R15),PDLFI1OF    ACTIVE CHANNEL?
         BE    I1CHNNX1           NO, CHANNEL IS OFFLINE.
         LA    R2,256             YES.
         SLR   R2,R5              GET THE CHANNEL NUMBER.
         LA    R7,DGFSTCH#        POINT TO THE CHN ENTRY POINTERS.
         ST    R5,WORK+4          SAVE WORK REGISTER.
I1CHNLP2 LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT CHAN NUMBER ENTRY.
         BZ    I1NEWCHN           NO MORE CHN ENTRIES SO MAKE ONE.
         USING DGCH#ENT,R7
         C     R2,DGCH#           COMPARE CHANNEL NUMBERS.
         BH    I1CHNLP2           RECORD FROM HIGHER CHN SO CONTINUE.
         BE    I1CENTOK           FOUND THE CHANNEL ENTRY IN THE LIST.
*        BL    I1NEWCHN           RECORD FROM LOWER CHN SO MAKE ENTRY.
         DROP  R7                 DGCH#ENT.
         SPACE
I1NEWCHN LA    R0,DGCH#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R9,R0              POINT TO THE NEW ENTRY.
         USING DGCH#ENT,R9
         ST    R2,DGCH#           STORE CHANNEL NUMBER.
         LTR   R7,R7              ENCOUNTERED END OF FORWARD CHAIN?
         BNZ   I1LWRCHN           NO, THIS CHANNEL NUMBER IS LOWER.
         ICM   R0,15,DGNUMCH#     YES, ANY ENTRIES ON CHAIN?
         BZ    I1FSTCHN           NO, THIS IS THE FIRST CHANNEL READ.
         ST    R5,DGCH#PRV        YES, NEW POINTS BACK TO OLD LAST.
         ST    R9,0(,R5)          OLD LAST POINTS FWD TO NEW ENTRY.
         ST    R9,DGLSTCH#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     I1CNTCHN           CHN NUMBER ENTRY CHAIN NOW UPDATED.
I1FSTCHN ST    R9,DGFSTCH#        NEW ENTRY IS NOW THE FIRST ENTRY.
         ST    R9,DGLSTCH#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     I1CNTCHN           CHN NUMBER ENTRY CHAIN NOW UPDATED.
I1LWRCHN ST    R7,DGCH#NXT        NEW ENTRY POINTS FWD TO OLD ENTRY.
         MVC   DGCH#PRV,4(R7)     OLD BACK POINTER IS NEW BACK PTR.
         ST    R9,0(,R5)          POINT FORWARD TO NEW ENTRY.
         ST    R9,4(,R7)          POINT BACK TO NEW ENTRY.
         DROP  R9                 DGCH#ENT.
I1CNTCHN LA    R0,1
         A     R0,DGNUMCH#        INCREMENT THE DIFFERENT CHANNEL
         ST    R0,DGNUMCH#        NUMBER COUNT FOR THIS SYSTEM.
I1CENTOK LA    R6,1(,R6)          COUNT THE ACTIVE CHANNEL.
         L     R5,WORK+4          RESTORE WORK REGISTER.
I1CHNNX1 LA    R15,2(,R15)        POINT TO NEXT CHANNEL FIELD.
         BCT   R5,I1CHNLP1        PROCESS THE NEXT CHANNEL ENTRY.
         SPACE
         LA    R15,DGCHPLEN       GET THE CHPID SECTION LENGTH.
         MR    R14,R6             GET LENGTH OF ALL CHPID SECTIONS.
         LA    R0,DGCHNLEN(,R15)  GET THE INTERVAL CHPID ENTRY SIZE.
         MVI   ENTRYTYP,3         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R7,R0              POINT TO THE NEW ENTRY.
         ST    R7,DGFSTCHN        SAVE THE CHANNEL PATH ENTRY ADDRESS.
         ST    R7,DGLSTCHN
         USING DGCHPID,R7
         ST    R6,DGCHNNUM        SAVE THE CHPID SECTION COUNT.
         LA    R7,DGCHPATH        POINT TO THE FIRST SECTION.
         DROP  R7                 DGCHPID.
         USING DGCHPATH,R7
         L     R15,WORK           POINT TO THE START OF ELEMENT 1.
         LA    R0,256             GET MAXIMUM CHANNEL COUNT.
I1CHNLP3 DS    0H
         CLI   0(R15),PDLFI1OF    ACTIVE CHANNEL?
         BE    I1CHNNX3           NO, CHANNEL IS OFFLINE.
         LA    R9,256
         SLR   R9,R0              GET THE CHANNEL NUMBER.
         STC   R9,DGCHPPID        SAVE IT.
         OI    DGCHPPID+1,X'01'   TURN ON RMF "CHANNEL ONLINE" FLAG.
         ICM   R9,3,0(R15)        GET THE CHANNEL BUSY PERCENTAGE.
         M     R8,=F'100'         MAKE IT HUNDREDTHS OF PERCENT.
         ST    R9,DGCHPBSY        SAVE IT.
         LA    R7,DGCHPLEN(,R7)   POINT TO NEXT CHANNEL PATH SECTION.
I1CHNNX3 LA    R15,2(,R15)        POINT TO NEXT CHANNEL FIELD.
         BCT   R0,I1CHNLP3        PROCESS NEXT CHANNEL FIELD, IF ANY.
         DROP  R7                 DGCHPATH.
*        DROP  R15                PDLFIREC.
         SPACE 2
*                                 PROCESS I/O DEVICE ELEMENT.
         LA    R2,PDLFCMNE        POINT TO FIRST ELEMENT DESCRIPTOR.
         USING PDLFCELM,R2
         SLR   R15,R15
         ICM   R15,3,PDLFCOFF     GET OFFSET TO FIRST ELEMENT.
         LA    R15,PDLFCMNS(R15)  POINT TO THE FIRST ELEMENT.
         SLR   R9,R9
         ICM   R9,3,PDLFCELN      GET THE LENGTH OF THE 1ST ELEMENT.
         ALR   R15,R9             POINT TO THE 2ND (DEVICE) ELEMENT.
         USING PDLFI2HD,R15
         LA    R2,PDLFCELE        POINT TO THE ELEMENT 2 DESCRIPTOR.
         CLI   PDLFCENO,2         ELEMENT NUMBER TWO?
         BNE   GATMAIN            NO, UNEXPECTED FORMAT SO DISCARD IT.
         CLC   PDLFCELN,PDLFI2LN+2    CONSISTENT LENGTH FIELDS?
         BNE   GATMAIN            NO, UNEXPECTED FORMAT SO DISCARD IT.
         DROP  R2                 PDLFCELM.
         ICM   R9,3,PDLFI2LN+2    GET THE WHOLE 2ND ELEMENT LENGTH.
         SH    R9,=H'8'           ANY DEVICE DATA SECTIONS?
         BZ    GATMAIN            NO, SO RETURN.
         SLR   R7,R7
         ICM   R7,3,PDLFI2EL      GET THE LENGTH OF DEV DATA SECTION.
         BNP   GATMAIN            UNEXPECTED FORMAT SO DISCARD DATA.
         STH   R7,WORK+6          SAVE THE LENGTH.
         SLR   R8,R8              PREPARE FOR DIVIDE.
         DR    R8,R7              GET THE NUMBER OF DEVICE ENTRIES.
         LR    R5,R9              COPY IT.
         LA    R15,PDLFI2ST       POINT TO FIRST DEVICE DATA SECTION.
         DROP  R15                PDLFI2HD
         USING PDLFI2ST,R15
I1DEVLP1 DS    0H                 PROCESS NEXT DEVICE.
         STH   R5,WORK+4          SAVE REMAINING DEVICE COUNT.
         SLR   R2,R2
         ICM   R2,3,PDLFI2AD      LOAD THE DEVICE NUMBER.
         LA    R7,DGFSTDV#        POINT TO THE DEV ENTRY POINTERS.
I1DEVLP2 LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT DEV NUMBER ENTRY.
         BZ    I1NEWDEV           NO MORE DVN ENTRIES SO MAKE ONE.
         USING DGDV#ENT,R7
         C     R2,DGDV#           COMPARE DEVICE NUMBERS.
         BH    I1DEVLP2           RECORD FROM HIGHER DEV SO CONTINUE.
         BE    I1DENTOK           FOUND THE DEVICE ENTRY IN THE LIST.
*        BL    I1NEWDEV           RECORD FROM LOWER DEV SO MAKE ENTRY.
         DROP  R7                 DGDV#ENT.
         SPACE
I1NEWDEV LA    R0,DGDV#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R9,R0              POINT TO THE NEW ENTRY.
         USING DGDV#ENT,R9
         ST    R2,DGDV#           STORE DEVICE NUMBER.
         LTR   R7,R7              ENCOUNTERED END OF FORWARD CHAIN?
         BNZ   I1LWRDVN           NO, THIS DEVICE NUMBER IS LOWER.
         ICM   R0,15,DGNUMDV#     YES, ANY ENTRIES ON CHAIN?
         BZ    I1FSTDVN           NO, THIS IS THE FIRST DEVICE READ.
         ST    R5,DGDV#PRV        YES, NEW POINTS BACK TO OLD LAST.
         ST    R9,0(,R5)          OLD LAST POINTS FWD TO NEW ENTRY.
         ST    R9,DGLSTDV#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     I1CNTDVN           DEV NUMBER ENTRY CHAIN NOW UPDATED.
I1FSTDVN ST    R9,DGFSTDV#        NEW ENTRY IS NOW THE FIRST ENTRY.
         ST    R9,DGLSTDV#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     I1CNTDVN           DEV NUMBER ENTRY CHAIN NOW UPDATED.
I1LWRDVN ST    R7,DGDV#NXT        NEW ENTRY POINTS FWD TO OLD ENTRY.
         MVC   DGDV#PRV,4(R7)     OLD BACK POINTER IS NEW BACK PTR.
         ST    R9,0(,R5)          POINT FORWARD TO NEW ENTRY.
         ST    R9,4(,R7)          POINT BACK TO NEW ENTRY.
         DROP  R9                 DGDV#ENT.
I1CNTDVN LA    R0,1
         A     R0,DGNUMDV#        INCREMENT THE DIFFERENT DEVICE
         ST    R0,DGNUMDV#        NUMBER COUNT FOR THIS SYSTEM.
I1DENTOK DS    0H
         LA    R0,DGDEVLEN        GET THE DEVICE ENTRY SIZE.
         MVI   ENTRYTYP,4         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGDEVICE,R6
         ICM   R7,15,DGLSTDEV     POINT TO THE PREVIOUSLY LAST ENTRY.
         BZ    I1FSTDEV           ZERO SO FIRST TYPE 74 FOR INTERVAL.
         ST    R7,DGDEVPRV        NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R7)          OLD LAST POINTS FORWARD TO NEW.
         B     I1LSTDEV           GO UPDATE THE INTERVAL ENTRY.
I1FSTDEV ST    R6,DGFSTDEV        THIS IS THE FIRST DEVICE ENTRY.
I1LSTDEV ST    R6,DGLSTDEV        THIS IS NOW THE LAST DEVICE ENTRY.
         ST    R2,DGDEVNAM        PUT DEVICE NUMBER INTO ENTRY.
         MVI   DGDEVFLG,X'41'     SAY NO LCU DATA AND ONLINE.
         MVC   DGDEVVOL,PDLFI2VL  COPY VOLUME SERIAL NUMBER.
         MVI   DGDEVTYP+2,X'20'   COPY DEVICE UNIT TYPE BYTES.
         MVC   DGDEVSGN,PDLFI2DT  COPY EBCDIC DEVICE TYPE NAME.
         OI    DGDEVFL2,DGDEV0IO  ASSUME ZERO I/O IN INTERVAL.
         ICM   R9,15,PDLFI2IR     GET THE DEVICE I/O COUNT.
         BZ    I1DIOCOK           ZERO SO SKIP SOME CALCULATIONS.
         LR    R0,R9              COPY IT.
         XI    DGDEVFL2,DGDEV0IO  NON-ZERO I/O IN INTERVAL.
         M     R8,=F'100000'      WANT HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        DIVIDE I/O COUNT BY ELAPSED TIME.
         ST    R9,DGDEVACT        SAVE DEVICE ACTIVATION RATE.
         TM    PDLFI2F2,PDLFI2NI  DEVICE TIME MEASUREMENTS LOGGED?
         BZ    I1IOOKAY           YES, USE THEM.
I1BADATA SLR   R9,R9              NO, USE SAMPLED UTILIZATION.
         ICM   R9,3,PDLFI2DB      GET DEVICE BUSY PERCENT.
         CL    R9,=F'10000'       IS IT TOO STUPID EVEN FOR US?
         BNL   I1DIOCOK           YES, IGNORE IT TOTALLY.
         M     R8,=F'10'          CONVERT TO PERMILLE.
         ST    R9,DGDEVMTP        SAVE IT IN "MOUNT PENDING" FIELD.
         B     I1DIOCOK           IGNORE ERRONEOUS MEASUREMENTS.
I1IOOKAY CLI   PDLFI2CT,X'00'     DEVICE CONNECT TIME TOO LARGE?
         BH    I1BADATA           YES, AVOID S0C9 ABEND.
         CLI   PDLFI2SD,X'00'     DEVICE DISCONNECT TIME TOO LARGE?
         BH    I1BADATA           YES, AVOID S0C9 ABEND.
         CLI   PDLFI2RP,X'00'     REQUEST PENDING TIME TOO LARGE?
         BH    I1BADATA           YES, AVOID S0C9 ABEND.
         ICM   R9,15,PDLFI2CT     GET THE DEVICE CONNECT TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         DR    R8,R0              GET CONNECT MICROSECONDS PER IO.
         ST    R9,DGDEVAVC        SAVE IT.
         ICM   R9,15,PDLFI2SD     GET THE DEVICE DISCONNECT TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         DR    R8,R0              GET DISCONNECT MICROSECONDS PER IO.
         ST    R9,DGDEVAVD        SAVE IT.
         ICM   R9,15,PDLFI2RP     GET THE DEVICE PENDING TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         DR    R8,R0              GET PENDING MICROSECONDS PER IO.
         ST    R9,DGDEVAVP        SAVE IT.
         ICM   R9,15,PDLFI2CT     GET THE DEVICE CONNECT TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVCON        SAVE CONNECT TIME PERMILLAGE.
         ICM   R9,15,PDLFI2SD     GET THE DEVICE DISCONNECT TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVDIS        SAVE DISCONNECT TIME PERMILLAGE.
         ICM   R9,15,PDLFI2RP     GET THE DEVICE PENDING TIME.
         SLR   R8,R8
         SLDL  R8,10              CONVERT TO MICROSECONDS.
         D     R8,DGINTSIZ        DIVIDE BY ELAPSED TIME.
         ST    R9,DGDEVPND        SAVE PENDING TIME PERMILLAGE.
I1DIOCOK AH    R15,WORK+6         POINT TO NEXT DEVICE DATA SECTION.
         LH    R5,WORK+4          GET REMAINING DEVICE COUNT OF RECORD.
         BCT   R5,I1DEVLP1        PROCESS NEXT DEVICE, IF ANY.
         B     GATMAIN            END OF PDLF I001 RECORD PROCESSING.
         SPACE
         DROP  R6,R15             DGDEVICE, PDLFI2ST.
         SPACE 2
SCANP001 DS    0H                 PROCESS PERFORMANCE GROUP RECORD.
         USING PDLFCELM,R2
         USING PDLFP1HD,R15
         MVC   WORK+2(2),PDLFCELN COPY PERF. PERIOD ELEMENT LENGTH.
         DROP  R2                 PDLFCELM.
         SLR   R5,R5
         ICM   R5,3,PDLFCNOE      GET THE PERFORMANCE PERIOD COUNT.
P1PGNLP1 SLR   R2,R2
         IC    R2,PDLFP1PG        LOAD THE PERFORMANCE GROUP NUMBER.
         ST    R5,WORK+4          REMEMBER REMAINING ELEMENT COUNT.
         LA    R7,DGFSTPG#        POINT TO THE PGN ENTRY POINTERS.
P1PGNLP2 LR    R5,R7              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R7,15,0(R7)        POINT TO THE NEXT PG NUMBER ENTRY.
         BZ    P1NEWPGN           NO MORE PGN ENTRIES SO MAKE ONE.
         USING DGPG#ENT,R7
         C     R2,DGPG#           COMPARE PERFORMANCE GROUP NUMBERS.
         BH    P1PGNLP2           RECORD FROM HIGHER PGN SO CONTINUE.
         BE    P1PENTOK           FOUND THE PGN ENTRY IN THE LIST.
*        BL    P1NEWPGN           RECORD FROM LOWER PGN SO MAKE ENTRY.
         DROP  R7                 DGPG#ENT.
         SPACE
P1NEWPGN LA    R0,DGPG#LEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,1         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGPG#ENT,R6
         ST    R2,DGPG#           STORE PERFORMANCE GROUP NUMBER.
         LTR   R7,R7              ENCOUNTERED END OF FORWARD CHAIN?
         BNZ   P1LWRPGN           NO, THIS PG NUMBER IS LOWER.
         ICM   R0,15,DGNUMPG#     YES, ANY ENTRIES ON CHAIN?
         BZ    P1FSTPGN           NO, THIS IS THE FIRST PGN READ.
         ST    R5,DGPG#PRV        YES, NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R5)          OLD LAST POINTS FWD TO NEW ENTRY.
         ST    R6,DGLSTPG#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     P1CNTPGN           PG NUMBER ENTRY CHAIN NOW UPDATED.
P1FSTPGN ST    R6,DGFSTPG#        NEW ENTRY IS NOW THE FIRST ENTRY.
         ST    R6,DGLSTPG#        NEW ENTRY IS NOW THE LAST ENTRY.
         B     P1CNTPGN           PG NUMBER ENTRY CHAIN NOW UPDATED.
P1LWRPGN ST    R7,DGPG#NXT        NEW ENTRY POINTS FWD TO OLD ENTRY.
         MVC   DGPG#PRV,4(R7)     OLD BACK POINTER IS NEW BACK PTR.
         ST    R6,0(,R5)          POINT FORWARD TO NEW ENTRY.
         ST    R6,4(,R7)          POINT BACK TO NEW ENTRY.
         DROP  R6                 DGPG#ENT.
P1CNTPGN LA    R0,1
         A     R0,DGNUMPG#        INCREMENT THE DIFFERENT PERFORMANCE
         ST    R0,DGNUMPG#        GROUP NUMBER COUNT FOR THIS SYSTEM.
P1PENTOK L     R5,WORK+4          RESTORE REMAINING ELEMENT COUNT.
         LR    R8,R5              COPY IT.
         SLR   R6,R6              CLEAR THE PERIOD COUNTER.
         LR    R7,R15             COPY CURRENT ELEMENT POINTER.
P1PGNLP3 CLC   PDLFP1PG,0(R7)     THIS PERIOD IN THE SAME GROUP?
         BNE   P1EOPLP3           NO, PAST THIS GROUP'S DATA.
         LA    R6,1(,R6)          YES, COUNT IT.
         AH    R7,WORK+2          POINT TO THE NEXT PERIOD ELEMENT.
         BCT   R8,P1PGNLP3        CHECK THE NEXT PERIOD ELEMENT.
P1EOPLP3 ST    R6,WORK+4          SAVE THE PERIOD COUNT.
         LA    R8,DGPERLEN        GET THE PERIOD SECTION LENGTH.
         STH   R8,WORK
         LR    R8,R6              GET THE PERIOD COUNT FOR THIS GROUP.
         MH    R8,WORK            GET THE LENGTH FOR ALL PERIODS.
         LA    R0,DGPRFLEN(,R8)   GET THE TOTAL GROUP ENTRY SIZE.
         MVI   ENTRYTYP,5         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGPRFGRP,R6
         ICM   R7,15,DGLSTPGN     POINT TO THE PREVIOUSLY LAST ENTRY.
         BZ    P1FSTPRF           ZERO SO PROBABLY PGN 0 (IE. 1ST PG).
         ST    R7,DGPRFPRV        NEW POINTS BACK TO OLD LAST.
         ST    R6,0(,R7)          OLD LAST POINTS FORWARD TO NEW.
         B     P1LSTPRF           GO UPDATE THE INTERVAL ENTRY.
P1FSTPRF ST    R6,DGFSTPGN        THIS IS THE FIRST PG ENTRY.
P1LSTPRF ST    R6,DGLSTPGN        THIS IS NOW THE LAST PG ENTRY.
         ST    R2,DGPRFNUM        PUT PG NUMBER INTO ENTRY.
         MVC   DGPRFPER,WORK+4    LOAD THE PERF. GROUP PERIOD COUNT.
         L     R0,DGPRFPER        GET THE PERIOD COUNT.
         ST    R15,WORK+4         SAVE CURRENT ELEMENT POINTER.
         SLR   R9,R9              CLEAR ACCUMULATOR.
P1PGNLP4 ICM   R8,15,PDLFP1RQ     GET THE PERIOD I/O REQUEST COUNT.
         ALR   R9,R8              ACCUMULATE IT.
         AH    R15,WORK+2         POINT TO THE NEXT ELEMENT.
         BCT   R0,P1PGNLP4        PROCESS NEXT PERIOD.
         M     R8,=F'100000'      WANT HUNDREDTHS PER SECOND.
         D     R8,DGINTSIZ        DIVIDE ACCUMLATOR BY ELAPSED TIME.
         A     R9,DGIORATE        ACCUMULATE SYSTEM I/O RATE.
         ST    R9,DGIORATE        SAVE TOTAL SYSTEM I/O RATE.
         C     R9,DGMAXIOR        NEW MAXIMUM I/O RATE FOR SYSTEM?
         BNH   P1IORTOK           NO, DO NOT ALTER HIGH-WATER-MARK.
         ST    R9,DGMAXIOR        YES, SAVE IT FOR SCALING PURPOSES.
P1IORTOK L     R0,DGPRFPER        GET THE PERIOD COUNT.
         L     R15,WORK+4         RESTORE CURRENT ELEMENT POINTER.
         SLR   R7,R7              CLEAR ACCUMULATOR.
         SLR   R9,R9              CLEAR ACCUMULATOR.
P1PGNLP5 SLR   R8,R8              CLEAR FOR INSERT.
         ICM   R8,3,PDLFP1TJ      PERIOD INTERVAL TRANSACTION COUNT.
         ALR   R7,R8              ACCUMULATE IT.
         ICM   R8,15,PDLFP1RT     PERIOD INTERVAL RESPONSE TIME.
         ALR   R9,R8              ACCUMULATE IT.
         AH    R15,WORK+2         POINT TO THE NEXT ELEMENT.
         BCT   R0,P1PGNLP5        PROCESS NEXT PERIOD.
         ST    R7,DGPRFXAN        SAVE PERF. GROUP TRANSACTION COUNT.
         LTR   R7,R7              ANY TRANSACTIONS?
         BNP   P1PGXNOK           NO, DO NOT DIVIDE BY ZERO.
         SLR   R8,R8
         DR    R8,R7              GET PG RESPONSE TIME PER TRANSACTION.
         ST    R9,DGPRFXTM        SAVE IT.
P1PGXNOK L     R15,WORK+4         RESTORE CURRENT ELEMENT POINTER.
         L     R0,DGPRFPER        GET THE PERIOD COUNT.
         LA    R2,DGPRFLEN(,R6)   POINT TO FIRST PERIOD SECTION.
         USING DGPERIOD,R2
P1PGNLP6 SLR   R7,R7              CLEAR FOR INSERT.
         ICM   R7,3,PDLFP1TJ      PERIOD INTERVAL TRANSACTION COUNT.
         BZ    P1PPXNOK           DO NOT DIVIDE BY ZERO.
         ST    R7,DGPERXAN        SAVE IT.
         ICM   R9,15,PDLFP1RT     PERIOD INTERVAL RESPONSE TIME.
         SLR   R8,R8
         DR    R8,R7              GET PP RESPONSE TIME PER TRANSACTION.
         ST    R9,DGPERXTM        SAVE IT.
P1PPXNOK STM   R14,R12,12(R13)    SAVE REGISTERS.
         LA    R0,8               LOAD MAXIMUM CPU COUNT.
         SLR   R7,R7              ZERO ACTIVE CPU COUNT.
         SLR   R9,R9              ZERO CPU UTILIZATION.
         SLR   R14,R14            CLEAR WORK REGISTER.
         LA    R8,PDLFP1C0        POINT TO FIRST CPU BUSY FIELD.
P1PGNLP7 CLI   0(R8),PDLFP1OF     ACTIVE CPU?
         BE    P1PGNXT7           NO, DO NOT COUNT.
         IC    R14,0(,R8)         YES, GET PERIOD UTILIZATION.
         ALR   R9,R14             ACCUMULATE IT.
         LA    R7,1(,R7)          INCREMENT CPU COUNT.
P1PGNXT7 LA    R8,1(,R8)          POINT TO NEXT CPU FIELD.
         BCT   R0,P1PGNLP7        PROCESS NEXT CPU.
         M     R8,=F'10'          CONVERT PERCENT TO PERMILLE.
         DR    R8,R7              GET AVERAGE OVER EACH CP.
         ST    R9,DGPERCPU        SAVE IT.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         LA    R2,DGPERLEN(,R6)   POINT TO NEXT PERIOD SECTION.
         AH    R15,WORK+2         POINT TO THE NEXT ELEMENT.
         BCT   R0,P1PGNLP6        PROCESS NEXT PERIOD.
         S     R5,DGPRFPER        UPDATE ELEMENT COUNT FOR NEXT P.G.
         BP    P1PGNLP1           PROCESS NEXT PERFORMANCE GROUP.
         B     GATMAIN            END OF PDLF P001 RECORD PROCESSING.
         SPACE
         DROP  R2,R6,R15          DGPERIOD, DGPRFGRP, PDLFP1HD.
         SPACE
         DROP  R1                 PDLFHDR.
         SPACE 2
         DROP  R4,R3              DGRMFINT, DGSYSTEM.
         TITLE 'PROCESS DATA SET EVENT SMF RECORD TYPES'
         USING SMFRECD,R1
DGDSET14 DS    0H                 PROCESS SMF RECORD TYPE 14/15.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF14JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF14JBN        POINT TO THE JOB NAME.
         LA    R3,DASDJOB         POINT TO THE JOB NAME MASK.
         TM    SMF14RIN,SMF14DAD  DASD DATA SET?
         BO    DGJOBN14           YES, CHECK DASD JOB NAME MASK.
         LA    R3,TAPEJOB         NO, CHECK TAPE JOB NAME MASK.
DGJOBN14 BAS   R14,MASKTEST       RECORD THIS EVENT?
         BE    GATMAIN            NO, DISCARD THE DATA.
         LA    R8,SMFJFCB1        POINT TO THE DATA SET NAME.
         CLC   =CL8'********',TRACEJOB
         BNE   DGKEEP14           COLLECT EVENT IF TRACING JOB.
         L     R15,CVTPTR(,0)     POINT TO THE CVT.
         USING CVT,R15            COMMUNICATION VECTOR TABLE.
         L     R15,CVTSMCA        POINT TO THE SMCA.
         DROP  R15                CVT.
         USING SMCABASE,R15       SMF COMMUNICATION AREA.
         TM    SMCAOPT,SMCATDS    TEMPORARY SCRATCH DATA FOR THIS SITE?
         BO    DGKEEP14           YES, COLLECT ALL DATA POSSIBLE.
         DROP  R15                SMCABASE.
*                                 NO, SELECTIVELY DISCARD SOME RECORDS.
         TM    SMF14RIN,SMF14DAD  TAPE DATA SET?
         BZ    DGKEEP14           YES, COLLECT THE DATA.
         TM    SMF14RIN,SMF14IS+SMF14JIS   ANY HINT OF ISAM?
         BNZ   DGKEEP14           YES, COLLECT THE DATA.
         TM    SMF14RIN,SMF14VIO  VIO DATA SET?
         BO    GATMAIN            YES, DISCARD THE DATA.
         TM    SMF14RIN,SMF14TDS  DASD TEMPORARY DATA SET?
         BO    GATMAIN            YES, DISCARD THE DATA.
         TM    SMFDEBOP,X'0B'     OPEN FOR OTHER THAN INPUT OR UPDAT?
         BNZ   DGKEEP14           YES, COLLECT THE DATA.
         TM    SMFDEBOP,X'0F'     OPEN FOR OTHER THAN INPUT?
         BNZ   HLQCHECK           YES, CHECK THE HIGH LEVEL QUALIFIER.
         CLC   =C'SMPPTS  ',SMFTIOE5   SMP PTF TERMPORARY STORE?
         BE    BPAMREAD                YES.
         CLC   =C'SYSPROC ',SMFTIOE5   CLIST FILE?
         BE    BPAMREAD                YES.
         CLC   =C'SYSEXEC ',SMFTIOE5   REXX FILE?
         BE    BPAMREAD                YES.
*        CLC   =C'SYSUPROC',SMFTIOE5   USER CLIST FILE?
*        BE    BPAMREAD                YES.
*        CLC   =C'SYSUEXEC',SMFTIOE5   USER REXX FILE?
*        BE    BPAMREAD                YES.
         CLC   =C'PFDMENUS',SMFTIOE5   PFD PANEL FILE?
         BE    BPAMREAD                YES.
         CLC   =C'PFDMSGS ',SMFTIOE5   PFD MESSAGE FILE?
         BE    BPAMREAD                YES.
         CLC   =C'PFDPROCS',SMFTIOE5   PFD SKELETON FILE?
         BE    BPAMREAD                YES.
         CLC   =C'ISP',SMFTIOE5        ISPF FILE?
         BNE   HLQCHECK                NO.
         CLC   =C'LIB ',SMFTIOE5+4     ISPF FILE?
         BNE   HLQCHECK                NO.
BPAMREAD TM    SMFDCBOR,JFCORGPO       INPUT USING BPAM?
         BO    GATMAIN                 YES, DISCARD THE DATA.
HLQCHECK CLC   =C'ISPPROF ',SMFTIOE5   ISPF PROFILE?
         BE    GATMAIN                 YES, DISCARD FOR ANY HLQ.
         CLC   =C'PFDATTRS',SMFTIOE5   PFD PROFILE?
         BE    GATMAIN                 YES, DISCARD FOR ANY HLQ.
         LA    R9,SMF14JBN+7      POINT TO THE JOB NAME.
         LA    R7,7(,R8)          POINT TO THE DATA SET NAME.
         LA    R0,8               GET THE MAXIMUM LENGTH TO CHECK.
PREFXLP1 CLI   0(R9),C' '         TRAILING BLANK IN JOB NAME?
         BNE   PREFXLP2           NO, START COMPARISON.
         BCTR  R9,0               YES, BACK UP ONE IN JOB NAME.
         BCTR  R7,0               BACK UP ONE IN DATA SET NAME.
         BCT   R0,PREFXLP1        CONTINUE.
         B     DGKEEP14           LOOK FOR MATCHING BLANK DSNAME ENTRY.
PREFXLP2 CLC   0(1,R9),0(R7)      JOBNAME/DSN PREFIX MISMATCH?
         BNE   JMRUCHEK           YES, GO CHECK FOR MATCHING USERID.
         BCTR  R9,0               NO, BACK UP ONE IN JOB NAME.
         BCTR  R7,0               BACK UP ONE IN DATA SET NAME.
         BCT   R0,PREFXLP2        CONTINUE.
         B     GATMAIN            ASSUME USER LOOKING AT OWN FILE.
JMRUCHEK LA    R9,SMF14UID        POINT TO THE JMR USER FIELD.
         LR    R7,R8              POINT TO THE DATA SET NAME.
         LA    R0,8               GET THE MAXIMUM LENGTH TO CHECK.
PREFXLP3 CLI   0(R9),C' '         BLANK IN "USERID"?
         BNH   Q1ENDCHK           YES, CHECK FOR THE END OF THE HLQ.
         CLC   0(1,R7),0(R9)      USERID/DSN PREFIX MISMATCH?
         BNE   DGKEEP14           YES, COLLECT THE DATA.
         LA    R9,1(,R9)          POINT TO NEXT BYTE IN USERID.
         LA    R7,1(,R7)          POINT TO NEXT BYTE IN DATA SET NAME.
         BCT   R0,PREFXLP3        CONTINUE.
Q1ENDCHK CLI   0(R7),C'.'         END OF FIRST QUALIFIER?
         BE    GATMAIN            YES, MATCH SO DISCARD THE DATA.
*        B     DGKEEP14           NO, MISMATCH SO COLLECT THE DATA.
DGKEEP14 LA    R0,DGDSEL14        LOAD TYPE 14/15 ENTRY SIZE.
         B     DGDSSRCH           COLLECT THE DATA.
         SPACE
DGDSET17 DS    0H                 PROCESS SMF RECORD TYPE 17.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF17JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF17JBN        POINT TO THE JOB NAME.
         LA    R3,DASDJOB         POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BE    GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL17        LOAD TYPE 17 ENTRY SIZE.
         LA    R8,SMF17DSN        POINT TO THE DATA SET NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET18 DS    0H                 PROCESS SMF RECORD TYPE 18.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF18JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF18JBN        POINT TO THE JOB NAME.
         LA    R3,DASDJOB         POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BE    GATMAIN            NO, DISCARD THE DATA.
         XC    RENCOMMA,RENCOMMA  CLEAR THE RENAME COMMUNICATION AREA.
         LA    R0,DGDSEL18        LOAD TYPE 18 ENTRY SIZE.
         LA    R8,SMF18ODS        POINT TO THE OLD DATA SET NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET61 DS    0H                 PROCESS SMF RECORD TYPE 61.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF61JNM        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL61        LOAD TYPE 61 ENTRY SIZE.
         LA    R8,SMF61ENM        POINT TO THE ENTRY NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET62 DS    0H                 PROCESS SMF RECORD TYPE 62.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF62JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL62        LOAD TYPE 62 ENTRY SIZE.
         LA    R8,SMF62DNM        POINT TO THE ENTRY NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET64 DS    0H                 PROCESS SMF RECORD TYPE 64.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF64JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL64        LOAD TYPE 64 ENTRY SIZE.
         LA    R8,SMF64DNM        POINT TO THE PHYSICAL DATA SET NAME.
         CLI   0(R8),C'$'         VALID NAME?
         BNL   DGDSSRCH           POSSIBLY, ASSUME IT IS.
         SLR   R8,R8              NO, CLEAR FOR INSERT.
         ICM   R8,3,SMF64ESL      GET EXTENT SECTION LENGTH.
         LA    R8,SMF64FEX(R8)    POINT PAST EXTENT SECTION.
         USING SMF64STS,R8        STATISTICS SECTION ADDRESSABILITY.
         LA    R8,SMF64CLN        USE THE JCL DATA SET NAME.
         DROP  R8                 SMF64STS.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET65 DS    0H                 PROCESS SMF RECORD TYPE 65.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF65JNM        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL65        LOAD TYPE 65 ENTRY SIZE.
         LA    R8,SMF65ENM        POINT TO THE ENTRY NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSET66 DS    0H                 PROCESS SMF RECORD TYPE 66.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF66JNM        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL66        LOAD TYPE 66 ENTRY SIZE.
         LA    R8,SMF66ENM        POINT TO THE ENTRY NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSETHF DS    0H                 PROCESS HSM FUNCTION SMF RECORD.
         CLC   =H'300',0(R1)      AT LEAST 300 BYTES LONG?
         BL    GATMAIN            NO, CAN'T BE HSM SO DISCARD RECORD.
         MVC   HSMFNTYP,5(R1)     UPDATE THE HSM FUNCTION RECORD TYPE.
         CLI   42(R1),14          KNOWN FUNCTION TYPE CODE?
         BH    GATMAIN            NO, DISCARD THIS RECORD.
         SLR   R15,R15            CLEAR FOR INSERT.
         IC    R15,42(,R1)        LOAD FUNCTION TYPE CODE.
         LA    R15,HSMSEL(R15)    POINT TO SELECTION BYTE.
         ICM   R0,1,0(R15)        INTERESTED IN THIS RECORD?
         BZ    GATMAIN            NO, DISCARD IT.
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF14JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         LA    R0,DGDSEL14        LOAD TYPE 14/15 ENTRY SIZE.
         LA    R8,44(,R1)         POINT TO THE DATA SET NAME.
         B     DGDSSRCH           LOOK FOR MATCHING DSNAME ENTRY.
         SPACE
DGDSTARG DS    0H                 PROCESS "RENAME-TO" ENTRIES.
         LA    R0,DGDSEL18        LOAD TYPE 18 ENTRY SIZE.
         LA    R8,SMF18NDS        POINT TO THE NEW DATA SET NAME.
         CLI   SMF18RTY,18        TYPE 18 SMF RECORD?
         BE    DGDSSRCH           YES, PROCESS IT.
         LA    R0,DGDSEL66        LOAD TYPE 66 ENTRY SIZE.
         LA    R8,SMF66NNM        NO, MUST BE A TYPE 66 SMF RECORD.
         SPACE
DGDSSRCH CLI   0(R8),C'$'         VALID NAME?
         BNL   MKNEWDSE           YES, ASSUME IT IS AND PROCEED.
         CLI   0(R8),X'04'        WAS THE VTOC ACCESSED?
         BNE   GATMAIN            NO, IGNORE BLANK OR BAD NAME.
         LA    R8,=CL44' *** FORMAT4.DSCB/VTOC *** '
MKNEWDSE MVI   ENTRYTYP,8         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGDSEVNT,R6
         L     R2,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R2
         LA    R3,DGFSTDSN        POINT TO THE FIRST DSN ENTRY POINTER.
         LR    R5,R3              COPY FIRST DSN ENTRY POINTER.
         CLI   0(R8),C'R'         DSNAME STARTS WITH 'S' OR LATER?
         BH    DGDSNLP2           YES, SEARCH FROM END, NOT START.
DGDSNLP1 LR    R5,R3              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R3,15,0(R3)        POINT TO THE NEXT DSNAME ENTRY.
         BZ    MKNEWDSN           NO MORE DSNAME ENTRIES SO MAKE ONE.
         USING DGDATAST,R3
         CLC   DGDSNAME,0(R8)     FOUND THE MATCHING DSNAME ENTRY?
         BE    DSNMATCH           YES.
         BL    DGDSNLP1           NO, TRY THE NEXT ONE.
         B     MKNEWDSN           PAST WHERE IT SHOULD BE SO MAKE IT.
DGDSNLP2 ICM   R3,15,4(R3)        POINT TO THE PREVIOUS DSNAME ENTRY.
         BZ    MKNEWDSN           NO MORE DSNAME ENTRIES SO MAKE ONE.
         USING DGDATAST,R3
         CLC   DGDSNAME,0(R8)     FOUND THE MATCHING DSNAME ENTRY?
         BE    DSNMATCH           YES.
         BH    DGDSNLP2           NO, TRY THE NEXT ONE.
         LR    R5,R3              REMEMBER ENTRY BEFORE NEW ENTRY.
*        B     MKNEWDSN           PAST WHERE IT SHOULD BE SO MAKE IT.
MKNEWDSN LA    R0,DGDSNLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,7         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R3,R0              POINT TO THE NEW ENTRY.
         MVC   DGDSNAME,0(R8)     LOAD THE DATA SET NAME.
         ICM   R4,15,0(R5)        ENCOUNTERED END OF CHAIN?
         BZ    LASTDSN            YES, ADD NEW LAST ENTRY.
         ST    R4,DGDSNNXT        NO, POINT FORWARD TO NEXT ENTRY.
         ST    R3,4(,R4)          POINT BACKWARD TO THIS ENTRY.
         B     CHAINDSN           CONTINUE WITH CHAIN UPDATE.
LASTDSN  ST    R3,DGLSTDSN        NEW ONE IS NOW THE LAST ONE.
CHAINDSN LA    R0,DGFSTDSN        POINT TO THE FIRST DSN ENTRY POINTER.
         CR    R5,R0              IS THIS THE FIRST DSNAME ENTRY?
         BE    FIRSTDSN           YES.
         ST    R3,0(,R5)          NO, POINT FORWARD TO THIS ENTRY.
         ST    R5,DGDSNPRV        POINT BACK TO PREVIOUS ENTRY.
         B     COUNTDSN           GO INCREMENT THE DSN ENTRY COUNT.
FIRSTDSN ST    R3,DGFSTDSN        THIS IS THE FIRST DSNAME ENTRY.
COUNTDSN LA    R0,1
         A     R0,DGNUMDSN        INCREMENT THE DSNAME ENTRY COUNTER.
         ST    R0,DGNUMDSN
         DROP  R2                 DGBASE.
         SPACE
DSNMATCH DS    0H                 FILL IN THE DATA SET EVENT ENTRY.
         MVC   DGDSETYP,SMF14RTY  COPY SMF RECORD TYPE.
         MVC   DGDSETIM,RECTIME   COPY SMF RECORD TIME.
         MVC   DGDSEDAT,SMF14DTE  COPY SMF RECORD DATE.
         MVC   DGDSESID,SMF14SID  COPY SMF SYSTEM IDENTIFIER.
         ST    R3,DGDSENAM        SAVE POINTER TO DATA SET ENTRY.
         MVI   DGDSEVOL,C' '      BLANK THE VOLUME SERIAL NUMBER LIST.
         MVC   DGDSEVOL+1(29),DGDSEVOL
         CLI   SMF61RTY,61        TYPE 61?
         BE    FILDSE61           YES, FILL IN TYPE 61 DETAILS.
         CLI   SMF61RTY,62        TYPE 62?
         BE    FILDSE62           YES, FILL IN TYPE 62 DETAILS.
         CLI   SMF65RTY,65        TYPE 65?
         BE    FILDSE65           YES, FILL IN TYPE 65 DETAILS.
         CLI   SMF65RTY,66        TYPE 66?
         BE    FILDSE66           YES, FILL IN TYPE 66 DETAILS.
         MVC   DGDSEJOB,SMF14JBN  COPY THE JOB NAME.
         MVC   DGDSEUSR,SMF14UID  COPY THE JMRUSEID FIELD.
         TM    SMF14RTY,X'80'     HSM FUNCTION RECORD?
         BO    FILDSEHF           YES, FILL IN HSM DETAILS.
         MVC   DGDSERIN,SMF14RIN  COPY SMF RECORD INDICATORS.
         CLI   SMF64RTY,64        TYPE 64?
         BE    FILDSE64           YES, FILL IN TYPE 64 DETAILS.
         CLI   SMF17RTY,17        TYPE 17?
         BE    FILDSE17           YES, FILL IN TYPE 17 DETAILS.
         CLI   SMF17RTY,18        TYPE 18?
         BE    FILDSE18           YES, FILL IN TYPE 18 DETAILS.
         SPACE
         DS    0H                 FILL IN TYPE 14/15 DETAILS.
         LA    R9,DGDSEVOL        POINT TO THE FIRST VOLUME SLOT.
         LA    R7,JFCBVOLS        POINT TO THE FIRST VOLUME OF FILE.
         LA    R0,5               LOAD UP TO FIVE VOLUME SERIALS.
VL1415LP CLI   0(R7),X'FF'        SCRATCH VOLUME?
         BE    VL1415OK           YES, END OF KNOWN VOLUME SERIAL LIST.
         MVC   0(6,R9),0(R7)      NO, COPY VOLUME SERIAL NUMBER.
         LA    R9,6(,R9)          POINT TO NEXT VOLUME SLOT.
         LA    R7,6(,R7)          POINT TO NEXT VOLUME IN JFCB.
         BCT   R0,VL1415LP        PROCESS NEXT VOLUME IF ANY.
VL1415OK MVC   DGDSEDDN,SMFTIOE5  COPY THE DATA DEFINITION NAME.
         MVC   DGDSEMEM,JFCBELNM  COPY THE ELEMENT OR MEMBER NAME.
         MVC   DGDSEDCO,SMFDCBOR  COPY DCBDSORG.
         MVC   DGDSEDSO,JFCDSORG  COPY JFCDSORG.
         MVC   DGDSEDMF,SMFDCBMF  COPY DCBMACRF.
         MVC   DGDSEOPT,SMFDCBOP  COPY DCBOPTCD.
         MVC   DGDSEEOP,SMFDEBOP  COPY DEBOPATB.
         SLR   R0,R0
         IC    R0,SMF14NUC        GET UCB SECTION COUNT.
         STH   R0,DGDSENUM        SAVE THE UNIT COUNT.
         SLR   R9,R9
         IC    R9,SMF14SUC        GET UCB SECTION SIZE.
         SLR   R7,R7              CLEAR ACCUMULATOR.
         LA    R15,SMF14UCB       POINT TO THE FIRST UCB SECTION.
         TM    SMF14OPD+3,X'0F'   VALID OPEN DATE?
         BO    UCB14LP1           YES, RECORD FROM SP5 OR LATER.
         SH    R15,=H'4'          NO, ITEM DOES NOT EXIST SO ADJUST.
         USING SMF14UCB,R15
UCB14LP1 ICM   R8,15,SMFEXCP      GET THE UCB EXCP COUNT.
         AR    R7,R8              ACCUMULATE IT.
         ALR   R15,R9             POINT TO THE NEXT UCB SECTION.
         BCT   R0,UCB14LP1        PROCESS NEXT UCB SECTION.
         DROP  R15                SMF14UCB.
         ST    R7,DGDSEXCP        SAVE THE TOTAL EXCP COUNT.
         MVC   DGDSEBLK,JFCBLKSI  COPY THE DATA SET BLOCK SIZE.
         MVC   DGDSELRL,JFCLRECL  COPY THE DATA SET RECORD LENGTH.
         MVC   DGDSERFM,JFCRECFM  COPY THE DATA SET RECORD FORMAT.
         MVC   DGDSEDEV,SMFUCBDV  COPY THE UCB DEVICE NUMBER.
         MVC   DGDSEUCV,SMFSRTEV  COPY THE UCB VOLUME SERIAL NUMBER.
         MVC   DGDSETBC,SMFDCBBL  COPY THE TAPE VOLUME BLOCK COUNT.
         MVC   DGDSEFSC,SMFSRTEF  COPY THE FILE SEQUENCE COUNT.
         MVC   DGDSEFSN,SMFSRTEQ  COPY THE FILE SEQUENCE NUMBER.
         TM    SMF14RIN,SMF14DAD  TAPE DATA SET?
         BZ    XTRA1415           YES, JUMP OVER DASD PROCESSING.
         TM    SMF14RIN,SMF14EOV  END-OF-VOLUME EVENT?
         BO    XTRA1415           YES, NO TRACKS AND EXTENTS DATA.
         MVC   DGDSEKEY,JFCKEYLE  COPY THE DATA SET KEY LENGTH.
         IC    R0,SMF14NUC        GET UCB SECTION COUNT.
         SLR   R7,R7              CLEAR ACCUMULATOR.
         LA    R15,SMF14UCB       POINT TO THE FIRST UCB SECTION.
         TM    SMF14OPD+3,X'0F'   VALID OPEN DATE?
         BO    UCB14LP2           YES, RECORD FROM SP5 OR LATER.
         SH    R15,=H'4'          NO, ITEM DOES NOT EXIST SO ADJUST.
         USING SMF14UCB,R15
UCB14LP2 ICM   R8,15,SMF14NTA     GET THE VOLUME ALLOCATED TRACK COUNT.
         AR    R7,R8              ACCUMULATE IT.
         ALR   R15,R9             POINT TO THE NEXT UCB SECTION.
         BCT   R0,UCB14LP2        PROCESS NEXT UCB SECTION.
         DROP  R15                SMF14UCB.
         ICM   R8,15,SMF14NTR     GET THE DADSM RELEASED TRACK COUNT.
         SR    R7,R8              GET THE TOTAL REMAINING TRACK COUNT.
         ST    R7,DGDSETRK        SAVE THE FINAL TOTAL TRACK COUNT.
         IC    R0,SMF14NUC        GET UCB SECTION COUNT.
         LA    R15,SMF14UCB       POINT TO THE FIRST UCB SECTION.
         SLR   R7,R7              CLEAR ACCUMULATOR.
         SLR   R8,R8              CLEAR FOR INSERT.
         USING SMF14UCB,R15
UCB14LP3 IC    R8,SMF14NEX        GET THE VOLUME EXTENT COUNT.
         AR    R7,R8              ACCUMULATE IT.
         ALR   R15,R9             POINT TO THE NEXT UCB SECTION.
         BCT   R0,UCB14LP3        PROCESS NEXT UCB SECTION.
         DROP  R15                SMF14UCB.
         IC    R8,SMF14NER        GET THE DADSM RELEASED EXTENT COUNT.
         SR    R7,R8              GET THE REMAINING EXTENT COUNT.
         STH   R7,DGDSEEXT        SAVE THE FINAL TOTAL EXTENT COUNT.
XTRA1415 DS    0H                 PROCESS NEW TYPE 14/15 FIELDS.
         TM    SMF14RIN+1,SMF14XSG     ANY EXTENDED INFORMATION?
         BZ    DSEFILLD           NO.
         TM    SMF14RIN,SMF14IS+SMF14JIS   ANY HINT OF ISAM?
         BNZ   DSEFILLD           YES, MAY BE ISAM SECTION PRESENT.
         TM    SMF14RIN+1,SMF14HBT      HIPERBATCH SECTION PRESENT?
         BNZ   DSEFILLD           YES, SKIP IT.
         USING SMF14XIS,R15
         SLR   R7,R7
         ICM   R7,3,SMF14SXS      GET EXTENDED SECTION SIZE.
         BNP   DSEFILLD           IGNORE BAD DATA.
         LA    R0,0(R7,R15)       POINT PAST EXTENDED INFORMATION.
         SR    R0,R1              GET REQUIRED RECORD LENGTH.
         CLM   R0,3,SMF14LEN      RECORD LONG ENOUGH TO HOLD SECTION?
         BH    DSEFILLD           NO, IGNORE BAD DATA.
         LA    R0,SMF14XIC-SMF14XIS POINT TO PAST EXTENDED INFO HEADER.
         DROP  R15                SMF14XIS.
         USING SMF14XIC,R15
XTRA14LP SR    R7,R0              ANY EXTENDED INFORMATION LEFT?
         BNP   DSEFILLD           NO.
         AR    15,R0              YES, POINT TO IT.
         ICM   R0,3,SMF14ESL      GET LENGTH OF THIS SECTION.
         CLI   SMF14STY,SMF14SMS  PROCESS THIS SECTION?
         BE    XTRA14T2           YES.
         CLI   SMF14STY,SMF14STP  PROCESS THIS SECTION?
         BE    XTRA14T3           YES.
         B     XTRA14LP           CHECK FOR ANOTHER SECTION.
XTRA14T2 MVC   DGDSEMCN,SMF14MCN  COPY MANAGEMENT CLASS NAME.
         MVC   DGDSEDCN,SMF14DCN  COPY DATA CLASS NAME.
         MVC   DGDSESCN,SMF14SCN  COPY STORAGE CLASS NAME.
         B     XTRA14LP           CHECK FOR ANOTHER SECTION.
XTRA14T3 MVC   DGDSESTP,SMF14SPN  COPY STEP NAME.
         MVC   DGDSEPGM,SMF14PGN  COPY ACTIVE PROGRAM NAME.
         B     XTRA14LP           CHECK FOR ANOTHER SECTION.
         DROP  R15                SMF14XIC.
         SPACE
FILDSE17 DS    0H                 FILL IN TYPE 17 DETAILS.
         SLR   R0,R0              CLEAR FOR INSERT.
         ICM   R0,1,SMF17NVL      GET THE NUMBER OF VOLUMES.
         STH   R0,DGDSENUM        SAVE IT.
         BZ    DSEFILLD           SKIP PROCESSING IF NO DATA.
         LA    R15,5              GET THE MAXIMUM VOLUME SLOT COUNT.
         CR    R0,R15             ACTUAL COUNT HIGHER THAN MAXIMUM?
         BNH   CNT17OK            NO.
         LR    R0,R15             YES, REDUCE IT TO THE MAXIMUM.
CNT17OK  LA    R8,DGDSEVOL        POINT TO THE FIRST VOLUME SLOT.
         LA    R15,SMF17FVL       POINT TO THE FIRST VOLUME SERIAL.
VOL17LP  MVC   0(6,R8),0(R15)     COPY THE VOLUME SERIAL NUMBER.
         LA    R8,6(,R8)          POINT TO THE NEXT VOLUME SLOT.
         LA    R15,8(,R15)        POINT TO THE NEXT VOLUME SERIAL.
         BCT   R0,VOL17LP         PROCESS NEXT VOLUME ENTRY.
         B     DSEFILLD           TYPE 17 DSE DATA NOW COMPLETE.
         SPACE
FILDSE18 DS    0H                 FILL IN TYPE 18 DETAILS.
         SLR   R0,R0              CLEAR FOR INSERT.
         ICM   R0,1,SMF18NVL      GET THE NUMBER OF VOLUMES.
         STH   R0,DGDSENUM        SAVE IT.
         BZ    VOL18OK            SKIP PROCESSING IF NO DATA.
         LA    R15,5              GET THE MAXIMUM VOLUME SLOT COUNT.
         CR    R0,R15             ACTUAL COUNT HIGHER THAN MAXIMUM?
         BNH   CNT18OK            NO.
         LR    R0,R15             YES, REDUCE IT TO THE MAXIMUM.
CNT18OK  LA    R8,DGDSEVOL        POINT TO THE FIRST VOLUME SLOT.
         LA    R15,SMF18FVL       POINT TO THE FIRST VOLUME SERIAL.
VOL18LP  MVC   0(6,R8),0(R15)     COPY THE VOLUME SERIAL NUMBER.
         LA    R8,6(,R8)          POINT TO THE NEXT VOLUME SLOT.
         LA    R15,8(,R15)        POINT TO THE NEXT VOLUME SERIAL.
         BCT   R0,VOL18LP         PROCESS NEXT VOLUME ENTRY.
VOL18OK  LM    R14,R15,RENCOMMA   LOAD RENAME COMMUNCIATION AREA DATA.
         LTR   R15,R15            IS THIS THE "RENAME-FROM" ENTRY?
         BZ    FROM18             YES, PERFORM THE RELEVANT PROCESSING.
         ST    R14,DGDSEONM       NO, "RENAME-TO" SO SAVE OLD DSNAME.
         OI    DGDSESBT,DGDSENEW  FLAG THAT THIS IS THE "NEW" ENTRY.
         ST    R3,DGDSEONM-DGDSEVNT(,R15)  SAVE NEW DSNAME IN "OLD".
         XC    RENCOMMA,RENCOMMA  CLEAR THE RENAME COMMUNICATION AREA.
         B     DSEFILLD           TYPE 18 DSE DATA NOW COMPLETE.
FROM18   ST    R3,RENCOMMA        SAVE DGDATAST ADDRESS.
         ST    R6,RENCOMMA+4      SAVE DGDSEVNT ADDRESS.
         B     DSEFILLD           GO CHAIN UP THIS DATA SET ENTRY.
         SPACE
FILDSE61 DS    0H                 FILL IN TYPE 61 DETAILS.
         MVC   DGDSEJOB,SMF61JNM  COPY THE JOB NAME.
         MVC   DGDSEUSR,SMF61UID  COPY THE JMRUSEID FIELD.
         MVC   DGDSEENT,SMF61TYP  COPY THE CATALOG ENTRY TYPE.
         LA    R15,SMF61CRC       POINT TO THE CATALOG RECORD.
         B     DSECATRC           EXTRACT ANY VOLUME SERIAL NUMBER(S).
         SPACE
FILDSE62 DS    0H                 FILL IN TYPE 62 DETAILS.
         MVC   DGDSEJOB,SMF62JBN  COPY THE JOB NAME.
         MVC   DGDSEUSR,SMF62UIF  COPY THE JMRUSEID FIELD.
         MVC   DGDSERIN,SMF62IND  COPY 1/2 OF SMF RECORD INDICATORS.
         SLR   R0,R0              CLEAR FOR INSERT.
         ICM   R0,3,SMF62VCT      GET THE NUMBER OF VOLUMES.
         STH   R0,DGDSENUM        SAVE IT.
         BZ    DSEFILLD           SKIP PROCESSING IF NO DATA.
         LA    R15,5              GET THE MAXIMUM VOLUME SLOT COUNT.
         CR    R0,R15             ACTUAL COUNT HIGHER THAN MAXIMUM?
         BNH   CNT62OK            NO.
         LR    R0,R15             YES, REDUCE IT TO THE MAXIMUM.
CNT62OK  LA    R8,DGDSEVOL        POINT TO THE FIRST VOLUME SLOT.
         LA    R15,SMF62VSR       POINT TO THE FIRST VOLUME SERIAL.
VOL62LP  MVC   0(6,R8),0(R15)     COPY THE VOLUME SERIAL NUMBER.
         LA    R8,6(,R8)          POINT TO THE NEXT VOLUME SLOT.
         LA    R15,10(,R15)       POINT TO THE NEXT VOLUME SERIAL.
         BCT   R0,VOL62LP         PROCESS NEXT VOLUME ENTRY.
         B     DSEFILLD           TYPE 62 DSE DATA NOW COMPLETE.
         SPACE
FILDSE64 DS    0H                 FILL IN TYPE 64 DETAILS.
         SLR   R15,R15            CLEAR FOR INSERT.
         ICM   R15,3,SMF64ESL     GET EXTENT SECTION LENGTH.
         LA    R15,SMF64FEX(R15)  POINT PAST EXTENT SECTION.
         USING SMF64STS,R15       STATISTICS SECTION ADDRESSABILITY.
         MVC   DGDSEDDN,SMF64DDN  COPY DATA DEFINITION NAME.
         MVC   DGDSEXCP,SMF64DEP  COPY CHANGE IN EXCP COUNT.
         MVC   DGDSEBLK,SMF64DBS+2     COPY PHYSICAL BLOCK SIZE.
         MVC   DGDSELRL,SMF64DLS+2     COPY MAXIMUM RECORD SIZE.
         MVC   DGDSEKEY(2),SMF64DKL    COPY KEY LENGTH.
         MVC   DGDSETRK+2(2),SMF64NTR  COPY TRACK REQUEST THAT FAILED.
         ICM   R7,15,SMF64NEX     GET ORIGINAL EXTENT COUNT.
         ICM   R8,15,SMF64DEX     GET CHANGE IN EXTENT COUNT.
         AR    R7,R8              GET FINAL EXTENT COUNT.
         STH   R7,DGDSEEXT        SAVE IT.
         MVC   DGDSEDMF(3),SMF64MC1    COPY ACBMACRF.
         DROP  R15                SMF64STS.
         SLR   R0,R0              CLEAR FOR INSERT.
         ICM   R0,3,SMF64ESL      GET THE EXTENT SECTION LENGTH.
         BZ    DSEFILLD           SKIP PROCESSING IF NO DATA.
         LA    R9,26              GET EXTENT ENTRY LENGTH.
         LA    R15,SMF64FEX       POINT TO THE EXTENT SECTION.
         USING SMF64FEX,R15       EXTENT SECTION ADDRESSABILITY.
         MVC   DGDSEUCV,SMF64VSN  COPY THE FIRST VOLUME SERIAL NUMBER.
         MVC   DGDSEDEV,SMF64CUU  COPY THE FIRST DEVICE NUMBER.
         MVC   DGDSEVOL(6),SMF64VSN
         LA    R7,1               INITIALIZE VOLUME COUNTER.
         LA    R8,DGDSEVOL        INITIALIZE VOLUME SLOT POINTER.
EXT64LP1 CLC   0(6,R8),SMF64VSN   ALREADY HAVE THIS VOLUME SERIAL?
         BE    EXT64NX1           YES.
         LA    R7,1(,R7)          NO, INCREMENT VOLUME SERIAL COUNT.
         CH    R7,=H'5'           ANY EMPTY SLOTS LEFT?
         BH    EXT64NX1           NO, TERMINATE VOLUME SERIAL SCAN.
         LA    R8,6(,R8)          YES, POINT TO THE NEXT VOLUME SLOT.
         MVC   0(6,R8),SMF64VSN   COPY THIS VOLUME SERIAL NUMBER.
EXT64NX1 AR    R15,R9             POINT TO NEXT EXTENT ENTRY.
         SR    R0,R9              SUBTRACT LENGTH OF ONE EXTENT ENTRY.
         BP    EXT64LP1           PROCESS NEXT EXTENT ENTRY.
         STH   R7,DGDSENUM        SAVE THE TOTAL VOLUME COUNT.
         DROP  R15                SMF64FEX.
         B     DSEFILLD           TYPE 64 DSE DATA NOW COMPLETE.
         SPACE
FILDSE65 DS    0H                 FILL IN TYPE 65 DETAILS.
         MVC   DGDSEJOB,SMF65JNM  COPY THE JOB NAME.
         MVC   DGDSEUSR,SMF65UID  COPY THE JMRUSEID FIELD.
         MVC   DGDSEENT,SMF65TYP  COPY THE CATALOG ENTRY TYPE.
         MVC   DGDSEFNC,SMF65FNC  COPY THE SCRATCH INDICATOR.
         LA    R15,SMF65CRC       POINT TO THE CATALOG RECORD.
         B     DSECATRC           EXTRACT ANY VOLUME SERIAL NUMBER(S).
         SPACE
FILDSE66 DS    0H                 FILL IN TYPE 61 DETAILS.
         MVC   DGDSEJOB,SMF66JNM  COPY THE JOB NAME.
         MVC   DGDSEUSR,SMF66UID  COPY THE JMRUSEID FIELD.
         MVC   DGDSEENT,SMF66TYP  COPY THE CATALOG ENTRY TYPE.
         MVC   DGDSEFNC,SMF66FNC  COPY THE RENAME INDICATOR.
         CLI   DGDSEFNC,C'R'      WAS THE ALTER A RENAME OPERATION?
         BNE   TIDY66             NO.
         LM    R14,R15,RENCOMMA   LOAD RENAME COMMUNCIATION AREA DATA.
         LTR   R15,R15            IS THIS THE "RENAME-FROM" ENTRY?
         BZ    FROM66             YES, PERFORM THE RELEVANT PROCESSING.
         ST    R14,DGDSEONM       NO, "RENAME-TO" SO SAVE OLD DSNAME.
         OI    DGDSESBT,DGDSENEW  FLAG THAT THIS IS THE "NEW" ENTRY.
         ST    R3,DGDSEONM-DGDSEVNT(,R15)  SAVE NEW DSNAME IN "OLD".
         XC    RENCOMMA,RENCOMMA  CLEAR THE RENAME COMMUNICATION AREA.
         B     TIDY66             PARSE CATALOG RECORD.
FROM66   ST    R3,RENCOMMA        SAVE DGDATAST ADDRESS.
         ST    R6,RENCOMMA+4      SAVE DGDSEVNT ADDRESS.
TIDY66   LA    R15,SMF66CRC       POINT TO THE CATALOG RECORD.
         B     DSECATRC           EXTRACT ANY VOLUME SERIAL NUMBER(S).
         SPACE
DSECATRC LR    R0,R15             COPY THIS ADDRESS.
         SLR   R0,R1              GET THE CATALOG RECORD OFFSET.
         CLM   R0,3,SMF65LEN      IS THE RECORD LONG ENOUGH?
         BNL   DSEFILLD           NO, CATALOG RECORD NOT IN SMF RECORD.
         SLR   R9,R9
         ICM   R9,3,0(R15)        GET THE CATALOG RECORD LENGTH.
         ALR   R9,R0              ADD THE CATALOG RECORD OFFSET.
         CLM   R9,3,SMF65LEN      DOES THIS ADD UP?
         BNE   DSEFILLD           NO, VALIDITY CHECK FAILURE.
         AH    R15,=H'2'          POINT TO THE FIRST CELL.
         AH    R0,=H'2'           ADJUST CURRENT RECORD OFFSET.
         CLI   DGDSEENT,C'H'      GENERATION DATA GROUP MEMBER?
         BNE   DSNOTGEN           NO.
GOOVOOIT LA    R8,35              YES, GET MAXIMUM CHECK COUNT.
         LA    R7,DGDSNAME+35     POINT TO LAST POSSIBLE '.G' SPOT.
GOOVOOLP CLI   0(R7),C'.'         FOUND LAST QUALIFIER?
         BE    GOTGENUM           YES.
         BCTR  R7,0               NO, BACK UP ONE BYTE.
         BCT   R8,GOOVOOLP        CONTINUE SEARCH.
         B     DSEFILLD           NOT FOUND SO GIVE UP.
GOTGENUM CLI   1(R7),C'G'         GENERATION NUMBER HERE?
         BNE   DSEFILLD           NO, VALIDITY CHECK FAILURE.
         CLI   6(R7),C'V'         VERSION NUMBER HERE?
         BNE   DSEFILLD           NO, VALIDITY CHECK FAILURE.
         PACK  WORK,2(4,R7)       PACK THE GENERATION NUMBER.
         CVB   R8,WORK            GET THE BINARY GENERATION NUMBER.
         PACK  WORK,7(2,R7)       PACK THE VERSION NUMBER.
         CVB   R7,WORK            GET THE BINARY VERSION NUMBER.
         STH   R8,WORK            STORE THE GENERATION NUMBER.
         STC   R7,WORK+2          STORE THE VERSION NUMBER.
         SLR   R7,R7              ZERO THE VOLUME COUNT.
         LA    R8,DGDSEVOL        POINT TO THE VOLUME AREA.
         USING TYPE@H,R15
HCELLOOP CLI   GDSTYPE,C'H'       GENERATION CELL?
         BNE   NXTHCELL           NO.
         CLC   GDSGENO,WORK       YES, CORRECT GENERATION?
         BNE   NXTHCELL           NO.
         CLC   GDSVERNO,WORK+2    YES, CORRECT VERSION?
         BNE   NXTHCELL           NO.
         ICM   R7,3,GDSVOLCT      YES, GET THE VOLUME COUNT.
         STH   R7,DGDSENUM        SAVE IT.
         CH    R7,=H'5'           MORE THAN FIVE VOLUMES?
         BNH   HVOLCTOK           NO, ROOM FOR ALL OF THEM.
         LH    R7,=H'5'           YES, JUST SAVE THE FIRST FIVE.
         B     HVOLCTOK           GO PROCESS VOLUME CELLS.
NXTHCELL ICM   R9,3,GDSCELEN      GET THE GDS CELL LENGTH.
         BNP   DSEFILLD           HANDLE BAD LENGTH.
         AR    R0,R9              GET THE NEW SMF RECORD OFFSET.
         CLM   R0,3,SMF65LEN      END OF SMF RECORD?
         BNL   DSEFILLD           YES.
         ALR   R15,R9             NO, POINT TO THE NEXT CELL.
         B     HCELLOOP           PROCESS THE NEXT CELL.
         DROP  R15                TYPE@H
         USING TYPE@04,R15
HVOLCTOK CLI   VOLTYPE,X'04'      VOLUME CELL?
         BNE   LOOK4H04           NO.
         MVC   0(6,R8),VOLSERN    YES, COPY THE VOLUME SERIAL.
         LA    R8,6(,R8)          POINT TO NEXT VOLUME SERIAL SLOT.
         ICM   R9,3,VOLLEN        GET THE CELL LENGTH.
         BNP   DSEFILLD           HANDLE BAD LENGTH.
         AR    R0,R9              GET THE NEW SMF RECORD OFFSET.
         CLM   R0,3,SMF65LEN      END OF SMF RECORD?
         BNL   DSEFILLD           YES.
         ALR   R15,R9             NO, POINT TO THE NEXT CELL.
         BCT   R7,HVOLCTOK        PROCESS THE NEXT CELL.
         B     DSEFILLD           NOW HAVE CORRECT NUMBER OF VOLUMES.
LOOK4H04 ICM   R9,3,VOLLEN        GET THE CELL LENGTH.
         BNP   DSEFILLD           HANDLE BAD LENGTH.
         AR    R0,R9              GET THE NEW SMF RECORD OFFSET.
         CLM   R0,3,SMF65LEN      END OF SMF RECORD?
         BNL   DSEFILLD           YES.
         ALR   R15,R9             NO, POINT TO THE NEXT CELL.
         B     HVOLCTOK           SEE IF IT IS A VOLUME CELL.
         SPACE
DSNOTGEN SLR   R7,R7              ZERO THE VOLUME COUNT.
         LA    R8,DGDSEVOL        POINT TO THE VOLUME AREA.
CCELLOOP CLI   VOLTYPE,C'H'       NONVSAM ACTUALLY A GDG MEMBER?
         BE    GOOVOOIT           YES, PROBABLY MSP, PROCESS AS 'H'.
         CLI   VOLTYPE,X'04'      VOLUME CELL?
         BNE   NXTCCELL           NO.
         LA    R7,1(,R7)          YES, INCREMENT VOLUME COUNT.
         STH   R7,DGDSENUM        UPDATE THE VOLUME COUNT.
         CH    R7,=H'5'           MORE THAN FIVE VOLUMES SO FAR?
         BH    NXTCCELL           YES, NO ROOM FOR VOLUME SERIAL.
         MVC   0(6,R8),VOLSERN    NO, COPY THE VOLUME SERIAL.
         LA    R8,6(,R8)          POINT TO NEXT VOLUME SERIAL SLOT.
NXTCCELL ICM   R9,3,VOLLEN        GET THE CELL LENGTH.
         BNP   DSEFILLD           HANDLE BAD LENGTH.
         AR    R0,R9              GET THE NEW SMF RECORD OFFSET.
         CLM   R0,3,SMF65LEN      END OF SMF RECORD?
         BNL   DSEFILLD           YES.
         ALR   R15,R9             NO, POINT TO THE NEXT CELL.
         B     CCELLOOP           PROCESS THE NEXT CELL.
         DROP  R15                TYPE@04
         SPACE
FILDSEHF DS    0H                 FILL IN HSM DETAILS.
         MVC   DGDSETYP,42(R1)    COPY FUNCTION TYPE.
         OI    DGDSETYP,X'80'     GET IMP INTERNAL CODE OF THIS.
         MVC   DGDSEDEV,96(R1)    COPY DEVICE TYPE BYTES.
         MVC   DGDSERIN,178(R1)   COPY FUNCTION FLAGS.
         MVC   DGDSEDCO,176(R1)   COPY THE DATA SET ORGANIZATION.
         MVC   DGDSEOPT,187(R1)   COPY THE I/O OPTION CODES.
         MVC   DGDSERFM,186(R1)   COPY THE RECORD FORMAT.
         MVC   DGDSESCN,196(R1)   COPY THE STORAGE CLASS NAME.
         MVC   DGDSEMCN,214(R1)   COPY THE MANAGEMENT CLASS NAME.
         MVC   DGDSEXCP+2(2),184(R1)   COPY THE AGE.
         MVI   DGDSENUM+1,1       ASSUME ONE VOLUME INVOLVED.
         CLI   42(R1),4           RECALL?
         BE    HSMTODSK           YES.
         CLI   42(R1),5           RECALL?
         BE    HSMTODSK           YES.
         CLI   42(R1),9           RECOVER?
         BE    HSMTODSK           YES.
         CLI   42(R1),14          RESTORE?
         BE    HSMTODSK           YES.
         MVC   DGDSEUCV,98(R1)    LOAD SOURCE VOLUME.
         MVC   DGDSEVOL,88(R1)    LOAD TARGET VOLUME.
         MVC   DGDSETRK+2(2),172(R1)  GET THE NUMBER OF TRACKS READ.
         B     HSMTPCHK           GO CHECK FOR TAPE USAGE.
HSMTODSK MVC   DGDSEEOP,X'08'     INDICATE OUTPUT PROCESSING.
         MVC   DGDSEVOL,98(R1)    LOAD SOURCE VOLUME.
         MVC   DGDSEUCV,88(R1)    LOAD TARGET VOLUME.
         MVC   DGDSETRK+2(2),174(R1)  GET THE NUMBER OF TRACKS WRITTEN.
         TM    43(R1),X'20'       DATA SET BIGGER THAN 32K TRACKS?
         BNO   HSMTPCHK           NO.
         MVC   DGDSETRK,208(R1)   GET THE NUMBER OF TRACKS WRITTEN.
HSMTPCHK SLR   R0,R0              CLEAR FOR INSERT.
         ICM   R0,3,240(R1)       GET THE NUMBER OF TAPES USED.
         BZ    DSEFILLD           DATA COMPLETE IF ZERO.
         STH   R0,DGDSENUM        LOAD THE NUMBER OF VOLUMES.
         LA    R15,5              GET MAXIMUM THAT CAN BE HANDLED HERE.
         CR    R0,R15             IS THE COUNT OKAY?
         BNH   HSMTPSOK           YES.
         LR    R0,R15             NO, USE THE MAXIMUM.
HSMTPSOK LA    R15,DGDSEVOL       POINT TO TARGET AREA.
         LA    R14,300(,R1)       POINT TO SOURCE AREA.
HSMTPLP  MVC   0(6,R15),0(R14)    COPY VOLUME SERIAL NUMBER.
         LA    R15,6(,R15)        POINT TO NEXT TARGET AREA.
         LA    R14,8(,R14)        POINT TO NEXT SOURCE AREA.
         BCT   R0,HSMTPLP         PROCESS NEXT SLOT.
         SPACE
DSEFILLD LA    R0,DGDSNDSF        POINT TO DATA SET DSE TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R6,CHNENTRY        SUPPLY DSE ENTRY ADDRESS.
         LA    R0,DGDSEDSN-DGDSEVNT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGDSEDAT-DGDSEVNT
         ST    R0,CHNCMPOF        SUPPLY TIMESTAMP OFFSET.
         LA    R0,8
         ST    R0,CHNCMPLN        SUPPLY TIMESTAMP LENGTH.
         BAS   R14,CHAINADD       ADD DSE TO DSN DSE CHAIN.
         L     R2,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R2
         LA    R0,DGFSTDSE        POINT TO GLOBAL DSE TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         LA    R0,DGDSENXT-DGDSEVNT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         BAS   R14,CHAINADD       ADD DSE TO GLOBAL DSE CHAIN.
         ICM   R0,15,RENCOMMA     IN THE MIDDLE OF A RENAME?
         BNZ   DGDSTARG           YES, GO FINISH IT.
         B     GATMAIN            NO, RECORD PROCESSING NOW COMPLETE.
         DROP  R6,R3,R2,R1        DGDSEVNT, DGDATAST, DGBASE, SMFRECD.
         TITLE 'VARIABLES AND CONSTANTS'
RMFSAMCT DC    F'0'               RMF INTERVAL SAMPLE COUNT HOLD AREA.
RMFMAXTM DC    X'7FFFFFFF'        MAXIMUM TIME IN FULLWORD.
RENCOMMA DC    FL8'0'             RENAME COMMUNICATION AREA.
BLANKS   DC    CL8' '             EXTEND IF NECESSARY.
DGSTRING DC    CL32'IMON DATA GATHERER DATA &IMPDATE'
RMFSMFRL DC    FL1'0'             RMF SMF RECORD LEVEL.
HSMSEL   DC    X'00010003040506070809000B00000E00'
         SPACE
         LTORG
         SPACE
         DC    (((*-IMDATGAT-1)/256)*256+256+IMDATGAT-*)X'00'
         TITLE 'PROCESS SMF RECORD TYPE 30'
         USING DATGAT30,R9
         USING SMFRCD30,R1
DATGAT30 DS    0H
         CLC   =H'1',SMF30SON     ONE SUBSYSTEM SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30ION     ONE IDENTIFICATION SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30UON     ONE I/O ACTIVITY SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30TON     ONE COMPLETION SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30CON     ONE PROCESSOR SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30RON     ONE STORAGE SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         CLC   =H'1',SMF30PON     ONE PERFORMANCE SECTION PRESENT?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         ICM   R8,15,SMF30TOF     GET COMPLETION SECTION OFFSET.
         ALR   R8,R1              POINT TO THE COMPLETION SECTION.
         USING SMF30CMP,R8
         TM    SMF30STI,SMF30FLH  WAS THE STEP FLUSHED?
         BO    GATMAIN            YES, DISCARD THE RECORD.
         DROP  R8                 SMF30CMP.
         ICM   R8,15,SMF30SOF     GET SUBSYSTEM SECTION OFFSET.
         ALR   R8,R1              POINT TO THE SUBSYSTEM SECTION.
         USING SMF30PSS,R8
         CLC   =H'4',SMF30TYP     STEP TOTAL (SUBTYPE 4) RECORD?
         BNE   GATMAIN            NO, DISCARD THE RECORD.
         DROP  R8                 SMF30PSS.
         SPACE
         ICM   R8,15,SMF30IOF     GET IDENTIFICATION SECTION OFFSET.
         ALR   R8,R1              POINT TO THE IDENTIFICATION SECTION.
         USING SMF30ID,R8
         LA    R0,8               GET LENGTH OF JOB NAME MASK.
         LA    R2,SMF30JBN        POINT TO THE JOB NAME.
         LA    R3,TRACEJOB        POINT TO THE JOB NAME MASK.
         BAS   R14,MASKTEST       RECORD THIS EVENT?
         BNE   GATMAIN            NO, DISCARD THE DATA.
         SPACE
         LA    R0,DGJSELEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,10        SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R6,R0              POINT TO THE NEW ENTRY.
         USING DGJSEVNT,R6
         MVC   DGJSETIM,RECTIME   COPY SMF RECORD TIME.
         MVC   DGJSEDAT,SMF30DTE  COPY SMF RECORD DATE.
         MVC   DGJSESID,SMF30SID  COPY SMF SYSTEM IDENTIFIER.
         MVC   DGJSEWID,SMF30WID  COPY SMF SUBSYSTEM IDENTIFIER.
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         ICM   R5,15,SMF30SIT     LOAD STEP INITIATION TIME.
         BAS   R14,CENTITOD       CONVERT TO HOURS/MINUTES/SECONDS.
         ST    R2,DGJSESIT        SAVE STEP INITIATION TIME.
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         ZAP   WORK,SMF30DTE      GET THE STEP END DATE.
         SP    WORK,SMF30STD      GET THE DAYS DIFFERENCE IN DATES.
         CVB   R15,WORK           GET THIS DAY COUNT IN BINARY.
         CLC   SMF30DTE(2),SMF30STD   START AND END IN SAME YEAR?
         BE    ELYR30OK           YES.
         LA    R14,1000-365       NO, GET THE APPROPRIATE ADJUSTMENT.
         TM    SMF30STD+1,X'01'   IS THE START YEAR ODD?
         BO    ELLP30OK           YES, SO NOT A LEAP YEAR.
         TM    SMF30STD+1,X'12'   IS THE START YEAR A LEAP YEAR?
         BM    ELLP30OK           NO.
         BCTR  R14,0              YES, ADJUST THE ADJUSTMENT.
ELLP30OK SR    R15,R14            GET THE JOB STEP ELAPSED DAYS.
ELYR30OK M     R14,=F'8640000'    CONVERT DAYS TO CENTISECONDS.
         ICM   R14,15,SMF30TME    GET THE STEP END TIME OF DAY.
         ICM   R0,15,SMF30SIT     GET THE STEP START TIME OF DAY.
         SR    R14,R0             GET THE STEP ELAPSED TIME.
         AR    R15,R14            GET THE STEP CENTISECONDS DURATION.
         ST    R15,DGJSELAP       SAVE THE STEP ELAPSED TIME.
         MVC   DGJSESTD,SMF30STD  COPY STEP INITIATION DATE.
         MVC   DGJSEJOB,SMF30JBN  COPY JOB NAME.
         MVC   DGJSEJID,SMF30JNM  COPY JES JOB NUMBER.
         MVC   DGJSEUSR,SMF30UIF  COPY JMRUSEID.
         MVC   DGJSESTP,SMF30STM  COPY JOB STEP NAME.
         MVC   DGJSESTN,SMF30STN  COPY STEP NUMBER.
         MVC   DGJSECLS,SMF30CLS  COPY JES JOB CLASS.
         MVC   DGJSEPGN,SMF30PGN  COPY PERFORMANCE GROUP NUMBER.
         MVC   DGJSEUID,SMF30USR  COPY PROGRAMMER'S NAME.
         MVC   DGJSERUD,SMF30RUD  COPY RACF USER IDENTIFIER.
         MVC   DGJSEGRP,SMF30GRP  COPY RACF GROUP IDENTIFIER.
         MVC   DGJSEPGM,SMF30PGM  COPY PROGRAM NAME.
         MVC   DGJSEPSN+1(6),=C'(UNKN)'
         CLC   =H'140',SMF30ILN   IS THE PROC STEP NAME PRESENT?
         BH    IDNT30OK           NO, IDENTIFICATION SECTION TOO SHORT.
         MVC   DGJSEPSN,SMF30PSN  COPY PROCEDURE STEP NAME.
IDNT30OK DS    0H
         DROP  R8                 SMF30ID.
         ICM   R8,15,SMF30UOF     GET I/O ACTIVITY SECTION OFFSET.
         ALR   R8,R1              POINT TO THE I/O ACTIVITY SECTION.
         USING SMF30URA,R8
         MVC   DGJSETEP,SMF30TEP  COPY EXCP COUNT.
         MVC   DGJSETPT,SMF30TPT  COPY TPUT COUNT.
         MVC   DGJSETGT,SMF30TGT  COPY TGET COUNT.
         TM    SMF30FLG,X'06'     MVS/XA OR LATER?
         BNO   CNCT30OK           NO.
         MVC   DGJSETCN,SMF30TCN  YES, COPY CHANNEL CONNECT TIME.
CNCT30OK DS    0H
         DROP  R8                 SMF30URA.
         ICM   R8,15,SMF30TOF     GET COMPLETION SECTION OFFSET.
         ALR   R8,R1              POINT TO THE COMPLETION SECTION.
         USING SMF30CMP,R8
         MVC   DGJSECMP,SMF30SCC  COPY THE STEP COMPLETION CODE.
         TM    SMF30SCC,X'80'     USER ABEND?
         BO    COMP30OK           YES.
         TM    SMF30STI,SMF30ABD  SYSTEM ABEND?
         BZ    COMP30OK           NO.
         OI    DGJSECMP,X'C0'     YES, INDICATE THIS.
COMP30OK DS    0H
         DROP  R8                 SMF30CMP.
         ICM   R8,15,SMF30COF     GET PROCESSOR SECTION OFFSET.
         ALR   R8,R1              POINT TO THE PROCESSOR SECTION.
         USING SMF30CAS,R8
         MVC   DGJSEPTY,SMF30PTY  COPY DISPATCHING PRIORITY.
         MVC   DGJSECPT,SMF30CPT  COPY PROBLEM PROGRAM CPU TCB TIME.
         MVC   DGJSECPS,SMF30CPS  COPY PROBLEM PROGRAM CPU SRB TIME.
         MVC   DGJSEICU,SMF30ICU  COPY INITIATOR CPU TCB TIME.
         MVC   DGJSEISB,SMF30ISB  COPY INITIATOR CPU SRB TIME.
         TM    SMF30FLG,X'DE'     MVS/SP4 SMF RECORD?
         BNO   PROC30OK           NO, OTHER CPU TIMES NOT AVAILABLE.
         MVC   DGJSEIIP,SMF30IIP  COPY I/O INTERRUPT CPU TIME.
         MVC   DGJSERCT,SMF30RCT  COPY REGION CONTROL TASK CPU TIME.
         MVC   DGJSEHPT,SMF30HPT  COPY HIPERSPACE TRANSFER CPU TIME.
PROC30OK DS    0H
         DROP  R8                 SMF30CAS.
         ICM   R8,15,SMF30ROF     GET STORAGE SECTION OFFSET.
         ALR   R8,R1              POINT TO THE STORAGE SECTION.
         USING SMF30SAP,R8
         MVC   DGJSESPK,SMF30SPK  COPY STORAGE PROTECT KEY.
         MVC   DGJSEPRI,SMF30PRV  COPY REGION HIGH-WATER-MARK.
         MVC   DGJSESYS,SMF30SYS  COPY LSQA HIGH-WATER-MARK.
         MVC   DGJSEEUR,SMF30EUR  COPY EXTENDED REGION HIGH-WATER-MARK.
         MVC   DGJSEEAR,SMF30EAR  COPY ELSQA HIGH-WATER-MARK.
         MVC   DGJSEPGI,SMF30PGI  COPY PAGE-IN COUNT.
         MVC   DGJSEPGO,SMF30PGO  COPY PAGE-OUT COUNT.
         MVC   DGJSEPSI,SMF30PSI  COPY SWAP PAGE-IN COUNT.
         MVC   DGJSEPSO,SMF30PSO  COPY SWAP PAGE-OUT COUNT.
         MVC   DGJSEVPI,SMF30VPI  COPY VIO PAGE-IN COUNT.
         MVC   DGJSEVPO,SMF30VPO  COPY VIO PAGE-OUT COUNT.
         MVC   DGJSEVPR,SMF30VPR  COPY VIO RECLAIM COUNT.
         MVC   DGJSECPI,SMF30CPI  COPY COMMON PAGE-IN COUNT.
         MVC   DGJSERGN+2(2),SMF30RSV  COPY OLD REGION FIELD.
         LA    R0,SMF30RGN-SMF30SAP+4
         CLM   R0,3,SMF30RLN      SECTION LONG ENOUGH FOR NEW FIELD?
         BH    STOR30OK           NO.
         MVC   DGJSERGN,SMF30RGN  COPY REQUESTED REGION SIZE.
         TM    SMF30FLG,X'CE'     MVS/ESA SMF RECORD?
         BNO   STOR30OK           NO, NO SUCH THING AS A DATA SPACE.
         MVC   DGJSEDSV,SMF30DSV  COPY DATA SPACE HIGH-WATER-MARK.
STOR30OK DS    0H
         DROP  R8                 SMF30SAP.
         ICM   R8,15,SMF30POF     GET PERFORMANCE SECTION OFFSET.
         ALR   R8,R1              POINT TO THE PERFORMANCE SECTION.
         USING SMF30PRF,R8
         MVC   DGJSESRV,SMF30SRV  COPY TOTAL SERVICE.
         MVC   DGJSECSU,SMF30CSU  COPY CPU SERVICE.
         MVC   DGJSESRB,SMF30SRB  COPY SRB SERVICE.
         MVC   DGJSEIOS,SMF30IO   COPY IOS SERVICE.
         MVC   DGJSEMSO,SMF30MSO  COPY MSO SERVICE.
         MVC   DGJSETRS,SMF30TRS  COPY SRM TRANSACTION COUNT.
         DROP  R8                 SMF30PRF.
         ICM   R8,3,SMF30OON      ANY OPERATOR SECTION PRESENT?
         BZ    OPER30OK           NO.
         ICM   R8,15,SMF30OOF     YES, GET OPERATOR SECTION OFFSET.
         ALR   R8,R1              POINT TO THE OPERATOR SECTION.
         USING SMF30OPS,R8
         L     R15,SMF30PDM       GET NON-SPECIFIC DASD MOUNT COUNT.
         A     R15,SMF30PRD       ADD SPECIFIC DASD MOUNT COUNT.
         A     R15,SMF30PTM       ADD NON-SPECIFIC TAPE MOUNT COUNT.
         A     R15,SMF30TPR       ADD SPECIFIC TAPE MOUNT COUNT.
         ST    R15,DGJSEVOL       SAVE TOTAL VOLUME MOUNT COUNT.
         DROP  R8                 SMF30OPS.
OPER30OK DS    0H
         SPACE
         L     R2,DGBASEAD        POINT TO THE BASE ENTRY.
         USING DGBASE,R2
         LA    R0,DGFSTJSE        POINT TO GLOBAL JSE TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R6,CHNENTRY        SUPPLY JSE ENTRY ADDRESS.
         LA    R0,DGJSENXT-DGJSEVNT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGJSEDAT-DGJSEVNT
         ST    R0,CHNCMPOF        SUPPLY TIMESTAMP OFFSET.
         LA    R0,8
         ST    R0,CHNCMPLN        SUPPLY TIMESTAMP LENGTH.
         BAS   R14,CHAINADD       ADD JSE TO GLOBAL JSE CHAIN.
         SPACE
         LA    R3,DGFSTPGM        POINT TO THE FIRST PGM ENTRY POINTER.
DGPROGLP LR    R5,R3              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R3,15,0(R3)        POINT TO THE FIRST PROGRAM ENTRY.
         BZ    MKNEWPGM           NO MORE PROGRAM ENTRIES SO MAKE ONE.
         USING DGPROGRM,R3
         CLC   DGPGMNAM,DGJSEPGM  FOUND THE MATCHING PROGRAM ENTRY?
         BE    PGMMATCH           YES.
         BL    DGPROGLP           NO, TRY THE NEXT ONE.
*        BH    MKNEWPGM           PAST WHERE IT SHOULD BE SO MAKE IT.
         SPACE
MKNEWPGM LA    R0,DGPGMLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,9         SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R3,R0              POINT TO THE NEW ENTRY.
         MVC   DGPGMNAM,DGJSEPGM  LOAD THE PROGRAM NAME.
         OI    DGPGMXCP+7,X'0C'   INITIALIZE DECIMAL COUNTER.
         OI    DGPGMSRV+7,X'0C'   INITIALIZE DECIMAL COUNTER.
         ICM   R4,15,0(R5)        ENCOUNTERED END OF CHAIN?
         BZ    LASTPGM            YES, ADD NEW LAST ENTRY.
         ST    R4,DGPGMNXT        NO, POINT FORWARD TO NEXT ENTRY.
         ST    R3,4(,R4)          POINT BACKWARD TO THIS ENTRY.
         B     CHAINPGM           CONTINUE WITH CHAIN UPDATE.
LASTPGM  ST    R3,DGLSTPGM        NEW ONE IS NOW THE LAST ONE.
CHAINPGM LA    R0,DGFSTPGM        POINT TO THE FIRST PGM ENTRY POINTER.
         CR    R5,R0              IS THIS THE FIRST PROGRAM ENTRY?
         BE    FIRSTPGM           YES.
         ST    R3,0(,R5)          NO, POINT FORWARD TO THIS ENTRY.
         ST    R5,DGPGMPRV        POINT BACK TO PREVIOUS ENTRY.
         B     COUNTPGM           GO INCREMENT THE PGM ENTRY COUNT.
FIRSTPGM ST    R3,DGFSTPGM        THIS IS THE FIRST PROGRAM ENTRY.
COUNTPGM LA    R0,1
         A     R0,DGNUMPGM        INCREMENT THE PROGRAM ENTRY COUNTER.
         ST    R0,DGNUMPGM
         SPACE
PGMMATCH ST    R3,DGJSEPGA        POINT TO OWNING PROGRAM ENTRY.
         LA    R0,DGPGMJSF        POINT TO PROGRAM JSE TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R6,CHNENTRY        SUPPLY JSE ENTRY ADDRESS.
         LA    R0,DGJSEPRN-DGJSEVNT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGJSEDAT-DGJSEVNT
         ST    R0,CHNCMPOF        SUPPLY TIMESTAMP OFFSET.
         LA    R0,8
         ST    R0,CHNCMPLN        SUPPLY TIMESTAMP LENGTH.
         BAS   R14,CHAINADD       ADD JSE TO PROGRAM JSE CHAIN.
         L     R0,DGJSECPT        GET PROGRAM STEP TCB TIME.
         A     R0,DGJSECPS        ADD PROGRAM STEP SRB TIME.
         A     R0,DGPGMCPU        ADD PREVIOUS PROGRAM CPU TIME.
         ST    R0,DGPGMCPU        SAVE NEW PROGRAM CPU TIME TOTAL.
         L     R0,DGJSETEP        GET PROGRAM STEP EXCP COUNT.
         CVD   R0,WORK            CONVERT TO PACKED DECIMAL.
         AP    DGPGMXCP,WORK      GET NEW PROGRAM EXCP TOTAL.
         L     R0,DGJSESRV        GET PROGRAM STEP TOTAL SERVICE.
         CVD   R0,WORK            CONVERT TO PACKED DECIMAL.
         AP    DGPGMSRV,WORK      GET NEW PROGRAM SERVICE TOTAL.
         DROP  R3                 DGPROGRM.
         SPACE
         LA    R3,DGFSTJOB        POINT TO THE FIRST JOB ENTRY POINTER.
DGJBNMLP LR    R5,R3              REMEMBER PREVIOUS POINTER VALUE.
         ICM   R3,15,0(R3)        POINT TO THE FIRST JOB ENTRY.
         BZ    MKNEWJOB           NO MORE JOB ENTRIES SO MAKE ONE.
         USING DGJOB,R3
         CLC   DGJOBNAM,DGJSEJOB  FOUND THE MATCHING JOB ENTRY?
         BE    JOBMATCH           YES.
         BL    DGJBNMLP           NO, TRY THE NEXT ONE.
*        BH    MKNEWJOB           PAST WHERE IT SHOULD BE SO MAKE IT.
         SPACE
MKNEWJOB LA    R0,DGJOBLEN        GET THE SIZE OF THE DESIRED ENTRY.
         MVI   ENTRYTYP,13        SET STORAGE ENTRY TYPE CODE.
         BAS   R14,DGNEWENT       GET THE NEW ENTRY.
         LR    R3,R0              POINT TO THE NEW ENTRY.
         MVC   DGJOBNAM,DGJSEJOB  LOAD THE JOB NAME.
         OI    DGJOBXCP+7,X'0C'   INITIALIZE DECIMAL COUNTER.
         OI    DGJOBSRV+7,X'0C'   INITIALIZE DECIMAL COUNTER.
         ICM   R4,15,0(R5)        ENCOUNTERED END OF CHAIN?
         BZ    LASTJOB            YES, ADD NEW LAST ENTRY.
         ST    R4,DGJOBNXT        NO, POINT FORWARD TO NEXT ENTRY.
         ST    R3,4(,R4)          POINT BACKWARD TO THIS ENTRY.
         B     CHAINJOB           CONTINUE WITH CHAIN UPDATE.
LASTJOB  ST    R3,DGLSTJOB        NEW ONE IS NOW THE LAST ONE.
CHAINJOB LA    R0,DGFSTJOB        POINT TO THE FIRST JOB ENTRY POINTER.
         CR    R5,R0              IS THIS THE FIRST JOB ENTRY?
         BE    FIRSTJOB           YES.
         ST    R3,0(,R5)          NO, POINT FORWARD TO THIS ENTRY.
         ST    R5,DGJOBPRV        POINT BACK TO PREVIOUS ENTRY.
         B     COUNTJOB           GO INCREMENT THE JOB ENTRY COUNT.
FIRSTJOB ST    R3,DGFSTJOB        THIS IS THE FIRST JOB ENTRY.
COUNTJOB LA    R0,1
         A     R0,DGNUMJOB        INCREMENT THE JOB ENTRY COUNTER.
         ST    R0,DGNUMJOB
         DROP  R2                 DGBASE.
         SPACE
JOBMATCH ST    R3,DGJSEJBA        POINT TO OWNING JOB ENTRY.
         LA    R0,DGJOBJSF        POINT TO PROGRAM JSE TRIPLET.
         ST    R0,CHNTRIPL        SUPPLY ITS ADDRESS IN PARAMETERS.
         ST    R6,CHNENTRY        SUPPLY JSE ENTRY ADDRESS.
         LA    R0,DGJSEJBN-DGJSEVNT
         ST    R0,CHNPTROF        SUPPLY CHAIN POINTERS OFFSET.
         LA    R0,DGJSEDAT-DGJSEVNT
         ST    R0,CHNCMPOF        SUPPLY TIMESTAMP OFFSET.
         LA    R0,8
         ST    R0,CHNCMPLN        SUPPLY TIMESTAMP LENGTH.
         BAS   R14,CHAINADD       ADD JSE TO JOB JSE CHAIN.
         L     R0,DGJSECPT        GET JOB STEP TCB TIME.
         A     R0,DGJSECPS        ADD JOB STEP SRB TIME.
         A     R0,DGJOBCPU        ADD PREVIOUS JOB CPU TIME.
         ST    R0,DGJOBCPU        SAVE NEW JOB CPU TIME TOTAL.
         L     R0,DGJSETEP        GET JOB STEP EXCP COUNT.
         CVD   R0,WORK            CONVERT TO PACKED DECIMAL.
         AP    DGJOBXCP,WORK      GET NEW JOB EXCP TOTAL.
         L     R0,DGJSESRV        GET JOB STEP TOTAL SERVICE.
         CVD   R0,WORK            CONVERT TO PACKED DECIMAL.
         AP    DGJOBSRV,WORK      GET NEW JOB SERVICE TOTAL.
         B     GATMAIN            RECORD PROCESSING NOW COMPLETE.
         DROP  R6,R3,R1           DGJSEVNT, DGJOB, SMFRCD30.
         DROP  R9                 DATGAT30.
         TITLE 'VARIABLES AND CONSTANTS  (TYPE 30 ROUTINE)'
         LTORG
         SPACE
         DC    (((*-IMDATGAT-1)/256)*256+256+IMDATGAT-*)X'00'
         TITLE 'GENERAL INITIALIZATION ROUTINE'
IMDGINIT DS    0D
         STM   R14,R12,12(R13)    SAVE REGISTERS.
         LR    R9,R15             COPY BASE REGISTER.
         USING IMDGINIT,R9
         MVI   GATFLAGS,0         RESET ALL STATUS FLAGS.
         MVI   SELFLAGS,SELINIT   INITIALIZE SELECTION FLAGS.
         L     R15,CVTPTR(,0)     POINT TO THE CVT.
         USING CVT,R15            COMMUNICATION VECTOR TABLE.
         MVC   OSBITS,CVTDCB      COPY THE OS FLAGS.
         XC    OSLVL,OSLVL        CLEAR ESA FEATURE FLAGS.
         TM    OSBITS,X'9B'       MVS/ESA?
         BNO   GOTOSLVL           NO.
         MVC   OSLVL,CVTOSLVL     YES, COPY MVS/ESA FEATURE FLAGS.
         TM    CVTOSLV1,CVTH6603  OS/390 1.3OR LATER?
         BNO   GOTOSLVL           NO.
         OI    GATGETAD,X'80'     YES, RUN IMGATGET IN AMODE 31.
GOTOSLVL DS    0H
         DROP  R15                CVT.
         MVI   HSMFNTYP,0         RESET HSM FUNCTION SMF RECORD TYPE.
         L     R2,0(,R1)          POINT TO PROGRAM PARAMETER.
         EXTRACT MF=(E,EXTRACTL)  GET ADDRESS OF TSO FLAG.
         MVC   COMMADDR,EXTRFLDS  COPY COMMUNICATION LIST ADDRESS.
         L     R1,EXTRFLDS+4      POINT TO TSU FLAG BYTE.
         TM    0(R1),X'80'        TIME SHARING USER ADDRESS SPACE?
         BZ    TSUKNOWN           NO.
         OI    GATFLAGS,TSU       YES.
         NI    GATGETAD,X'7F'     RUN IMGATGET IN AMODE 24.
TSUKNOWN LA    R1,0(,R2)          ENSURE ADDRESS FORMAT.
         LTR   R1,R1              ANY PARAMETER ADDRESS?
         BNP   PARMDONE           NO.
         CLI   0(R1),0            PARAMETER LESS THAN 256 BYTES?
         BNE   PARMDONE           NO, IGNORE IT.
         CLI   1(R1),0            ANY PARAMETER AT ALL?
         BE    PARMDONE           NO, IGNORE IT.
         LH    R4,0(,R1)          GET THE PARAMETER LENGTH.
         LA    R3,2(,R1)          POINT TO START OF PARAMETER TEXT.
NEWKEYWD LR    R5,R3              POINT TO START OF POSSIBLE KEYWORD.
         CLI   0(R3),C','         COMMA?
         BE    XTRADLIM           YES.
         CLI   0(R3),C' '         BLANK?
         BNE   PKWCHKLP           NO.
XTRADLIM LA    R3,1(,R3)          YES, IGNORE IT.
         BCT   R4,NEWKEYWD        LOOK AT THE NEXT CHARACTER.
         B     PARMDONE           END OF PARAMETER.
PKWCHKLP CLI   0(R3),C'='         EQUALS SIGN?
         BE    KWCHECK            YES, SEE WHICH KEYWORD WAS SPECIFIED.
         CLI   0(R3),C','         COMMA?
         BE    PREMDLIM           YES, NO ASSIGNMENT VALUE SUPPLIED.
         CLI   0(R3),C' '         BLANK?
         BE    PREMDLIM           YES, NO ASSIGNMENT VALUE SUPPLIED.
         LA    R3,1(,R3)          NO, POINT TO THE NEXT BYTE.
         BCT   R4,PKWCHKLP        LOOK AT THE NEXT CHARACTER.
         B     PARMDONE           END OF PARAMETER.
PREMDLIM LR    R6,R3              POINT TO THE DELIMITER.
         SR    R6,R5              GET THE KEYWORD LENGTH.
         BNP   COMMASCN           HANDLE OMITTED KEYWORD.
         LA    R0,KWTELEN-8       GET MAXIMUM KEYWORD LENGTH.
         CR    R6,R0              IS THE KEYWORD TOO LONG?
         BNH   PREKLNOK           NO.
         LR    R6,R0              YES, USE THE MAXIMUM LENGTH.
PREKLNOK BCTR  R6,0               DECREMENT FOR EXECUTE.
         EX    R6,LOADPREM        SHOW THE IGNORED KEYWORD.
         LA    R1,GATWTO04        ISSUE "PREMATURE DELIMITER" MESSAGE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         LA    R3,1(,R3)          POINT PAST THE DELIMITER.
         BCT   R4,COMMASCN        LOOK FOR NEXT KEYWORD.
         B     PARMDONE           END OF PARAMETER.
LOADPREM MVC   KEYWORD4(0),0(R5)  <<< EXECUTED >>>
NOKEYWD  LA    R1,GATWTO04        ISSUE "MISSING KEYWORD" MESSAGE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         B     COMMASCN
KWCHECK  LR    R6,R3              POINT TO EQUALS SIGN.
         SR    R6,R5              GET THE KEYWORD LENGTH.
         BNP   NOKEYWD            HANDLE MISSING KEYWORD.
         BCTR  R6,0               DECREMENT FOR EXECUTE.
         LA    R7,KEYWDTAB        POINT TO THE KEYWORD TABLE.
KWDSCNLP CLI   0(R7),X'FF'        END OF TABLE?
         BE    BADKEYWD           YES, UNKNOWN KEYWORD.
         C     R6,0(,R7)          IS THE KEYWORD THE CORRECT LENGTH?
         BNE   NXTKEYWD           NO.
         EX    R6,KEYWDCMP        YES, IS IT THIS KEYWORD?
         BE    GOTKEYWD           YES, GO PROCESS IT.
NXTKEYWD LA    R7,KWTELEN(,R7)    POINT TO THE NEXT TABLE ENTRY.
         B     KWDSCNLP           CONTINUE KEYWORD TABLE SCAN.
KEYWDCMP CLC   8(0,R7),0(R5)      <<< EXECUTED >>>
BADKEYWD LA    R0,KWTELEN-9       GET MAXIMUM KEYWORD LENGTH.
         CR    R6,R0              IS THE KEYWORD TOO LONG?
         BNH   BADKLNOK           NO.
         LR    R6,R0              YES, USE THE MAXIMUM LENGTH.
BADKLNOK EX    R6,LOADBDWD        SHOW THE IGNORED KEYWORD.
         LA    R1,GATWTO03        ISSUE "UNKNOWN KEYWORD" MESSAGE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
COMMASCN CLI   0(R3),C','         COMMA?
         BE    VALUEEND           END OF THE ASSIGNED VALUE.
         CLI   0(R3),C' '         BLANK?
         BE    VALUEEND           END OF THE ASSIGNED VALUE.
         LA    R3,1(,R3)          NO, POINT TO THE NEXT BYTE.
         BCT   R4,COMMASCN        LOOK AT THE NEXT CHARACTER.
         B     PARMDONE           END OF PARAMETER.
VALUEEND LA    R3,1(,R3)          POINT PAST THE COMMA.
         BCT   R4,NEWKEYWD        PROCESS THE NEW KEYWORD.
         B     PARMDONE           END OF PARAMETER.
LOADBDWD MVC   KEYWORD3(0),0(R5)  <<< EXECUTED >>>
GOTKEYWD LA    R3,1(,R3)          POINT PAST THE EQUALS SIGN.
         BCT   R4,GETVALUE        LOOK AT THE NEXT CHARACTER.
         B     PARMDONE           NO VALUE SPECIFIED, END OF PARAMETER.
GETVALUE CLI   0(R3),C','         COMMA?
         BE    VALUEEND           YES, NO VALUE SPECIFIED.
         CLI   0(R3),C' '         BLANK?
         BE    VALUEEND           END OF THE ASSIGNED VALUE.
         L     R15,4(,R7)         LOAD THE APPROPRIATE BRANCH ADDRESS.
         BR    R15                GO BRANCH THERE.
KDATASET CLI   0(R3),C'N'         IS 'NO' REQUESTED?
         BNE   COMMASCN           NO, 'YES' IS ALREADY SET.
         MVI   ODATASET,C'N'      YES, SET 'NO'.
         NI    SELFLAGS,255-DSET
         B     COMMASCN
KPERFORM CLI   0(R3),C'N'         IS 'NO' REQUESTED?
         BNE   COMMASCN           NO, 'YES' IS ALREADY SET.
         MVI   OPERFORM,C'N'      YES, SET 'NO'.
         NI    SELFLAGS,255-PERF
         B     COMMASCN
KJOBSTEP CLI   0(R3),C'N'         IS 'NO' REQUESTED?
         BNE   COMMASCN           NO, 'YES' IS ALREADY SET.
         MVI   OJOBSTEP,C'N'      YES, SET 'NO'.
         NI    SELFLAGS,255-PGMS
         B     COMMASCN
*TAPEVOL CLI   0(R3),C'N'         IS 'NO' REQUESTED?
*        BNE   COMMASCN           NO, 'YES' IS ALREADY SET.
*        MVI   OTAPEVOL,C'N'      YES, SET 'NO'.
*        NI    SELFLAGS,255-TAPE
*        B     COMMASCN
*DASDVOL CLI   0(R3),C'N'         IS 'NO' REQUESTED?
*        BNE   COMMASCN           NO, 'YES' IS ALREADY SET.
*        MVI   ODASDVOL,C'N'      YES, SET 'NO'.
*        NI    SELFLAGS,255-DASD
*        B     COMMASCN
KTAPEJOB LA    R0,8               GET MAXIMUM JOB NAME LENGTH.
         LA    R15,OTAPEJOB       POINT TO TARGET.
KTPJOBLP CLI   0(R3),C','         DELIMITER?
         BE    VALUEEND           YES.
         CLI   0(R3),C' '         DELIMITER?
         BE    VALUEEND           YES.
         MVC   0(1,R15),0(R3)     NO, COPY BYTE.
         LA    R3,1(,R3)          NO, POINT TO THE NEXT BYTE.
         LA    R15,1(,R15)        POINT TO THE NEXT TARGET BYTE.
         BCTR  R4,0               DECREMENT PARAMETER LENGTH.
         LTR   R4,R4              END OF PARAMETER?
         BNP   PARMDONE           YES.
         BCT   R0,KTPJOBLP        LOOK AT THE NEXT CHARACTER.
         B     COMMASCN           TRUNCATE THE JOB NAME TO 8 BYTES.
KDASDJOB LA    R0,8               GET MAXIMUM JOB NAME LENGTH.
         LA    R15,ODASDJOB       POINT TO TARGET.
         B     KTPJOBLP           BRANCH TO COMMON CODE.
KTRACJOB LA    R0,8               GET MAXIMUM JOB NAME LENGTH.
         LA    R15,OTRACJOB       POINT TO TARGET.
         B     KTPJOBLP           BRANCH TO COMMON CODE.
         SPACE
PARMDONE MVC   DASDJOB,ODASDJOB   SHOW "DASD" JOB NAME MASK.
         MVC   TAPEJOB,OTAPEJOB   SHOW "TAPE" JOB NAME MASK.
         MVC   TRACEJOB,OTRACJOB  SHOW "TRACE" JOB NAME MASK.
         LA    R1,GATWTO06        DISPLAY OPTIONS IN USE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         LA    R1,GATWTO07        DISPLAY OPTIONS IN USE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         TM    SELFLAGS,SELANY    SELECTING ANYTHING?
         BNZ   SELNOKAY           YES.
         LA    R1,GATWTO08        NO, DISPLAY WARNING MESSAGE.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
SELNOKAY DS    0H
         LM    R14,R12,12(R13)    RESTORE REGISTERS.
         SLR   R15,R15            SET ZERO RETURN CODE.
         BR    R14                RETURN TO CALLER.
         SPACE
         DROP  R9                 IMDGINIT.
         TITLE 'VARIABLES AND CONSTANTS'
EXTRACTL EXTRACT EXTRFLDS,'S',FIELDS=(COMM,TSO),MF=L
EXTRFLDS DC    2A(0)              ADDRESS OF EXTRACTED FIELDS.
KEYWDTAB DS    0F                 PARAMETER KEYWORD TABLE.
         DC    F'6',A(KDATASET),CL8'DATASET ' DATA SET EVENTS.
         DC    F'3',A(KDATASET),CL8'DSET    ' DATA SET EVENTS.
         DC    F'6',A(KPERFORM),CL8'PERFORM ' RMF/PDLF DATA.
         DC    F'3',A(KPERFORM),CL8'PERF    ' RMF/PDLF DATA.
         DC    F'6',A(KJOBSTEP),CL8'JOBSTEP ' JOB STEP TERMINATIONS.
         DC    F'3',A(KJOBSTEP),CL8'STEP    ' JOB STEP TERMINATIONS.
*        DC    F'6',A(KTAPEVOL),CL8'TAPEVOL ' TAPE VOLUME DISMOUNTS.
*        DC    F'3',A(KTAPEVOL),CL8'TAPE    ' TAPE VOLUME DISMOUNTS.
*        DC    F'6',A(KDASDVOL),CL8'DASDVOL ' DASD SPACE STATISTICS.
*        DC    F'3',A(KDASDVOL),CL8'DASD    ' DASD SPACE STATISTICS.
         DC    F'6',A(KTAPEJOB),CL8'TAPEJOB ' NO TAPE 14/15 EVENTS.
         DC    F'6',A(KDASDJOB),CL8'DASDJOB ' NO DASD 14/15/17/18.
         DC    F'7',A(KTRACJOB),CL8'TRACEJOB' ONLY EVENTS FOR THIS JOB.
         DC    F'-1'              END OF TABLE.
KWTELEN  EQU   16                 LENGTH OF A SINGLE TABLE ENTRY.
         SPACE
GATWTO03 WTO   'PRY633I  IMPGAT IGNORING UNKNOWN KEYWORD:         ',   +
               ROUTCDE=(2,11),MF=L
KEYWORD3 EQU   GATWTO03+46,8
GATWTO04 WTO   'PRY634I  PREMATURE DELIMITER SO IGNORING KEYWORD:      +
                  ',ROUTCDE=(2,11),MF=L
KEYWORD4 EQU   GATWTO04+54,8
GATWTO05 WTO   'PRY635I  NO KEYWORD FOUND BEFORE EQUALS SIGN',         +
               ROUTCDE=(2,11),MF=L
GATWTO06 WTO   'PRY636I  USING OPTIONS: PERFORM=Y DATASET=Y JOBSTEP=Y',+
               ROUTCDE=(2,11),MF=L
GATWTO07 WTO   'PRY637I  USING OPTIONS: TAPEJOB=         DASDJOB=      +
                  TRACEJOB=********',                                  +
               ROUTCDE=(2,11),MF=L
GATWTO08 WTO   'PRY638W  WARNING: IMPGAT WILL NOT SELECT ANY DATA',    +
               ROUTCDE=(2,11),MF=L
OPERFORM EQU   GATWTO06+36,1
ODATASET EQU   GATWTO06+46,1
OJOBSTEP EQU   GATWTO06+56,1
OTAPEJOB EQU   GATWTO07+36,8
ODASDJOB EQU   GATWTO07+53,8
OTRACJOB EQU   GATWTO07+71,8
         SPACE 2
         LTORG
         SPACE
         DC    (((*-IMDATGAT-1)/256)*256+256+IMDATGAT-*)X'00'
         TITLE 'ABEND HANDLING ROUTINE'
GATRETRY DS    0D
         USING GATRETRY,R9
         L     R9,RETRYADR        INITIALIZE BASE REGISTER.
         MVC   RETABCDE,ABENDCDE  LOAD ABEND CODE INTO MESSAGE.
         UNPK  RETYYYY,10(3,R1)   LOAD YEAR INTO MESSAGE.
         TR    RETYYYY(4),ABENDHEX-C'0'
         MVI   RETYYYY+4,C'.'
         UNPK  RETDDD,12(2,R1)    LOAD JULIAN DAY INTO MESSAGE.
         TR    RETDDD,ABENDHEX-C'0'
         ICM   R7,15,6(R1)        GET THE TIME OF DAY.
         SLR   R6,R6              CLEAR FOR DIVIDE.
         D     R6,=F'360000'      GET THE HOURS.
         LA    R15,RETHH          POINT TO OUTPUT FIELD.
         BAS   R14,RETIMSG        CALL FORMATTING ROUTINE.
         LR    R7,R6              USE THE REMAINDER.
         SLR   R6,R6              CLEAR FOR DIVIDE.
         D     R6,=F'6000'        GET THE MINUTES.
         LA    R15,RETMM          POINT TO OUTPUT FIELD.
         BAS   R14,RETIMSG        CALL FORMATTING ROUTINE.
         LR    R7,R6              USE THE REMAINDER.
         SLR   R6,R6              CLEAR FOR DIVIDE.
         D     R6,=F'100'         GET THE SECONDS.
         LA    R15,RETSS          POINT TO OUTPUT FIELD.
         BAS   R14,RETIMSG        CALL FORMATTING ROUTINE.
         LR    R7,R6              GET THE CENTISECONDS.
         LA    R15,RETTH          POINT TO OUTPUT FIELD.
         BAS   R14,RETIMSG        CALL FORMATTING ROUTINE.
         SLR   R0,R0              CLEAR FOR INSERT.
         IC    R0,5(,R1)          GET THE SMF RECORD TYPE.
         CVD   R0,WORK
         OI    WORK+7,X'0F'
         UNPK  RETTYPE,WORK+6(2)  LOAD SMF RECORD TYPE INTO MESSAGE.
         MVC   RETSID,14(R1)      LOAD SYSTEM IDENTIFIER INTO MESSAGE.
         LA    R1,GATWTO13        ISSUE NOTIFICATION OF IMPGAT START.
         BAS   R14,DGPUTMSG       CALL MESSAGE ISSUING ROUTINE.
         B     GATMAIN            RETURN TO MAIN PROCESSING LOOP.
         SPACE
RETIMSG  DS    0H                 PUT TIME COMPONENT INTO MESSAGE.
         CVD   R7,WORK
         OI    WORK+7,X'0F'
         UNPK  0(2,R15),WORK+6(2)
         BR    R14
         SPACE
         DROP  R12,R11,R10,R9     IMDATGAT, GATRETRY.
         SPACE 2
GATWTO13 WTO   'PRY613I  ABEND S___-____ PROCESSING RECORD YYYY.DDD HH:+
               MM:SS.TH TYPE ### FROM SYSTEM ____',ROUTCDE=(2,11),MF=L
RETABCDE EQU   GATWTO13+20,8
RETYYYY  EQU   GATWTO13+47,5
RETDDD   EQU   GATWTO13+52,3
RETHH    EQU   GATWTO13+56,2
RETMM    EQU   GATWTO13+59,2
RETSS    EQU   GATWTO13+62,2
RETTH    EQU   GATWTO13+65,2
RETTYPE  EQU   GATWTO13+73,3
RETSID   EQU   GATWTO13+89,4
         SPACE
         LTORG
         SPACE
         DC    (((*-IMDATGAT-1)/256)*256+256+IMDATGAT-*)X'00'
         TITLE 'IMP DATA GATHERER ABNORMAL END EXIT'
         USING GATABEND,R15
GATABEND DS    0D
         CH    R0,TWELVE        ENTRY CODE 12?
         BE    ENTRY12          YES, ISSUE MESSAGE AND PERCOLATE ABEND.
         SPACE
         STM   R14,R12,12(R13)  NO, SAVE REGISTERS IN SUPPLIED AREA.
         DROP  R15              GATABEND.
         USING GATABEND,R10
         LR    R10,R15          LOAD EXIT BASE REGISTER.
         USING SDWA,R3
         LR    R3,R1            POINT TO SYSTEM DIAGNOSTIC WORK AREA.
         UNPK  ABENDCDE,SDWACMPC(2)
         OI    ABENDCDE+2,X'F0' DISPLAY THE ABEND CODE.
         TR    ABENDCDE,ABENDHEX-C'0'
         UNPK  ABENDINT(5),SDWAINC1(3)
         CLI   SDWACMPC,X'0C'   ABEND S0CX?
         BE    GOTINTCD         YES, INTERRUPT CODE IS RELEVANT.
         CLI   SDWACMPC,X'0D'   ABEND S0DX?
         BE    GOTINTCD         YES, INTERRUPT CODE IS RELEVANT.
         UNPK  ABENDINT(5),SDWASR15+2(3)
GOTINTCD TR    ABENDINT,ABENDHEX-C'0'
         MVI   ABENDINT+4,C'P'  RESTORE NEXT MESSAGE'S MSGID.
         LA    R1,ABENDMS1
         LA    R0,ABENDLN1
         TPUT  (1),(0),R        DISPLAY ABEND CODE DETAILS.
         UNPK  ABENDPSW(9),SDWAEC1(5)
         TR    ABENDPSW(8),ABENDHEX-C'0'
         MVI   ABENDPSW+8,C' '  ERASE GARBAGE.
         UNPK  ABENDADR(9),SDWANXT1(5)
         TR    ABENDADR(8),ABENDHEX-C'0'
         MVI   ABENDADR+8,C'P'  RESTORE NEXT MESSAGE'S MSGID.
         LA    R1,ABENDMS2
         LA    R0,ABENDLN2
         TPUT  (1),(0),R        DISPLAY PSW DETAILS.
         LA    R1,ABENDMSN
         LA    R0,L'ABENDMSN
         CLI   SDWANAME+5,0     ANY ACTIVE MODULE?
         BE    PUTACTIV         NO.
         MVC   ABENDNAM,SDWANAME
         UNPK  ABENDEPA(9),SDWAEPA(5)
         TR    ABENDEPA(8),ABENDHEX-C'0'
         MVI   ABENDEPA+8,C' '  ERASE GARBAGE.
         L     R1,SDWANXT1
         SL    R1,SDWAEPA       GET THE OFFSET.
         ST    R1,ABNDTEMP
         NI    ABNDTEMP,X'7F'   ENSURE SIGN BIT IS OFF.
         UNPK  ABENDOFF(9),ABNDTEMP(5)
         TR    ABENDOFF(8),ABENDHEX-C'0'
         MVI   ABENDOFF+8,C'P'  RESTORE NEXT MESSAGE'S MSGID.
         LA    R1,ABENDMS3
         LA    R0,ABENDLN3
PUTACTIV TPUT  (1),(0),R        DISPLAY ACTIVE MODULE DETAILS.
         L     R1,SDWANXT1
         LA    R1,0(,R1)
         LA    R0,6
         SR    R1,R0            POINT TO BEFORE FAILING INSTRUCTION.
         ST    R1,ABNDTEMP
         UNPK  ABENDTAD(9),ABNDTEMP(5)
         TR    ABENDTAD(8),ABENDHEX-C'0'
         MVI   ABENDTAD+8,C' '
         LA    R0,3
         LA    R15,ABENDATA
ABNDATLP UNPK  0(9,R15),0(5,1)
         TR    0(8,R15),ABENDHEX-C'0'
         MVI   8(R15),C' '
         LA    R1,4(,R1)
         LA    R15,9(,R15)
         BCT   R0,ABNDATLP
         LA    R1,ABENDMS4
         LA    R0,ABENDLN4
         TPUT  (1),(0),R        DISPLAY DATA AT PSW DETAILS.
         LA    R6,4             FOUR REGISTER LINES TO BE SHOWN.
         LA    R7,ABNDREGS      POINT TO REGISTER LABELS.
         LA    R8,SDWAGRSV      POINT TO REGISTER CONTENTS.
ABRGLNLP MVC   ABENDRGS,0(R7)   LABEL THE REGISTERS OF THIS LINE.
         LA    R0,4             FOUR REGISTERS SHOWN ON THIS LINE.
         LA    R5,ABENDRDT      POINT TO FIRST DISPLAY SLOT.
ABNDRGLP UNPK  0(9,R5),0(5,R8)
         TR    0(8,R5),ABENDHEX-C'0'
         MVI   8(R5),C' '
         LA    R8,4(,R8)        POINT TO NEXT REGISTER'S DATA.
         LA    R5,9(,R5)        POINT TO NEXT DISPLAY SLOT.
         BCT   R0,ABNDRGLP
         LA    R1,ABENDMS5
         LA    R0,ABENDLN5
         TPUT  (1),(0),R        DISPLAY REGISTER CONTENTS DETAILS.
         LA    R7,3(,R7)        POINT TO NEXT LABEL LITERAL.
         BCT   R6,ABRGLNLP
         L     R12,SDWAPARM     LOAD THE RETRY ADDRESS.
         TM    SDWANXT1,X'7F'   EXECUTING ABOVE THE LINE?
         BNZ   GATFAIL          YES, PERCOLATE THE ABEND.
         CLC   SDWAADD1,1(R12)  ADDRESS BEFORE EXTRACTION ZONE?
         BL    GATFAIL          YES, PERCOLATE THE ABEND.
         CLC   SDWAADD1,5(R12)  ADDRESS AFTER EXTRACTION ZONE?
         BNL   GATFAIL          YES, PERCOLATE THE ABEND.
         L     R12,8(,R12)      LOAD THE RETRY ADDRESS.
         SETRP WKAREA=(3),REGS=(14,12),DUMP=NO,RC=4,                   +
               RETADDR=(12),RETREGS=YES,FRESDWA=YES
GATFAIL  DS    0H               ABNORMALLY TERMINATE WITH A DUMP.
         SETRP WKAREA=(3),REGS=(14,12),DUMP=YES,RC=0
         DROP  3                SDWA.
         SPACE
ENTRY12  LR    R10,R15          LOAD EXIT BASE REGISTER.
         LR    R5,R14           SAVE RETURN ADDRESS.
         LA    R1,ABN12MSG      POINT TO ESTAE EXIT NOTIFY MESSAGE.
         WTO   MF=(E,(1))       ISSUE THE MESSAGE.
         LR    R14,R5           RESTORE RETURN ADDRESS.
         SLR   R15,R15          CONTINUE WITH ABEND (PERCOLATE).
         BR    R14              EXIT FROM EXIT.
         SPACE
         DROP  R10              GATABEND.
         SPACE 2
ABNDTEMP DC    F'0'
TWELVE   DC    H'12'
ABENDMS1 DC    C'PRY691I  IMDATGAT TASK ABEND S'
ABENDCDE DC    C'___',C'-'
ABENDINT DC    C'____'
ABENDLN1 EQU   *-ABENDMS1
ABENDMS2 DC    C'PRY692I    PSW  '
ABENDPSW DC    CL8' ',C' '
ABENDADR DC    CL8' '
ABENDLN2 EQU   *-ABENDMS2
ABENDMS3 DC    C'PRY693I    ACTIVE MODULE '
ABENDNAM DC    CL8'________',C'  EPA '
ABENDEPA DC    CL8'________',C'  OFFSET +'
ABENDOFF DC    CL8'________'
ABENDLN3 EQU   *-ABENDMS3
ABENDMS4 DC    C'PRY694I    DATA AT '
ABENDTAD DC    CL8'________',C'   '
ABENDATA DC    CL27' '
ABENDLN4 EQU   *-ABENDMS4
ABENDMS5 DC    C'PRY695I    GPRS '
ABENDRGS DC    C'#-#',C'  '
ABENDRDT DC    CL36' '
ABENDLN5 EQU   *-ABENDMS5
ABENDMSN DC    C'PRY696I    NO ACTIVE MODULE FOUND'
ABENDHEX DC    C'0123456789ABCDEF'
ABNDREGS DC    C'0-34-78-BC-F'
ABN12MSG WTO   'PRY699I  IMDATGAT ESTAE EXIT - ENTRY CODE 12 - NO VIRTU+
               AL STORAGE FOR RTM SDWA',ROUTCDE=(2,11),MF=L
         SPACE
         LTORG
         SPACE
         DS    0D                 END OF CSECT.
         COPY  IMGATCOM
         TITLE 'INTERNAL DATA AREAS'
         COPY  IMGATDAT
         TITLE 'RMF RECORD STRUCTURES'
         ERBSMFR (70,71,72,73,75,78)
         ERBSMF74 1
         TITLE 'SMF RECORD STRUCTURES'
SMFRECD  DSECT
         IFASMFR (6)
         EJECT
         ORG   SMFRECD
         IFASMFR (14)
         SPACE
         ORG   SMFJFCB1
         IEFJFCBN
         EJECT
         ORG   SMFRECD
         IFASMFR (17)
         ORG   SMFRECD
         IFASMFR (18)
         EJECT
         ORG   SMFRECD
         IFASMFR (57)             INVOKE MACRO IAZSMF57.
         EJECT
         ORG   SMFRECD
         IFASMFI6 61
         ORG   SMFRECD
         IFASMFR (62)
         ORG   SMFRECD
         IFASMFR (64)
         ORG   SMFRECD
         IFASMFI6 65
         ORG   SMFRECD
         IFASMFI6 66
         EJECT
         IFASMFR (30)
         EJECT
         COPY  PDLFRECS
         TITLE 'SYSTEM CONTROL BLOCKS'
         IHASDWA VRAMAP=NO
         EJECT
         COPY  ICFDSECT
         EJECT
         CVT   DSECT=YES
         SPACE 2
         IEESMCA
         SPACE 2
         END   IMDATGAT

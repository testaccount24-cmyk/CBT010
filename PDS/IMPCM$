*        COPYRIGHT (C) 1989  PRYCROFT SIX PTY LTD
         TITLE 'DISK SPACE SNAP-SHOT TABLE'
         COPY  IMSPDSST
         TITLE 'DISK SPACE STATUS DISPLAY SUBROUTINE'
&IMPSECT CSECT
         USING DSK$PACE,R11,R10
DSK$PACE DS    0H
         LA    R10,2048(,R11)    INITIALIZE SECOND
         LA    R10,2048(,R10)                      BASE REGISTER.
         AIF   (&MSPMON).$INIT
         XC    SECTIOWA,SECTIOWA CLEAR A WORK AREA.
         TM    OSLEVEL,CVTUCBSV  UCB SERVICES AVAILABLE?
         BNO   $NOSERV1          NO, USE IEFEB4UV.
         CLI   $UNITNAM,C' '     ANY UNIT NAME SPECIFIED?
         BNH   $UNIT1OK          NO.
         LA    R4,32             YES.
         SLL   R4,10             GET 32K.
         LR    R0,R4             SET GETMAIN AMOUNT.
         GETMAIN RU,LV=(0),SP=SUBPOOL,LOC=(ANY)
         ST    R1,SECTIOWA       SAVE DEVICE NUMBER LIST ADDRESS.
         ST    R4,0(,R1)         SAVE DEVICE NUMBER LIST SIZE.
         EDTINFO RTNDEVN,        REQUEST DEVICE NUMBER LIST            +
               UNITNAME=$UNITNAM,        FOR THIS UNIT.                +
               DYNAMIC=YES,                                            +
               DEVNLIST=SECTIOWA,                                      +
               RANGE=ALL,                                              +
               LOC=ANY,                                                +
               MF=S
         LTR   R15,R15           UCB LIST SUCCESSFULLY SUPPLIED?
         BZ    $UNIT1OK          YES.
         B     $NOUNIT1          NO, ZERO THE UNIT NAME.
$NOSERV1 LA    R4,SECTIOWA+16    POINT TO AREA FOR FUNCTION FLAGS.
         USING FUNCFLGS,R4
         MVI   FUNCFLG1,RETNUCBS REQUEST RETURN OF UCB ADDRESS.
         MVI   FUNCFLG2,SPECSUBP SUBPOOL WILL BE SPECFIED.
         ST    R4,SECTIOWA+4     SAVE SECOND PARAMETER IN PLIST.
         OI    SECTIOWA+4,X'80'  IT IS ALSO THE LAST PARAMETER.
         DROP  R4                FUNCFLGS.
         LA    R4,SECTIOWA+32    POINT TO AREA FOR UNIT TABLE.
         USING UNITTAB,R4
         MVC   UNITNM,$UNITNAM   INITIALIZE UNIT NAME.
         MVI   UNSUBPL+1,SUBPOOL SUPPLY SUBPOOL TO BE USED.
         MVI   UNDEVCL,UCB3DACC  LIMIT SEARCH TO DASD DEVICE CLASS.
         ST    R4,SECTIOWA       SAVE FIRST PARAMETER IN PLIST.
         CLI   UNITNM,C' '       ANY UNIT NAME SPECIFIED?
         BNH   $UNIT1OK          NO.
         LA    R1,SECTIOWA       YES, POINT TO PARAMETER LIST.
         LINK  EPLOC=EB4UVNAM    INVOKE IEFEB4UV FOR UCB ADDRESS LIST.
         LTR   R15,R15           UCB LIST SUCCESSFULLY SUPPLIED?
         BZ    $UNIT1OK          YES.
         XC    UNITNM,UNITNM     NO, ZERO THE UNIT NAME.
$NOUNIT1 XC    $UNITNAM,$UNITNAM
         DROP  R4                UNITTAB.
.$INIT   ANOP
$UNIT1OK L     R15,PRNTADDR      GET ADDRESSABILITY TO TRANSLATE TABLE.
         USING SCRNPRNT,R15
         MVI   PRTXLATE+4,C'.'   MONOCHROME REPLACEMENT CHR FOR GREEN.
         MVI   PRTXLATE+6,C'_'   MONOCHROME REPLACEMENT CHR FOR YELLOW.
         OI    MODESW2,CLNF      FLAG CLEANUP REQUIRED UPON EXIT.
         DROP  R15               SCRNPRNT.
         LA    R2,BUFFER         RESET BUFFER POINTER.
         MVC   INCHARS(L'INCHARS-1),INCHARS+1
         MVI   INCHARS+L'INCHARS-1,C' '      ADJUST ANY COMMAND INPUT.
         SLR   R5,R5             INDICATE RESTART REQUIRED.
         B     CMDSCAN$          PROCESS INITIAL SUBCOMMAND.
         SPACE
NOL$PACE DS    0H                SHOW MESSAGE WHY NO DATA IS AVAILABLE.
         MVC   0(LL-79,R2),HIGHX
         MVI   LL-79(R2),C' '    BLANK DISPLAY LINE.
         MVC   LL-78(78,R2),LL-79(R2)
         MVC   LL-70(20,R2),=CL22'DATA NOT DISPLAYED -'
         SLL   R3,5              MULTPLY BY 32 FOR INDEX INTO MESSAGES.
         LA    R1,$PACERRS(R3)   POINT TO APPROPRIATE MESSAGE.
         MVC   LL-49(32,R2),0(R1) LOAD MESSAGE.
         LA    R2,LL(,R2)        ADJUST BUFFER POINTER.
         SLR   R0,R0
         ST    R0,$PCDSPST       ZERO ANY REMEMBERED DSST ADDRESS.
         B     $XMUNDUN          GO SHOW IT.
         SPACE
         AIF   (&MSPMON).REDO$
$ALLUNIT XC    $UNITNAM,$UNITNAM RESET ANY SPECIFIED UNIT NAME.
         TM    OSLEVEL,CVTUCBSV  UCB SERVICES AVAILABLE?
         BNO   REDO$PAC          NO.
         ICM   R1,15,SECTIOWA    POINT TO DEVICE NUMBER LIST AREA.
         BZ    REDO$PAC          THERE IS NONE TO FREE.
         L     R0,0(,R1)         GET ITS SIZE.
         LA    R15,SUBPOOL       GET THE SUBPOOL.
         FREEMAIN RU,LV=(0),A=(1),SP=(15)
         ST    R15,SECTIOWA      CLEAR DEVICE NUMBER LIST POINTER.
.REDO$   ANOP
REDO$PAC MVC   HEADING,HEADING$  LOAD FREE SPACE DISPLAY HEADING.
         AIF   (&MSPMON).$REDO
         CLI   $STORNAM,C' '     ANY SMS STORAGE GROUP SELECTION?
         BNH   $SGHDGOK          NO.
         MVC   HEADING+39(13),=C'(SG=********)'
         LH    R1,$PRFXLEN       GET THE LENGTH OF THE GROUP PREFIX.
         BCTR  R1,0              LESS ONE FOR EXECUTE.
$GETSHDG MVC   HEADING+43(0),$STORNAM
         EX    R1,$GETSHDG       LOAD THE GROUP PREFIX INTO HEADING.
$SGHDGOK L     R4,SECTIOWA       POINT TO THE UNIT TABLE.
         TM    OSLEVEL,CVTUCBSV  UCB SERVICES AVAILABLE?
         BNO   $NOSERV2          NO.
         SLR   R8,R8             YES, RESET LIST POINTER.
         CLI   $UNITNAM,C' '     ANY UNIT NAME SPECIFIED?
         BNH   $HDGUOK           NO, NO UNIT TO PUT IN HEADING.
         L     R0,4(,R4)         YES, GET SUPPLIED DEVICE NUMBER COUNT.
         L     R8,8(,R4)         POINT TO THE FIRST DEVICE NUMBER.
         B     $UHDGNUM          SHOW THE NUMBER OF DEVICES IN UNIT.
         USING UNITTAB,R4
$NOSERV2 ICM   R8,15,UNUCBL4P    POINT TO THE UCB LIST.
         BZ    $HDGUOK           NO LIST SO UNIT PART OF HEADING IS OK.
         DROP  R4                UNITTAB.
         USING UCBLIST4,R8
         L     R0,LIST4NUM       GET THE NUMBER OF SUPPLIED UCBS.
$UHDGNUM CVD   R0,WORK
         MVC   HEADING+26(6),ED5
         ED    HEADING+26(6),WORK+5
         MVC   HEADING+38(8),=CL8'IN UNIT='
         MVC   HEADING+46(8),$UNITNAM
         AGO   .$REDONE
.$REDO   ANOP
         L     R15,=A(UPRFXLEN)  GET ADDRESSABAILITY TO SELUCBID.
         USING UPRFXLEN,R15
         CLI   SELUCBID,C' '     ANY UCB NAME MASKING?
         BNH   $HDGUOK           NO.
         MVC   HEADING+38(R11),=CL11'IN UNIT=***'
         LH    R1,UPRFXLEN       GET THE LENGTH OF THE UCB NAME PREFIX.
         BCTR  R1,0              LESS ONE FOR EXECUTE.
$GETUHDG MVC   HEADING+46(0),SELUCBID
         EX    R1,$GETUHDG       LOAD THE UCB NAME PREFIX INTO HEADING.
         DROP  R15               UPRFXLEN.
.$REDONE ANOP
$HDGUOK  L     R15,=A(VPRFXLEN)  GET ADDRESSABAILITY TO SELVOLID.
         USING VPRFXLEN,R15
         CLI   SELVOLID,C' '     ANY VOLUME SERIAL MASKING?
         BNH   $HDGVOK           NO.
         MVC   HEADING+54(16),=CL16'(VOL=SER=******)'
         LH    R1,VPRFXLEN       GET THE LENGTH OF THE VOLUME PREFIX.
         BCTR  R1,0              LESS ONE FOR EXECUTE.
$GETVHDG MVC   HEADING+63(0),SELVOLID
         EX    R1,$GETVHDG       LOAD THE VOLUME PREFIX INTO HEADING.
         DROP  R15               VPRFXLEN.
$HDGVOK  TR    HEADING,XLATETBL HANDLE UNPRINTABLES.
         SLR   R0,R0
         ST    R0,GQ$TOKEN       ZERO THE GQSCAN TOKEN.
         SLR   R3,R3             PREPARE FOR MESSAGE 0.
         LA    R5,SECWORKA       GET A GQSCAN WORK AREA.
         GQSCAN AREA=((5),512),SCOPE=SYSTEM,                           +
               RESNAME=(IMPMAJNM,IMPMINNM,IMINORLN,SPECIFIC,8),        +
               TOKEN=GQ$TOKEN
         LTR   R15,R15           FOUND AN ENQUEUE?
         BZ    $FINDGAT          YES, GO LOOK AT IT.
         CHI   R15,8             WAS AREA FILLED WITH TOO MUCH DATA?
         BNE   NOL$PACE          NO, THE SPACE MONITOR IS DOWN.
         GQSCAN QUIT=YES,TOKEN=GQ$TOKEN YES, SO QUIT THE GQSCAN FIRST.
         SPACE
$FINDGAT DS    0H                GO FIND THE SPACE MONITOR ASID.
         LA    R1,SECWORKA       POINT TO RIB.
         USING RIB,R1
         SLR   R4,R4
         ICM   R4,3,RIBVLEN      GET LENGTH OF RIBVAR.
         SRL   R0,16             GET LENGTH OF FIXED RIB PORTION.
         ALR   R4,R0             GET OFFSET TO FIRST RIBE.
         ALR   R4,R1             POINT TO FIRST RIBE.
         DROP  R1                RIB.
         USING RIBE,R4
         SLR   R1,R1
         ICM   R1,3,RIBEASID     LOAD THE SPACE MONITOR ASID.
         C     R1,$GATASID       IS IT STILL THE SAME ADDRESS SPACE?
         BE    $GATASOK          YES, PROCEED.
         XC    $TATADRS($TATADLN),$TATADRS  RESET CURRENT STATUS AREA.
         ST    R1,$GATASID       SAVE THE ASID FOR LATER.
$GATASOK SLL   R1,2              MULTIPLY ASID BY FOUR FOR INDEX.
         A     R1,ASVTADDR
         AIF   (&MVSMON).$OSASID
         AIF   (&XATEST).$OSASID
         ICM   R1,B'1111',0(R1)  LOAD SPACE MONITOR ASCB POINTER.
         BNM   NOL$PACE          THE ADDRESS SPACE IS NOT ASSIGNED.
         AGO   .$F4ASID
.$OSASID ANOP
         ICM   R1,15,524(R1)     LOAD SPACE MONITOR ASCB POINTER.
         BM    NOL$PACE          THE ADDRESS SPACE IS NOT ASSIGNED.
.$F4ASID ANOP
         MVC   $GTCBADR,RIBETCB  SAVE THE SPACE MONITOR TCB ADDRESS.
         DROP  R4                RIBE.
         SPACE
         AIF   (&MSPMON).$XAI
         TM    OSBITS,X'9B'      MVS/ESA?
         BNO   $AXSTUFF          NO, CAN'T USE ACCESS REGISTERS.
         L     R5,$PACALET       YES, LOAD THE PREVIOUS ALET VALUE.
         L     R1,336(,R1)       POINT TO THE SPACE MONITOR ASSB.
         CLC   DG$TOKEN,48(R1)   SAME SPACE TOKEN AS BEFORE?
         BNE   $GETSTKN          NO, GO GET THE NEW ONE.
         LTR   R5,R5             YES, STILL HAVE THE CURRENT ALET?
         BNZ   $GOTALET          YES, PROCEED.
$GETSTKN MVC   DG$TOKEN,48(R1)   NO, COPY SPACE MONITOR SPACE TOKEN.
         MODESET MF=(E,MDSTSUP0)
         LTR   R5,R5             OUT-OF-DATE ALET STILL IN DU-AL?
         BZ    $DGDELOK          NO, VALID ALET CANNOT BE ZERO.
         ALESERV DELETE,ALET=(5),CHKEAX=NO,MF=(E,ALESERVL)
         SLR   R5,R5             ALET NOW DELETED.
         ST    R5,$PACALET       ZERO THE REMEMBERED ALET VALUE.
         XC    $TATADRS($TATADLN),$TATADRS  RESET CURRENT STATUS AREA.
$DGDELOK DS    0H
         ALESERV ADD,STOKEN=DG$TOKEN,ALET=(5),CHKEAX=NO,               +
               MF=(E,ALESERVL)   ADD ALET TO DU-AL.
         LR    R3,R15            SAVE THE RETURN CODE.
         MODESET MF=(E,MDSTPROB)
         LTR   R3,R3             WAS THE ADD SUCCESSFUL?
         BZ    $DGADDOK          YES, PROCEED.
         XC    DG$TOKEN,DG$TOKEN  NO, ERASE REMEMBERED STOKEN VALUE.
         NI    MODESW2,255-CLNF  CLEAN-UP NOT REQUIRED IF EXIT HERE.
         ST    R3,WORK
         UNPK  $BADMSG1+27(3),WORK+3(2)
         TR    $BADMSG1+27(2),HEX-C'0'
         MVI   $BADMSG1+29,C' '  DISPLAY THE RETURN CODE.
         LA    R3,1              PREPARE FOR MESSAGE 1.
         B     NOL$PACE
$DGADDOK ST    R5,$PACALET       SAVE THE ALET.
         OI    MODESW2,CLNF      FLAG CLEAN-UP REQUIRED UPON EXIT.
$GOTALET DS    0H                CROSS-MEMORY ACCESS NOW ESTABLISHED.
         SAR   A4,R5             AR 4 WILL ACCESS IMSPACER.
         SAR   A5,R5             AR 5 WILL ACCESS IMSPACER.
         SAR   A6,R5             AR 6 WILL ACCESS IMSPACER.
         SAC   X'200'            GET INTO ACCESS REGISTER MODE.
         B     $GETEPAD          CROSS-MEMORY ACCESS NOW ESTABLISHED.
         SPACE
$AXSTUFF DS    0H                ESTABLISH XA CROSS-MEMORY ACCESS.
.$XAI    ANOP
         MODESET MF=(E,MDSTSUP0)
         BAS   R14,DONTSWAP      BECOME NON-SWAPPABLE.
         STATUS SET,MC,STEP      STOP ALL OTHER TASKS.
         LA    R1,1              ADDRESS ALL AX NUMBER.
         AXSET AX=(1)            SET AX = 1.
         ST    R0,AXVALUE        SAVE ORIGINAL AX VALUE.
         L     R4,$GATASID       GET TARGET ASID.
         SSAR  R4                MAKE TARGET JOB THE SECONDARY ASID.
*        B     $GETEPAD          XA CROSS-MEMORY ACCESS ESTABLISHED OK.
         SPACE
$GETEPAD ICM   R4,15,$BASEADR    GET FIRST AND LAST POINTERS ADDRESS.
         BNZ   $GOTBASE          PROCEED.
         L     R4,$GTCBADR       POINT TO THE SPACE MONITOR TCB.
         LA    R0,4              FIRST 4 BYTES OF R4->TCB POINTS TO RB.
         BAS   R14,R4ACCES$
         L     R4,0(,R4)         POINT TO THE TOP RB.
         LA    R0,32             GET FIRST 32 BYTES OF R4->RB.
$GRBLOOP LR    R5,R4             COPY THE RB ADDRESS.
         BAS   R14,R4ACCES$
         ICM   R4,7,29(R4)       POINT TO NEXT RB.
         C     R4,$GTCBADR       IS THIS THE TCB ADDRESS?
         BNE   $GRBLOOP          NO, FOLLOW CHAIN TO ORIGINAL RB.
         LA    R0,16             YES, GET FIRST 16 BYTES OF R5->RB.
         BAS   R14,R5ACCES$
         L     R4,12(,R5)        POINT TO THE ORIGINAL CDE.
         SLL   R4,8
         SRL   R4,8              ENSURE 24-BIT ADDRESS.
         LA    R0,20             GET FIRST 20 BYTES OF R4->CDE.
         BAS   R14,R4ACCES$
         L     R4,16(,R4)        POINT TO IMSPACER ENTRY POINT.
$GOTDGEP LA    R4,52(,R4)        POINT TO FIRST AND LAST DSST POINTERS.
         ST    R4,$BASEADR       SAVE ADDRESS OF DSST POINTERS.
$GOTBASE LA    R0,8              SET LENGTH OF TWO POINTERS.
         BAS   R14,R4ACCES$      RETRIEVE FIRST AND LAST POINTERS.
         ICM   R5,15,$PCDSPST    POINT TO FIRST SNAP-SHOT TO DISPLAY.
         BZ    $SHOWTOP          IF ZERO THEN SHOW FROM THE TOP.
         USING DSST,R5
         LA    R0,DSSTBLEN
         BAS   R14,R5ACCES$
         CLI   $SCRLAMT,X'7F'    BOTTOM REQUESTED?
         BE    $SHOWBTM          YES, DIRECTLY ACCESS THE BOTTOM.
         ICM   R1,15,$SCRLAMT    LOAD ENTRY COUNT TO BE SCROLLED.
         BZ    FRSTDSST          ZERO SO START FORMATTING.
         BP    $FORWDLP          POSITIVE SO SCROLL FORWARD.
         LPR   R1,R1             NEGATIVE SO GET COUNT TO SCROLL BACK.
$BAKWDLP ICM   R5,15,DSSTBACK    POINT TO THE PREVIOUS SNAP-SHOT.
         BZ    $SHOWTOP          BACKWARD CHAIN END SO SHOW FROM TOP.
         ST    R5,$PCDSPST       THIS MAY BE THE NEW TOP OF SCREEN.
         LA    R0,DSSTBLEN
         BAS   R14,R5ACCES$
         BCT   R1,$BAKWDLP       CONTINUE SCROLLING TO CORRECT ENTRY.
         B     FRSTDSST          NOW AT THE CORRECT LOCATION.
$SHOWBTM MVI   INBUFF,13         ERASE SCROLL DOWN INDICATOR.
         L     R5,4(,R4)         POINT TO THE LAST SNAP-SHOT.
         LA    R0,DSSTBLEN
         BAS   R14,R5ACCES$
         L     R1,LINES          GET THE SCREEN LINE COUNT.
         AHI   R1,-4             GET THE SCROLL UP VALUE.
         B     $BAKWDLP          GO DO IT.
$FORWDLP ICM   R5,15,DSSTDSST    POINT TO THE NEXT SNAP-SHOT.
         BZ    $SHOWTOP          HANDLE END OF CHAIN IF ENCOUNTERED.
         ST    R5,$PCDSPST       THIS MAY BE THE NEW TOP OF SCREEN.
         LA    R0,DSSTBLEN
         BAS   R14,R5ACCES$
         BCT   R1,$FORWDLP       CONTINUE SCROLLING TO CORRECT ENTRY.
         B     FRSTDSST          GET FORMATTING.
$SHOWTOP CLI   INBUFF,8          WAS THIS A SCROLL DOWN REQUEST?
         BE    $SHOWBTM          YES, SO FORCE A SCROLL DOWN MAXIMUM.
         L     R5,0(,R4)         POINT TO THE FIRST DSNAME SNAP-SHOT.
         ST    R5,$PCDSPST       THIS IS THE NEW TOP OF SCREEN.
         SLR   R1,R1
         SPACE
FRSTDSST DS    0H                SUPPLY A SUB-HEADING TO LABEL COLUMNS.
         ST    R1,$SCRLAMT       RESET PREVIOUS SCROLL AMOUNT.
         MVC   0(LL-79,R2),HIGHX
         MVC   LL-79(79,R2),SUBHDG$$
         TM    $FLAGS,$GRAFON    IS GRAPHIC DISPLAY MODE ACTIVE?
         BZ    $SBHDGOK          NO, CONTINUE WITH "NORMAL" DISPLAY.
         MVC   LL-79(79,R2),SUBHDGG$ YES, LOAD APPROPRIATE SUB-HEADING.
$SBHDGOK TR    LL-79(79,R2),XLATETBL
         LA    R2,LL(,R2)        ADJUST BUFFER POINTER.
         L     R5,$PCDSPST       POINT TO FIRST ENTRY TO DISPLAY.
THISDSST LTR   R5,R5             ANY DATA TO SHOW?
         BZ    DONE$PAC          NO.
         MVC   0(LL-79,R2),LOWX  YES, INITIALIZE DISPLAY LINE.
         MVI   $PACLINE,C' '
         MVC   $PACLINE+1(78),$PACLINE
         SLR   R0,R0
         BCTR  R0,0              MAKE REGISTER 0 NEGATIVE.
         BAS   R14,R5ACCES$      RETRIEVE DISK SPACE SNAP-SHOT TABLE.
         TM    $FLAGS,$DATEFMT   NO, USING YYMMDD DATE FORMAT?
         BO    $DATEYMD          YES.
         UNPK  $DATE+1(5),DSSTDATE+1(3)
         MVC   $DATE(2),$DATE+1
         MVI   $DATE+2,C'.'      DISPLAY DATE IN YY.DDD FORMAT.
         B     $DTFMTOK
$DATEYMD L     R1,DSSTDATE       GET THE JULIAN DATE.
         L     R7,DTCONVAD       GET DATE CONVERSION ENTRY POINT.
         BASR  R14,R7            CONVERT THE JULIAN DATE.
         MVC   $DATE(2),WORK     LOAD YY
         MVC   $DATE+2(2),WORK+3 AND MM
         MVC   $DATE+4(2),WORK+6 AND DD.
$DTFMTOK UNPK  $TIME,DSSTTIME(3)
         ICM   R0,3,$TIME+2
         STCM  R0,3,$TIME+3      MOVE MINUTES TO RIGHT SPOT.
         MVI   $TIME+2,C':'      DISPLAY TIME IN HH:MM FORMAT.
         XC    $CNTRS($CTLN),$CNTRS     ZERO DSSTE ACCUMULATORS.
         L     R14,DSSTSIZE      GET ENTIRE DSSTSIZE.
         AHI   R14,-DSSTBLEN     GET SIZE OF ALL DSST ENTRIES.
         BNP   EODSSTES          MUST BE ALL UNSUPPORTED DEVICE TYPES.
         SPACE
         LA    R6,DSSTE          POINT TO THE FIRST DSSTE.
         USING DSSTE,R6
GOTDSSTE CLI   DSSTEVOL,0        ANY DATA IN THIS DSSTE?
         BE    NXTDSSTE          NO, GO GET NEXT ONE.
         L     R3,DSSTEUCB       YES, GET UCB NAME OR ADDRESS.
         AIF   (&MSPMON).$MSPU
         TM    OSLEVEL,X'88'     UCB SERVICES AVAILABLE?
         BNO   $NOSERV3          NO.
         ICM   R1,15,SECTIOWA    YES, POINT TO DEVICE LIST AREA.
         BZ    $GOODUCB          NO LIST, DON'T REJECT THE UCB HERE.
         ICM   R0,15,4(R1)       GET THE NUMBER OF UCBS IN LIST.
         BZ    NXTDSSTE          THERE ARE NONE SO REJECT THE VOLUME.
         LA    R1,8(,R1)         POINT TO FIRST DEVICE NUMBER IN LIST.
         B     $UCBLOOP          SEARCH FOR THIS DEVICE IN THE LIST.
$NOSERV3 LTR   R8,R8             ANY UCB LIST CHECKING REQUIRED?
         BZ    $GOODUCB          NO, DON'T REJECT THE UCB HERE.
         ICM   R0,15,LIST4NUM    YES, GET THE NUMBER OF UCBS IN LIST.
         BZ    NXTDSSTE          THERE ARE NONE SO REJECT THE VOLUME.
         LA    R1,LIST4UCB       POINT TO THE UCB ADDRESS LIST.
$UCBLOOP CL    R3,0(,R1)         MATCHING UCB ADDRESS?
         BE    $GOODUCB          YES, PROCESS IT.
         LA    R1,4(,R1)         NO, POINT TO THE NEXT ADDRESS.
         BCT   R0,$UCBLOOP       CHECK OUT THE NEXT UCB ADDRESS.
         B     NXTDSSTE          UCB ADDRESS NOT IN LIST SO REJECT IT.
         DROP  R8                UCBLIST4.
         AGO   .$GDUCB
.$MSPU   ANOP
         L     R7,=A(UPRFXLEN)   YES, GET ADDRESSABILITY TO SELUCBID.
         USING UPRFXLEN,R7
         CLI   SELUCBID,C' '     ANY UCB NAME MASKING?
         BNH   $GOODUCB          NO.
         LH    R1,UPRFXLEN       GET THE LENGTH OF THE UCB NAME PREFIX.
         LA    R15,SELUCBID      POINT TO DESIRED PREFIX.
         MVC   LL-70(3,R2),13(R3) COPY UCB NAME TO WORK AREA.
         LA    R0,LL-70(,R2)     POINT TO UCB NAME.
         DROP  R7                UPRFXLEN.
         STM   R15,R1,WORK+4     SAVE PARAMETER LIST.
         L     R7,PRFCHKAD       LOAD PREFCHEK ENTRY POINT.
         BASR  R1,R7             COMPARE UCB NAME WITH PREFIX.
         BNE   NXTDSSTE          DIDN'T MATCH SO GET NEXT ONE.
.$GDUCB  ANOP
$GOODUCB L     R7,=A(VPRFXLEN)   YES, GET ADDRESSABILITY TO SELVOLID.
         USING VPRFXLEN,R7
         CLI   SELVOLID,C' '     ANY VOLUME SERIAL MASKING?
         BNH   $GOODVOL          NO.
         LH    R1,VPRFXLEN       GET THE LENGTH OF THE VOLUME PREFIX.
         LA    R15,SELVOLID      POINT TO DESIRED PREFIX.
         MVC   LL-70(6,R2),DSSTEVOL    COPY VOLUME SERIAL TO WORK AREA.
         LA    R0,LL-70(,R2)     POINT TO DISK VOLUME SERIAL.
         DROP  R7                VPRFXLEN.
         STM   R15,R1,WORK+4     SAVE PARAMETER LIST.
         L     R7,PRFCHKAD       LOAD PREFCHEK ENTRY POINT.
         BASR  R1,R7             COMPARE VOLUME SERIAL WITH PREFIX.
         BNE   NXTDSSTE          DIDN'T MATCH SO GET NEXT ONE.
$GOODVOL DS    0H
         AIF   (&MSPMON).$GDGRP
         CLI   $STORNAM,C' '     ANY STORAGE GROUP NAME MASKING?
         BNH   $GOODGRP          NO.
         LH    R1,$PRFXLEN       GET THE LENGTH OF THE GROUP PREFIX.
         LA    R15,$STORNAM      POINT TO DESIRED PREFIX.
         MVC   LL-70(8,R2),DSSTEGRP    COPY STORAGE GROUP TO WORK AREA.
         LA    R0,LL-70(,R2)     POINT TO DISK STORAGE GROUP.
         STM   R15,R1,WORK+4     SAVE PARAMETER LIST.
         L     R7,PRFCHKAD       LOAD PREFCHEK ENTRY POINT.
         BASR  R1,R7             COMPARE VOLUME SERIAL WITH PREFIX.
         BNE   NXTDSSTE          DIDN'T MATCH SO GET NEXT ONE.
$GOODGRP DS    0H
.$GDGRP  ANOP
         LA    R0,1              INCREMENT THE USABLE VOLUME COUNTER.
         A     R0,GOODVOLS
         ST    R0,GOODVOLS
         SLR   R0,R0
         ICM   R0,3,DSSTETSZ     GET THE TRACK SIZE.
         SRL   R0,11             TRUNCATE TO 2K BOUNDARY.
         SLL   R0,1              CONVERT TO KILOBYTES.
         STH   R0,WORK           SAVE FOR LATER.
         L     R15,DSSTECYL      GET FREE CYLINDERS FOR THIS VOLUME.
         LR    R0,15             COPY IT.
         A     R0,FREECYLS
         ST    R0,FREECYLS       ADD IT TO TOTAL FREE CYLINDERS.
         MH    R15,DSSTETPC      CONVERT IT TO TRACKS.
         L     R0,DSSTETRK       GET FREE TRACKS FOR THIS VOLUME.
         AR    R15,R0            GET TOTAL FREE TRACKS FOR THIS VOLUME.
         A     R0,FREETRKS
         ST    R0,FREETRKS       TOTAL UP ACROSS VOLUMES.
         MH    R15,WORK          CONVERT FREE TRACKS TO KILOBYTES.
         SRL   R15,10            CONVERT FROM KILOBYTES TO MEGABYTES.
         A     R15,FREEMEGS
         ST    R15,FREEMEGS      TOTAL UP FREE MB ACROSS VOLUMES.
         L     R0,DSSTEEXT       GET FREE EXTENTS FOR THIS VOLUME.
         A     R0,FREEEXTS
         ST    R0,FREEEXTS       TOTAL UP FREE EXTENTS ACROSS VOLUMES.
         L     R15,DSSTEMXC      GET BIGGEST FREE EXTENT CYLINDERS.
         LR    R0,R15            COPY IT.
         A     R0,LARGCYLS
         ST    R0,LARGCYLS       TOTAL UP ACROSS VOLUMES.
         MH    R15,DSSTETPC      CONVERT IT TO TRACKS.
         L     R0,DSSTEMXT       GET BIGGEST FREE EXTENT TRACKS.
         AR    R15,R0            GET CONTIG FREE TRACKS FOR THIS DISK.
         A     R0,LARGTRKS
         ST    R0,LARGTRKS       TOTAL UP ACROSS VOLUMES.
         MH    R15,WORK          CONVERT FREE TRACKS TO KILOBYTES.
         SRL   R15,10            CONVERT FROM KILOBYTES TO MEGABYTES.
         A     R15,LARGMEGS
         ST    R15,LARGMEGS      TOTAL UP CONTIG MB ACROSS VOLUMES.
         SLR   R0,R0
         ICM   R0,3,DSSTEUSE     GET VOLUME USAGE COUNT.
         A     R0,ALLDDSCT
         ST    R0,ALLDDSCT       TOTAL UP ACROSS VOLUMES.
         AIF   (&MVSMON).$MVSOPN
         ICM   R0,3,DSSTEOPN     GET VOLUME OPEN DCB COUNT.
         AGO   .$OPENOK
.$MVSOPN ANOP
         SLR   R0,R0
         IC    R0,DSSTEOPN       GET VOLUME OPEN DCB COUNT.
.$OPENOK ANOP
         A     R0,OPNDCBCT
         ST    R0,OPNDCBCT       TOTAL UP ACROSS VOLUMES.
         SLR   R15,R15
         ICM   R15,3,DSSTECPV    GET THE VOLUME NUMBER OF CYLINDERS.
         MH    R15,DSSTETPC      GET THE VOLUME NUMBER OF TRACKS.
         MH    R15,WORK          GET THE KILOBYTES PER VOLUME.
         SRL   R15,10            CONVERT FROM KILOBYTES TO MEGABYTES.
         A     R15,TOTALMEG
         ST    R15,TOTALMEG      TOTAL UP USABLE MB ACROSS VOLUMES.
NXTDSSTE LA    R0,DSSTELEN       GET THE LENGTH OF A DSSTE.
         ALR   R6,R0             POINT TO THE NEXT DSSTE.
         SR    R14,R0            DECREMENT REMAINING STORAGE TO VIEW.
         BP    GOTDSSTE          IF NOT LAST THEN CRUNCH NEXT DSSTE.
         DROP  R6                DSSTE.
         SPACE
EODSSTES SLR   R1,R1             CATER FOR NO SPACE.
         ICM   R15,15,TOTALMEG   GET TOTAL DASD STORAGE MEGABYTES.
         BZ    NO$PRCNT          ZERO SO 0% AND AVOID S0C9 ABEND.
         L     R1,FREEMEGS       FORMAT AND DISPLAY FREE MEGABYTES.
         CVD   R1,WORK
         MVC   $FREEMEG,ED9Z
         ED    $FREEMEG,WORK+3
         M     R0,AHUNDRED       TIMES ONE HUNDRED FOR PERCENTAGE.
         DR    R0,R15            FREE SPACE AS PERCENTAGE OF TOTAL.
         CVD   R1,WORK
         MVC   $FREEPCT,ED3Z
         ED    $FREEPCT,WORK+6
NO$PRCNT L     R0,ALLDDSCT       FORMAT AND SHOW ALLOCATED FILE COUNT.
         CVD   R0,WORK
         MVC   $DDUSAGE,ED7Z
         ED    $DDUSAGE,WORK+4
         L     R0,OPNDCBCT       FORMAT AND SHOW OPEN DCB COUNT.
         CVD   R0,WORK
         MVC   $DCBOPEN,ED5Z
         ED    $DCBOPEN,WORK+5
         TM    $FLAGS,$GRAFON    IS GRAPHIC DISPLAY MODE ACTIVE?
         BZ    $NOGRAFX          NO, CONTINUE WITH "NORMAL" DISPLAY.
         MVC   $FREECYL(4),$FREEPCT SHOW PERCENT IN A DIFFERENT COLUMN.
         TR    LL-79(79,2),XLATETBL
         MVI   $FREECYL+4,X'3B'  PUT A BORDER BETWEEN COLUMN AND GRAPH.
         MVI   $FREECYL+5,X'07'  WHITE FOR NO DASD EXIST.
         LTR   R15,R15           ANY SPACE TO REPORT ON?
         BZ    $GRFBKGD          NO, FILL IN BACKGROUND.
         MVI   $FREECYL+5,X'02'  RED FOR USED DISK SPACE.
$GRFBKGD MVC   $FREECYL+6(49),$FREECYL+5
         LA    R1,1(,R1)         ROUND UPWARDS.
         SRA   R1,R1             DIVIDE BY TWO.
         BZ    $DONEGRF          NO FREE SPACE WORTH MENTIONING.
         MVI   $FREECYL+5,X'06'  YELLOW FOR FREE DISK SPACE.
         BCTR  R1,0              DECREMENT FOR BYTE ALREADY SUPPLIED.
         BCTR  R1,0              DECREMENT FOR EXECUTE.
         LTR   R1,R1             MORE THAN ONE SCREEN BYTE REQUIRED?
         BM    PLOTDFRE          NO, SHOW LARGEST CONTIGUOUS PERCENT.
         EX    R1,$GRFFREE       YES, SUPPLY THE REST.
PLOTDFRE L     R1,LARGMEGS       FORMAT AND DISPLAY LARGEST FREE MEGS.
         M     R0,AHUNDRED       TIMES ONE HUNDRED FOR PERCENTAGE.
         DR    R0,R15            FREE SPACE AS PERCENTAGE OF TOTAL.
         CVD   R1,WORK
         LA    R1,1(,R1)         ROUND UPWARDS.
         SRA   R1,1              DIVIDE BY TWO.
         BZ    $DONEGRF          NO LARGE FREE SPACE WORTH MENTIONING.
         MVI   $FREECYL+5,X'04'  GREEN FOR LARGEST FREE DISK SPACE.
         BCTR  R1,0              DECREMENT FOR BYTE ALREADY SUPPLIED.
         BCTR  R1,0              DECREMENT FOR EXECUTE.
         LTR   R1,R1             MORE THAN ONE SCREEN BYTE REQUIRED?
         BM    $DONEGRF          NO, GRAPH NOW COMPLETE.
         EX    R1,$GRFFREE       YES, SUPPLY THE REST.
         B     $DONEGRF          GRAPH NOW COMPLETE.
$GRFFREE MVC   $FREECYL+6(0),$FREECYL+5         <<< EXECUTED >>>
$NOGRAFX L     R0,FREECYLS       FORMAT AND SHOW FREE CYLINDER COUNT.
         CVD   R0,WORK
         MVC   $FREECYL,ED7Z
         ED    $FREECYL,WORK+4
         L     R0,FREETRKS       FORMAT AND SHOW FREE TRACK COUNT.
         CVD   R0,WORK
         MVC   $FREETRK,ED9Z
         ED    $FREETRK,WORK+3
         L     R0,FREEEXTS       FORMAT AND SHOW FREE EXTENT COUNT.
         CVD   R0,WORK
         MVC   $FREEEXT,ED5Z
         ED    $FREEEXT,WORK+5
         L     R0,LARGCYLS       FORMAT AND SHOW LARGEST CYL COUNT.
         CVD   R0,WORK
         MVC   $LARGCYL,ED7Z
         ED    $LARGCYL,WORK+4
         L     R0,LARGTRKS       FORMAT AND SHOW LARGEST TRACK COUNT.
         CVD   R0,WORK
         MVC   $LARGTRK,ED5Z
         ED    $LARGTRK,WORK+5
         TR    LL-79(79,R2),XLATETBL
         MVI   $FREEMEG,X'3B'    INDICATE COLUMNS.
         MVI   $FREEPCT,X'3B'
         MVI   $FREEEXT,X'3B'
         MVI   $FILLER,X'3B'
         MVI   $DDUSAGE,X'3B'
$DONEGRF MVI   $DCBOPEN,X'3B'
         MVI   $FREECYL,X'3B'
         MVC   LL-79(79,R2),$PACLINE PUT DETAIL LINE IN SCREEN BUFFER.
         LA    R2,LL(,R2)        ADJUST BUFFER POINTER.
         C     R2,PAGEND         SCREEN NOW FULL?
         BNL   DONE$PAC          YES, SHOW IT.
         L     R5,DSSTDSST       NO, POINT TO THE NEXT DSST.
         B     THISDSST          PROCESS THE NEW DSST.
DONE$PAC DS    0H
         AIF   (&MSPMON).$XAUN
         TM    OSBITS,X'9B'      MVS/ESA?
         BNO   $XAUNDO           NO, CAN'T USE ACCESS REGISTERS.
         SAC   X'000'            REVERT TO PRIMARY SPACE MODE.
         XC    WORK(16),WORK     GET SOME NULLS.
         LAM   A4,A6,WORK        ZERO ACCESS REGISTERS.
         B     $XMUNDUN          ESA CROSS-MEMORY ACCESS NOW REMOVED.
         SPACE
.$XAUN   ANOP
$XAUNDO  L     R8,PSAAOLD        GET CURRENT ASCB.
         LH    R8,ASID(,R8)      GET CURRENT ASID.
         SSAR  R8                GET OUT OF CROSS-MEMORY MODE.
         L     R1,AXVALUE        GET SAVED AX NUMBER.
         AXSET AX=(1)            SET AX = 0.
         STATUS RESET,MC,STEP    START ALL OTHER TASKS.
         BAS   R14,OKAYSWAP      BECOME SWAPPABLE.
         MODESET MF=(E,MDSTPROB)
$XMUNDUN C     R2,PAGEND         SCREEN NOW FULL?
         BNL   PUT$PACE          YES, SHOW IT.
         BAS   R1,SYSUMMRY       PRODUCE & SHOW SYSTEM SUMMARY LINE.
         C     R2,PAGEND         BUFFER FULL?
         BNL   PUT$PACE          YES, SHOW THE PAGE.
         MVC   0(4,R2),BLNKREST  ERASE REST OF SCREEN.
         LA    R2,4(,R2)         ADJUST SCREEN SIZE.
PUT$PACE L     R0,GOODVOLS       LOAD NUMBER OF VOLUMES COUNTED.
         CVD   R0,WORK           FORMAT AND DISPLAY IT IN THE HEADING.
         MVC   HEADING+17(6),ED5
         ED    HEADING+17(6),WORK+5
         TR    HEADING,XLATETBL  REMOVE ANY UNPRINTABLES.
         L     R9,CCTADDR        GET CCT ADDRESS.
         LH    R9,UTILP(,R9)     LOAD CCVUTILP (CPU BUSY %).
         CVD   R9,WORK           CONVERT IT TO DECIMAL.
         MVC   BUSY,ED3          MOVE IN THE EDIT MASK.
         ED    BUSY,WORK+6       EDIT THE OUTPUT FIELD.
         LA    R1,HOME           POINT TO START OF SCREEN BUFFER.
         LR    R0,R2             POINT TO END OF SCREEN BUFFER.
         SR    R0,R1             GET SCREEN BUFFER LENGTH.
PUTSCRN$ BAS   R14,SCREENIO      CALL SCREEN I/O HANDLER.
         LA    R2,BUFFER         RESET BUFFER POINTER.
         CLI   DOWNCNTR,C' '     ARE WE IN AUTO REFRESH MODE?
         BH    $PACAUTO          YES.
         TM    MODESW2,XFLG      NO, SUBROUTINE EXIT REQUIRED?
         BZ    GETCMD$$          NO, PROCESS SUBCOMMAND.
$CLEANUP DS    0H                YES, PERFORM CLEAN-UP.
         AIF   (&MSPMON).$CLNUP
         TM    OSLEVEL,X'88'     UCB SERVICES AVAILABLE?
         BNO   $NOSERV4          NO.
         ICM   R1,15,SECTIOWA    POINT TO DEVICE NUMBER LIST AREA.
         BZ    UNITBCLN          THERE IS NONE TO FREE.
         L     R0,0(,R1)         GET ITS SIZE.
         LA    R15,SUBPOOL       GET THE SUBPOOL.
         B     $CLEANFM          GO FREE THE AREA.
$NOSERV4 L     R4,SECTIOWA       POINT TO UNIT TABLE.
         USING UNITTAB,R4
         ICM   R1,15,UNUCBL4P    POINT TO CURRENT UCB LIST.
         BZ    UNITBCLN          THERE IS NONE TO FREE.
         USING UCBLIST4,R1
         SLR   R0,R0
         ICM   R0,7,LIST4SIZ     GET THE SIZE OF THE AREA.
         IC    R15,LIST4SP       GET THE SUBPOOL.
         DROP  R1,R4             UCBLIST4, UNITTAB.
$CLEANFM FREEMAIN RU,LV=(0),A=(1),SP=(15)
UNITBCLN DS    0H
.$CLNUP  ANOP
         ICM   R0,15,SIZEDSST    ANY DSST COPY AREA TO FREE?
         BZ    XADSSTOK          NO.
         L     R1,AREADSST       YES, POINT TO THE AREA.
         FREEMAIN RU,LV=(0),A=(1),SP=SUBPOOL
         XC    SIZEDSST(8),SIZEDSST  CLEAR OLD DATA.
XADSSTOK L     R15,PRNTADDR      GET ADDRESSABILITY TO TRANSLATE TABLE.
         USING SCRNPRNT,R15
         MVI   PRTXLATE+4,X'50'  RESTORE OLD CHARACTERS FOR MONOCHROME
         MVI   PRTXLATE+6,X'7C'  SUBSTITUTION OF GREEN AND YELLOW.
         DROP  R15               SCRNPRNT.
         AIF   (&MSPMON).$CLNOK
         TM    OSBITS,X'9B'      MVS/ESA?
         BNOR  R9                NO, NO ALET TO CLEAN UP.
         ICM   R5,15,$PACALET    GET THE ALET TO DELETE.
         BZR   R9                ZERO SO NO ALET TO DELETE.
         MODESET MF=(E,MDSTSUP0)
         ALESERV DELETE,ALET=(5),CHKEAX=NO,MF=(E,ALESERVL)
         ST    R15,$PACALET      ZERO THE REMEMBERED ALET VALUE.
         MODESET MF=(E,MDSTPROB)
.$CLNOK  ANOP
         BR    R9                RETURN TO MAINLINE VIA SCREENIO.
GETCMD$$ CLI   INBUFF,1          PF1/13?
         BE    GIVEHLP$          YES, HELP.
         CLI   INBUFF,5          PF5/17?
         BE    $PACGRAF          YES, TOGGLE GRAPHIC MODE.
         CLI   INBUFF,7          PF7/19?
         BE    $PACPFUP          YES, SCROLL UP.
         CLI   INBUFF,8          PF8/20?
         BE    $PACPFDN          YES, SCROLL DOWN.
CMDSCAN$ CLI   INCHARS,C'-'      SCROLL UP REQUESTED?
         BE    $PACUP            YES.
         CLI   INCHARS,C'+'      SCROLL DOWN REQUESTED?
         BE    $PACDOWN          YES.
         CLI   INCHARS,C'B'      BOTTOM REQUESTED?
         BE    $PACDOWN          YES.
         CLI   INCHARS,C'T'      TOP REQUESTED?
         BE    $PACUP            YES.
         CLI   INCHARS,C'U'      REQUEST FOR NEW UNIT NAME?
         BE    $PCNAME           YES.
         CLI   INCHARS,C'V'      REQUEST FOR VOLUME PREFIX?
         BE    $PACEVOL          YES.
         AIF   (&MSPMON).$NOSG
         CLI   INCHARS,C'S'      REQUEST FOR STORAGE GROUP PREFIX?
         BE    $PACEGRP          YES.
.$NOSG   ANOP
         CLI   INCHARS,C'G'      TOGGLE GRAPHIC MODE?
         BE    $PACGRAF          YES.
         CLI   INCHARS,C'D'      DATE FORMAT TOGGLE REQUEST?
         BE    $CHGDATE          YES.
         CLI   INCHARS,C' '      CONTINUE REQUESTED?
         BE    REDO$PAC          YES.
         B     GIVEHLP$          NO, SHOW HELP PANEL.
$PACPFDN ICM   R1,15,SCRLAMT     ANY SCROLL AMOUNT SPECIFIED?
         BNZ   $PACDNOK          YES, USE IT.
$PACDOWN MVI   INBUFF,8          REMEMBER 'DOWN' EXPLICITLY REQUESTED.
         CLI   INCHARS,C'M'      SCROLL DOWN MAXIMUM REQUESTED?
         BE    $PACDNMX          YES, GO DO IT.
         CLI   INCHARS,C'B'      BOTTOM REQUESTED?
         BE    $PACDNMX          YES, GO DO IT.
         CLI   INCHARS,C'+'      PLUS SUBCOMMAND?
         BNE   $PACDNPG          NO, SCROLL DOWN A PAGE.
         CLI   INCHARS+1,C'M'    YES, SCROLL DOWN MAXIMUM REQUEST?
         BE    $PACDNMX          YES, GO DO IT.
         CLI   INCHARS+1,C'0'    NO, NUMERIC OPERAND?
         BL    $PACDNPG          NO, SO SCROLL DOWN A PAGE.
         MVC   $SCRLAMT+3(1),INCHARS+1
         NI    $SCRLAMT+3,X'0F'  YES, SAVE THE NUMBER FOR DISPLAY TIME.
         B     REDO$PAC          GO CONSTRUCT A NEW SCREEN IMAGE.
$PACDNMX MVI   $SCRLAMT,X'7F'    SCROLL DOWN AS FAR AS POSSIBLE.
         B     REDO$PAC          GO CONSTRUCT A NEW SCREEN IMAGE.
$PACAUTO MVI   INBUFF,8          REMEMBER 'DOWN' EXPLICITLY REQUESTED.
$PACDNPG L     R1,LINES          GET LINES PER SCREEN.
         BCTR  R1,0
         BCTR  R1,0              GET DETAIL LINES TO SCROLL.
$PACDNOK ST    R1,$SCRLAMT       SAVE FOR FOR DISPLAY TIME.
         B     REDO$PAC          GO CONSTRUCT A NEW SCREEN IMAGE.
$PACPFUP ICM   R1,15,SCRLAMT     ANY SCROLL AMOUNT SPECIFIED?
         BNZ   $PACUPOK          YES, USE IT.
$PACUP   CLI   INCHARS,C'M'      SCROLL UP MAXIMUM REQUESTED?
         BE    $PACUPMX          YES, GO DO IT.
         CLI   INCHARS,C'T'      TOP REQUESTED?
         BE    $PACUPMX          YES, GO DO IT.
         CLI   INCHARS,C'-'      MINUS SUBCOMMAND?
         BNE   $PACUPPG          NO, SCROLL UP A PAGE.
         CLI   INCHARS+1,C'M'    YES, SCROLL UP MAXIMUM REQUEST?
         BE    $PACUPMX          YES, GO DO IT.
         CLI   INCHARS+1,C'0'    NO, NUMERIC OPERAND?
         BL    $PACUPPG          NO, SO SCROLL UP A PAGE.
         MVC   $SCRLAMT+3(1),INCHARS+1
         NI    $SCRLAMT+3,X'0F'  YES, GET THE NUMBER.
         L     R1,$SCRLAMT       GET THE REQUESTED SCROLL AMOUNT.
         B     $PACUPOK          GO PREPARE FOR SCROLL UP.
$PACUPMX SLR   R0,R0             CAUSE TOP TO BE DIRECTLY ACCESSED.
         ST    R0,$PCDSPST       ZERO TOP-OF-SCREEN DSST ADDRESS.
         B     REDO$PAC          GO CONSTRUCT A NEW SCREEN IMAGE.
$PACUPPG L     R1,LINES          GET LINES PER SCREEN.
         BCTR  R1,0
         BCTR  R1,0              GET DETAIL LINES TO SCROLL.
$PACUPOK LNR   R1,R1             MAKE IT NEGATIVE FOR UP.
         ST    R1,$SCRLAMT       SAVE FOR FOR DISPLAY TIME.
         B     REDO$PAC          GO CONSTRUCT A NEW SCREEN IMAGE.
         AIF   (&MSPMON).$XANAME
$PACEGRP SLR   R1,R1
         CLI   INCHARS+1,C'/'    ERASE PREVIOUS PREFIX REQUEST?
         BE    NO$PCGRP          YES, DO IT.
$GETSGRP LA    R1,$STORNMP
         LA    R0,$STORLEN       FULL SCREEN TPUT THE PROMPT MESSAGE.
         BAS   R14,SCREENIO      ISSUE PROMPT AND GET PREFIX.
         TM    MODESW2,XFLG      SUBROUTINE EXIT REQUIRED?
         BO    $CLEANUP          YES, CLEANUP AND EXIT.
         CLI   INBUFF+4,0        INPUT FROM THE FIRST SCREEN LINE?
         BE    $GETSGRP          YES, UNEXPECTED SO REDRIVE THE PROMPT.
         MVC   $STORNAM,INCHARS  EXTRACT SPECIFIED PREFIX.
         LH    R1,TGETLEN        GET LENGTH OF INPUT STREAM.
         AHI   R1,-6             GET LENGTH OF TEXT.
NO$PCGRP STH   R1,$PRFXLEN       STORE PREFIX LENGTH.
         XC    $STORNAM,$STORNAM ERASE PREVIOUS STORAGEEGROUP.NAME.
         BCTR  R1,0              DECREMENT FOR EXECUTE.
         LTR   R1,R1             ANY PREFIX SUPPLIED?
         BM    REDO$PAC          NO.
         EX    R1,LODGRPNM       EXTRACT SPECIFIED PREFIX.
         B     REDO$PAC          SHOW SAME TIMESPAN FOR NEW GROUP MASK.
LODGRPNM MVC   $STORNAM(0),INCHARS              <<< EXECUTED >>>
$PCNAME  TM    OSLEVEL,X'88'     UCB SERVICES AVAILABLE?
         BO    ISNOUCBL          YES, DO NOT FREE UCB ADDRESS LIST.
         L     R4,SECTIOWA       POINT TO UNIT TABLE.
         USING UNITTAB,R4
         ICM   R1,15,UNUCBL4P    POINT TO CURRENT UCB LIST.
         BZ    ISNOUCBL          THERE IS NONE.
         USING UCBLIST4,R1
         SLR   R0,R0
         ICM   R0,7,LIST4SIZ     GET THE SIZE OF THE AREA.
         IC    R15,LIST4SP       GET THE SUBPOOL.
         DROP  R1                UCBLIST4.
         FREEMAIN RU,LV=(0),A=(1),SP=(15)
         XC    UNUCBL4P,UNUCBL4P ERASE PREVIOUS UCB LIST POINTER.
         MVC   UNITNM,BLANKS     CLEAR UNIT NAME.
ISNOUCBL CLI   INCHARS+1,C'/'    REMOVE UNIT RESTRICTION REQUEST?
         BE    $ALLUNIT          YES, RESTRICT ONLY BY VOLUME PREFIX.
$GETUNIT MVI   $UNITNMP,X'C1'    NO, RESET WCC FOR PROMPT.
         LA    R0,$UNITLEN
$PCNAMEX LA    R1,$UNITNMP       FULL SCREEN TPUT THE PROMPT MESSAGE.
         BAS   R14,SCREENIO      ISSUE PROMPT AND GET PREFIX.
         TM    MODESW2,XFLG      SUBROUTINE EXIT REQUIRED?
         BO    $CLEANUP          YES, CLEANUP AND EXIT.
         CLI   INBUFF+4,0        INPUT FROM THE FIRST SCREEN LINE?
         BE    $GETUNIT          YES, UNEXPECTED SO REDRIVE THE PROMPT.
         MVC   $UNITNAM,INCHARS  EXTRACT SPECIFIED ENTRY NAME.
         CLC   $UNITNAM,BLANKS   NULL NAME?
         BE    $ALLUNIT          YES, RESTRICT ONLY BY VOLUME PREFIX.
         TM    OSLEVEL,X'88'     UCB SERVICES AVAILABLE?
         BNO   $NOSERV5          NO.
         ICM   R0,15,SECTIOWA    YES, HAS LIST AREA BEEN GETMAINED?
         BNZ   $EDTINFO          YES.
         LA    R4,32             NO.
         SLL   R4,10             GET 32K.
         LR    R0,R4             SET GETMAIN AMOUNT.
         GETMAIN RU,LV=(0),SP=SUBPOOL,LOC=(ANY)
         ST    R1,SECTIOWA       SAVE DEVICE NUMBER LIST ADDRESS.
         ST    R4,0(,R1)         SAVE DEVICE NUMBER LIST SIZE.
$EDTINFO EDTINFO RTNDEVN,        REQUEST DEVICE NUMBER LIST            +
               UNITNAME=$UNITNAM,        FOR THIS UNIT.                +
               DYNAMIC=YES,                                            +
               DEVNLIST=SECTIOWA,                                      +
               RANGE=ALL,                                              +
               LOC=ANY,                                                +
               MF=S
         B     $CHKUNIT          CHECK SUCCESS.
$NOSERV5 MVC   UNITNM,$UNITNAM   INITIALIZE UNIT NAME.
         LA    R1,SECTIOWA       NO, POINT TO PARAMETER LIST.
         LINK  EPLOC=EB4UVNAM    INVOKE IEFEB4UV FOR UCB ADDRESS LIST.
$CHKUNIT MVI   $UNITNMP,X'C5'    PREPARE WCC FOR ERROR RE-PROMPT.
         LA    R0,$UNITLNX       PREPARE FOR ERROR.
         LTR   R15,R15           UCB LIST SUCCESSFULLY SUPPLIED?
         BNZ   $PCNAMEX          NO, UNIT NAME NOT IN THE EDT.
         B     REDO$PAC          SHOW SAME TIMESPAN FOR NEW UNIT NAME.
         DROP  R4,R5             UNITTAB, DSST.
         AGO   .$NAMEOK
.$XANAME ANOP
$PCNAME  L     R7,=A(UPRFXLEN)   GET ADDRESSABAILITY TO SELUCBID.
         USING UPRFXLEN,R7
         XC    SELUCBID,SELUCBID ERASE PREVIOUS UCB NAME.
         SLR   R1,R1
         CLI   INCHARS+1,C'/'    ERASE PREVIOUS PREFIX REQUEST?
         BE    NO$PCUCB          YES, DO IT.
$GETUCBN LA    R1,UPRFXMSG
         LA    R0,SELUCLEN       FULL SCREEN TPUT THE PROMPT MESSAGE.
         BAS   R14,SCREENIO      ISSUE PROMPT AND GET PREFIX.
         TM    MODESW2,XFLG      SUBROUTINE EXIT REQUIRED?
         BO    $CLEANUP          YES, CLEANUP AND EXIT.
         CLI   INBUFF+4,0        INPUT FROM THE FIRST SCREEN LINE?
         BE    $GETUCBN          YES, UNEXPECTED SO REDRIVE THE PROMPT.
         MVC   SELUCBID,INCHARS  EXTRACT SPECIFIED PREFIX.
         LH    R1,TGETLEN        GET LENGTH OF INPUT STREAM.
         AHI   R1,-6             GET LENGTH OF TEXT.
NO$PCUCB STH   R1,UPRFXLEN       STORE PREFIX LENGTH.
         B     REDO$PAC          SHOW SAME TIMESPAN FOR NEW UCBID MASK.
         DROP  R7                UPRFXLEN.
.$NAMEOK ANOP
$PACEVOL L     R7,=A(VPRFXLEN)   GET ADDRESSABAILITY TO SELVOLID.
         USING VPRFXLEN,R7
         XC    SELVOLID,SELVOLID ERASE PREVIOUS VOLID.
         SLR   R1,R1
         CLI   INCHARS+1,C'/'    ERASE PREVIOUS PREFIX REQUEST?
         BE    NO$PCVOL          YES, DO IT.
$GETVLSR LA    R1,VPRFXMSG
         LA    R0,SELVOLEN       FULL SCREEN TPUT THE PROMPT MESSAGE.
         BAS   R14,SCREENIO      ISSUE PROMPT AND GET PREFIX.
         TM    MODESW2,XFLG      SUBROUTINE EXIT REQUIRED?
         BO    $CLEANUP          YES, CLEANUP AND EXIT.
         CLI   INBUFF+4,0        INPUT FROM THE FIRST SCREEN LINE?
         BE    $GETVLSR          YES, UNEXPECTED SO REDRIVE THE PROMPT.
         MVC   SELVOLID,INCHARS  EXTRACT SPECIFIED PREFIX.
         LH    R1,TGETLEN        GET LENGTH OF INPUT STREAM.
         AHI   R1,-6             GET LENGTH OF TEXT.
NO$PCVOL STH   R1,VPRFXLEN       STORE PREFIX LENGTH.
         B     REDO$PAC          SHOW SAME TIMESPAN FOR NEW VOLID MASK.
         DROP  R7                VPRFXLEN.
$PACGRAF XI    $FLAGS,$GRAFON    TOGGLE GRAPHIC MODE.
         B     REDO$PAC          SHOW NEW DISPLAY MODE FOR SAME DATA.
$CHGDATE XI    $FLAGS,$DATEFMT   TOGGLE YY.DDD/YYMMDD DATE FORMATS.
         B     REDO$PAC          SHOW NEW DATE FORMAT FOR SAME DATA.
GIVEHLP$ MVC   INBUFF(8),SBLST   REQUEST SUBCOMMAND LIST FROM TUTORIAL.
         MVI   TGETLEN+1,8       SUPPLY LENGTH OF INPUT TO PARSE.
         LNR   R0,R11            MAKE REGISTER 0 NEGATIVE FOR PARSE.
         B     PUTSCRN$          GO DISPLAY HELP PANEL.
         SPACE 2
R4ACCES$ DS    0H                MAKE GPR 4 ADDRESS RELEVANT DATA.
         AIF   (&MSPMON).$R4AX
         TM    OSBITS,X'9B'      MVS/ESA?
         BOR   R14               YES, USING ACCESS REGISTERS.
.$R4AX   ANOP
         STM   R14,R12,12(R13)   SAVE REGISTERS.
         LA    R3,X'80'          USE STORAGE KEY EIGHT.
         LR    R8,R0             GET THE LENGTH OF DATA TO FETCH.
         LA    R7,SECTCT         POINT TO THE TARGET AREA.
         XC    0(256,R7),0(R7)   RESET RESIDUAL DATA.
         MVCP  0(R8,R7),0(R4),R3 FETCH THE DATA.
         LM    R14,R12,12(R13)   RESTORE REGISTERS.
         LA    R4,SECTCT         POINT TO THE FETCHED DATA.
         BR    R14
         SPACE
R5ACCES$ DS    0H                MAKE GPR 5 ADDRESS RELEVANT DATA.
         AIF   (&MSPMON).$R5AX
         TM    OSBITS,X'9B'      MVS/ESA?
         BOR   R14               YES, USING ACCESS REGISTERS.
.$R5AX   ANOP
         STM   R14,R12,12(R13)   SAVE REGISTERS.
         LA    R3,X'80'          USE STORAGE KEY EIGHT.
         LTR   R8,R0             GET THE LENGTH OF DATA TO FETCH.
         BP    R5L$OKAY          POSITIVE LENGTH SO PROCEED.
         LA    R8,4              FETCH DSST SIZE FIRST.
R5L$OKAY LA    R7,SECTCT+256     POINT TO THE TARGET AREA.
         XC    0(256,R7),0(R7)   RESET RESIDUAL DATA.
         MVCP  0(R8,R7),0(R5),R3 FETCH THE DATA.
         LTR   R0,R0             DSST FETCH REQUEST?
         BNP   R5ACDSST          YES.
         LM    R14,R12,12(R13)   RESTORE REGISTERS.
         LA    R5,SECTCT+256     POINT TO THE FETCHED DATA.
         BR    R14
R5ACDSST L     R8,SECTCT+256     GET THE SIZE OF WHOLE DSST.
         C     R8,SIZEDSST       ENOUGH ROOM FOR WHOLE DSST?
         BNH   R5$GETOK          YES, FETCH THE DSST.
         L     R9,PSAAOLD        GET CURRENT ASCB.
         LH    R9,ASID(,R9)      GET CURRENT ASID.
         SSAR  R9                GET OUT OF CROSS-MEMORY MODE.
         ICM   R0,15,SIZEDSST    GET THE PREVIOUS DSST SIZE.
         BZ    $GETDSST          THIS IS THE FIRST SO SKIP FREEMAIN.
         L     R1,AREADSST       GET THE PREVIOUSLY GOT ADDRESS.
         FREEMAIN RU,LV=(0),A=(1),SP=SUBPOOL
$GETDSST LR    R0,R8             GET THE LATEST SIZE OF WHOLE DSST.
         ST    R0,SIZEDSST       SAVE IT.
         GETMAIN RU,LV=(0),SP=SUBPOOL,LOC=(ANY,ANY)
         ST    R1,AREADSST       SAVE LATEST ADDRESS OF DSST COPIES.
         L     R4,$GATASID       GET TARGET ASID.
         SSAR  R4                RESUME CROSS-MEMORY MODE.
R5$GETOK L     R7,AREADSST       GET TARGET AREA ADDRESS.
         LA    R0,256            GET LARGEST COPY CHUNK.
R5$GETLP MVCP  0(R8,R7),0(R5),R3 FETCH UP TO 256 BYTES OF DSST.
         BZ    R5$GETDN          LAST CHUNK DONE SO FINISH UP.
         AR    R7,R0             POINT TO NEXT TARGET CHUNK.
         AR    R5,R0             POINT TO NEXT SOURCE CHUNK.
         SR    R8,R0             DECREASE REMAINING LENGTH.
         B     R5$GETLP          FETCH NEXT DSST CHUNK.
R5$GETDN LM    R14,R12,12(R13)   RESTORE REGISTERS.
         L     R5,AREADSST       POINT TO THE FETCHED DATA.
         BR    R14
         SPACE 2
         DROP  R11,R10           DSK$PACE.
         TITLE 'DISK SPACE STATUS DISPLAY - VARIABLES AND CONSTANTS'
DG$TOKEN DC    D'0'              SPACE MONITOR SPACE TOKEN.
IMPMAJNM DC    CL8'IMPMAJOR'
IMPMINNM DC    C'IMPSPACER ACTIVE'
IMINORLN EQU   *-IMPMINNM
         AIF   (&MSPMON).$NOALET
EB4UVNAM DC    CL8'IEFEB4UV'
$PACALET DC    F'0'              ALET FOR SPACE MONITOR ADDRESS SPACE.
.$NOALET ANOP
GQ$TOKEN DC    F'0'              GQSCAN TOKEN.
$GTCBADR DC    F'0'              SPACE MONITOR TCB ADDRESS.
$GATASID DC    F'0'              SPACE MONITOR ASID.
$TATADRS DS    0F                CURRENT STATUS AREA.
$BASEADR DC    F'0'              SPACE MONITOR BASE ENTRY ADDRESS.
$PCDSPST DC    F'0'              ADDRESS OF FIRST DSST ON SCREEN PAGE.
$SCRLAMT DC    X'7F000000'       LINES TO SCROLL.
$TATADLN EQU   *-$TATADRS        CURRENT STATUS AREA LENGTH.
SIZEDSST DC    F'0'        \     SIZE OF DSST TO FETCH.
AREADSST DC    F'0'        /     ADDRESS OF DSST FETCH TARGET AREA.
$PACERRS DC    CL32'DISK SPACE MONITOR IS NOT ACTIVE'    ERROR 0.
         AIF   (&MVSMON).$ALSRVM
         DC    CL32'$BADMSG1 - MVS/ESA BAD ALESERV  '    ERROR 1.
         AGO   .$ERMSG1
.$ALSRVM ANOP
$BADMSG1 DC    CL32'   ALESERV ADD FAILED - RC=??   '    ERROR 1.
.$ERMSG1 ANOP
*DEVTBL  DS    0F                TRKS/CYL, KB/TRK, CYLS DEVICE TABLE.
*        DC    AL1(00,00),H'0'                 NULL.
*        DC    AL1(10,10),H'0'          2001 - 2311.
*        DC    AL1(200,0),H'0'          2002 - 2301 DRUM.
*        DC    AL1(10,00),H'0'          2003 - 2303 DRUM.
*        DC    AL1(46,00),H'0'          2004 - 2302.
*        DC    AL1(15,45),H'1440'   30102004 - 9345.
*        DC    AL1(10,00),H'0'          2005 - 2321 DATA CELL.
*        DC    AL1(08,14),H'48'         2006 - 2305-1 FIXED HEAD DISK.
*        DC    AL1(08,14),H'96'     30502007 - 2305-2 FIXED HEAD DISK.
*        DC    AL1(20,07),H'200'        2008 - 2314/2319.
*        DC    AL1(19,12),H'404'    30502009 - 3330.   (7 ALT CYL)
*        DC    AL1(12,00),H'0'      3040200A - 3340.
*        DC    AL1(30,18),H'555'    3050200B - 3350.   (2 ALT CYL)
*        DC    AL1(12,42),H'960'    3010200C - 3375.   (INCL. ALT)
*        DC    AL1(19,12),H'808'    3050200D - 3330-1. (7 ALT CYL)
*        DC    AL1(15,46),H'885'    3010200E - 3380.   (1 ALT CYL)
*        DC    AL1(15,50),H'1113'   3010200F - 3390.
$CNTRS   DS    0F                DSSTE STATISTICS ACCUMULATORS.
FREECYLS DC    F'0'
FREETRKS DC    F'0'
FREEEXTS DC    F'0'
FREEMEGS DC    F'0'
LARGCYLS DC    F'0'
LARGTRKS DC    F'0'
ALLDDSCT DC    F'0'
OPNDCBCT DC    F'0'
GOODVOLS DC    F'0'
LARGMEGS DC    F'0'
TOTALMEG DC    F'0'
$CTLN    EQU   *-$CNTRS          SIZE OF ALL DSST COUNTERS TO BE RESET.
         AIF   (&MSPMON).$NOGPL
$PRFXLEN DC    H'0'              STORAGE GROUP NAME PREFIX LENGTH.
.$NOGPL  ANOP
$FLAGS   DC    X'00'
$GRAFON  EQU   X'80'             GRAPHIC/TABULAR FORMAT SWITCH.
$DATEFMT EQU   X'40'             JULIAN/YMD DATE FORMAT SWITCH.
*        EQU   X'20'             UNUSED.
*        EQU   X'10'             UNUSED.
*        EQU   X'08'             UNUSED.
*        EQU   X'04'             UNUSED.
*        EQU   X'02'             UNUSED.
*        EQU   X'01'             UNUSED.
$PACLINE EQU   *,79
$DATE    DC    CL6'YY.DDD'
         DC    CL1' '
$TIME    DC    CL5'HH:MM'
$FREECYL DC    CL8' '
$FREETRK DC    CL10' '
$FREEMEG DC    CL10' '
$FREEPCT DC    CL4' '
$FREEEXT DC    CL6' '
$FILLER  DC    CL1' '
$LARGCYL DC    CL8' '
$LARGTRK DC    CL6' '
$DDUSAGE DC    CL8' '
$DCBOPEN DC    CL6' '
HEADING$ DC    CL71' DISK FREE SPACE:     0 OF TOTAL DASD              +
                                   '           ZZZZ9      IN UNIT=SYSAL
*              LDA (VOL=SER=******)'
SUBHDG$$ DC    CL79' DATE  TIME UNUSED-CYLS+TRACKS MEGABYTES PCT XTNTS +
               LARGEST-CONTIG #ALLOCS #OPEN'
SUBHDGG$ DC    CL79' DATE  TIME  PCT ----+---2+0---+---4+0---+---6+0---+
               +---8+0---+----% #ALCS #OPEN'
         SPACE
         LTORG
         SPACE
         AIF   (&MSPMON).$END
$UNITNMP DC    X'C11140403C404000'
         DCS   SBA,(5,3)
         DC    X'&LOW'
         DC    C'ENTER DASD UNIT NAME REQUIRED FOR FREE SPACE REPORT'
         DCS   SBA,(7,3)
         DC    X'&MED',C'===>',X'1BC94E132841F4'
$UNITNAM DC    X'0000000000000000'
         DC    X'2841001BF0C2'
         DCS   SBA,(12,3)
         DC    X'&LOW'
         DC    C'(USE',X'&HIGH',C'U/',X'&LOW',C'FROM DETAIL SCREEN '
         DC    C'TO CANCEL UNIT NAME SELECTION)'
$UNITLEN EQU   *-$UNITNMP
         DCS   SBA,(17,3)
         DC    X'&HIGH'
         DC   C'REENTER - SPECIFIED UNIT NAME WAS NOT FOUND IN THE EDT'
$UNITLNX EQU   *-$UNITNMP
         SPACE
$STORNMP DC    X'C11140403C404000'
         DCS   SBA,(5,3)
         DC    X'&LOW'
         DC    C'ENTER SMS STORAGE GROUP NAME REQUIRED FOR FREE SPACE R+
               EPORT'
         DCS   SBA,(7,3)
         DC    X'&MED',C'===>',X'1BC94E132841F4'
$STORNAM DC    X'0000000000000000'
         DC    X'2841001BF0C2'
         DCS   SBA,(12,3)
         DC    X'&LOW'
         DC    C'(USE',X'&HIGH',C'S/',X'&LOW',C'FROM DETAIL SCREEN '
         DC    C'TO CANCEL STORAGE GROUP NAME SELECTION)'
         DCS   SBA,(15,4)
         DC    C'(USE',X'&HIGH',C'*',X'&LOW'
         DC    C'FOR NON-SPECIFIC PLACE-HOLDER CHARACTERS)'
$STORLEN EQU   *-$STORNMP
         DC    X'11D1E2&HIGH'
         SPACE
.$END    ANOP
         DS    0H
